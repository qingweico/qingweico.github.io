<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #81C785; /*进度条颜色*/
        height: 1px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #81C785, 0 0 5px     #81C785; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color:#81C785;    /*上边框颜色*/
        border-left-color:#81C785;    /*左边框颜色*/
    }
</style>
  <link rel="apple-touch-icon" sizes="180x180" href="https://cdn.qingweico.cn/blog/fe4500031cb6f024b4d7.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://cdn.qingweico.cn/blog/fe4500031cb6f024b4d7.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://cdn.qingweico.cn/blog/fe4500031cb6f024b4d7.png">
  <link rel="mask-icon" href="https://cdn.qingweico.cn/blog/fe4500031cb6f024b4d7.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Deep understanding of the Java Virtual Machine[TOC]  1 类加载器1.1 类的加载过程 加载  1231: 通过一个类的全限定名称获取此类的二进制字节流2: 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构3: 在内存中生成一个代表这个类的java.lang.Class对象, 作为方法区这个类的各种数据的访问入口   链接 验证 文件">
<meta property="og:type" content="article">
<meta property="og:title" content="Deep understanding of the Java Virtual Machine(third edition)">
<meta property="og:url" content="http://example.com/2020/06/09/Deep-understanding-of-the-Java-Virtual-Machine-third-edition/index.html">
<meta property="og:site_name" content="流金岁月">
<meta property="og:description" content="Deep understanding of the Java Virtual Machine[TOC]  1 类加载器1.1 类的加载过程 加载  1231: 通过一个类的全限定名称获取此类的二进制字节流2: 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构3: 在内存中生成一个代表这个类的java.lang.Class对象, 作为方法区这个类的各种数据的访问入口   链接 验证 文件">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.qingweico.cn/blog/601773e53ffa7d37b3a530f6.png">
<meta property="og:image" content="https://cdn.qingweico.cn/blog/604e1e0d5aedab222c229f9b.png">
<meta property="og:image" content="https://cdn.qingweico.cn/blog/603658cc5f4313ce25534991.png">
<meta property="og:image" content="https://cdn.qingweico.cn/blog/60379b175f4313ce25471152.png">
<meta property="og:image" content="https://cdn.qingweico.cn/blog/60379b0f5f4313ce25470a05.png">
<meta property="og:image" content="https://cdn.qingweico.cn/blog/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg">
<meta property="article:published_time" content="2020-06-09T08:21:44.000Z">
<meta property="article:modified_time" content="2022-02-17T10:46:05.000Z">
<meta property="article:author" content="启明">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.qingweico.cn/blog/601773e53ffa7d37b3a530f6.png">

<link rel="canonical" href="http://example.com/2020/06/09/Deep-understanding-of-the-Java-Virtual-Machine-third-edition/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Deep understanding of the Java Virtual Machine(third edition) | 流金岁月</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="流金岁月" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">流金岁月</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">流金岁月</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/09/Deep-understanding-of-the-Java-Virtual-Machine-third-edition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.qingweico.cn/blog/53fd3cbe09ce49fe809c0dbb32a2f232.jfif">
      <meta itemprop="name" content="启明">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="流金岁月">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Deep understanding of the Java Virtual Machine(third edition)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-09 16:21:44" itemprop="dateCreated datePublished" datetime="2020-06-09T16:21:44+08:00">2020-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-17 18:46:05" itemprop="dateModified" datetime="2022-02-17T18:46:05+08:00">2022-02-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>30k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>27 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Deep-understanding-of-the-Java-Virtual-Machine"><a href="#Deep-understanding-of-the-Java-Virtual-Machine" class="headerlink" title="Deep understanding of the Java Virtual Machine"></a>Deep understanding of the Java Virtual Machine</h1><p>[TOC]</p>
<p><em><img src="https://cdn.qingweico.cn/blog/601773e53ffa7d37b3a530f6.png"></em></p>
<h2 id="1-类加载器"><a href="#1-类加载器" class="headerlink" title="1 类加载器"></a>1 类加载器</h2><h3 id="1-1-类的加载过程"><a href="#1-1-类的加载过程" class="headerlink" title="1.1 类的加载过程"></a>1.1 类的加载过程</h3><ul>
<li>加载</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1</span>: <span class="string">通过一个类的全限定名称获取此类的二进制字节流</span></span><br><span class="line"><span class="attr">2</span>: <span class="string">将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</span></span><br><span class="line"><span class="attr">3</span>: <span class="string">在内存中生成一个代表这个类的java.lang.Class对象, 作为方法区这个类的各种数据的访问入口</span></span><br></pre></td></tr></table></figure>

<ul>
<li>链接<ul>
<li>验证<ul>
<li>文件格式的验证(openjdk&#x2F;hotspot&#x2F;src&#x2F;share&#x2F;vm&#x2F;classfile&#x2F;classFileParser.cpp)</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ul>
</li>
<li>准备</li>
<li>解析</li>
</ul>
</li>
<li>初始化</li>
</ul>
<span id="more"></span>

<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">执行类构造器方法&lt;clinit&gt;()</span></span><br><span class="line"><span class="attr">此方法不需要定义,</span> <span class="string">是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来</span></span><br><span class="line"><span class="attr">构造器方法中指令按语句在源文件中出现的顺序执行</span></span><br><span class="line"><span class="attr">&lt;clinit&gt;不同于类的构造器(关联</span>: <span class="string">构造器是虚拟机视角下的&lt;init&gt;())</span></span><br><span class="line"><span class="attr">若该类具有父类,</span> <span class="string">JVM会保证子类的&lt;clinit&gt;()执行前, 父类的&lt;clinit&gt;()已经执行完毕</span></span><br><span class="line"><span class="attr">虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁</span></span><br></pre></td></tr></table></figure>

<p>对于初始化阶段 《Java虚拟机规划》 严格定义了有且只有六种情况必须对类进行初始化</p>
<ul>
<li>遇到 new 、getstatic、putstatic或者invokestatic 这四条字节码指令时</li>
<li>使用java.lang.reflect包的方法对类型进行反射调用的时候</li>
<li>当类初始化的时候 如果发现其父类还没有进行初始化的时候 则需要先触发其父类的初始化</li>
<li>当虚拟机启动时用户需要指定一个要执行的主类 虚拟机首先会初始化这个类(即包含main方法的那个类)</li>
<li>当使用JDK 7新加入的动态语言支持时 如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic REF_putStatic REF_invokeStatic REF_newInvokeSpecial 四种类型的方法句柄 并且这个方法句柄对应的类没有进行过初始化</li>
<li>当接口中定义JDK 8中新加入的默认方法时 如果这个接口的实现类发生了初始化 那该接口要在其之前被初始化</li>
</ul>
<h3 id="1-2-类加载器的分类"><a href="#1-2-类加载器的分类" class="headerlink" title="1.2 类加载器的分类"></a>1.2 类加载器的分类</h3><ul>
<li>引导类加载器(Bootstrap Class Loader) : <ul>
<li>系统类加载器(System(Application) Class Loader)         classpath</li>
<li>扩展类加载器(Extension Class Loader)                           jre目录下 lib&#x2F;ext</li>
</ul>
</li>
<li>自定义类加载器(User-Defined Class Loader)</li>
</ul>
<p><strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器(不包括引导类加载器)</strong></p>
<p>引导类加载器：使用C&#x2F;C++代码实现, 嵌套在JVM内部</p>
<p>系统类加载器(AppClassLoader)：程序中通过默认的类加载器</p>
<p>OSGi模型</p>
<h3 id="1-3-双亲委派机制"><a href="#1-3-双亲委派机制" class="headerlink" title="1.3 双亲委派机制"></a>1.3 双亲委派机制</h3><p>工作原理:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1&gt;</span>: <span class="string">如果一个类加载器收到了类加载请求, 它并不会自己先去加载, 而是把这个请求委托给父类的加载器去执行</span></span><br><span class="line"><span class="attr">2&gt;</span>: <span class="string">如果父类加载器还存在其父类加载器, 则近一步向上委托, 依次递归, 请求最终到达顶层的启动类加载器</span></span><br><span class="line"><span class="attr">3&gt;</span>: <span class="string">如果父类加载器可以完成类加载任务, 就成功返回, 倘若父类加载器无法完成此加载任务, 子加载器才会尝试自己去加载, 这就是双亲委派机制</span></span><br></pre></td></tr></table></figure>

<p>在JVM中表示两个class对象是否为同一个类存在的两个必要条件</p>
<ul>
<li>类的完整类名必须一致, 包括包名</li>
<li>加载这个类的ClassLoader(指ClassLoader实例对象)必须相同</li>
</ul>
<p>对类加载器的引用：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">JVM必须知道一个类型是由引导类加载器加载的还是由用户类加载器加载的.</span></span><br><span class="line"><span class="attr">如果一个类型是由用户类加载器加载的,</span> <span class="string">那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法去中.</span></span><br><span class="line"><span class="attr">当解析一个类型到另外一个类型的引用的时候,</span> <span class="string">JVM需要保证这两个类型的类加载器是相同的.</span></span><br></pre></td></tr></table></figure>

<h2 id="2-运行时数据区"><a href="#2-运行时数据区" class="headerlink" title="2 运行时数据区"></a>2 运行时数据区</h2><p>方法区和堆有GC, 虚拟机栈和本地方法区以及程序计数器则没有GC</p>
<p>方法区和堆为所有线程所共享, 而虚拟机栈和本地方法区以及程序计数器则每个线程各有一份</p>
<h3 id="2-1-PC寄存器"><a href="#2-1-PC寄存器" class="headerlink" title="2.1 PC寄存器"></a>2.1 PC寄存器</h3><p>程序计数器也叫PC寄存器(Program Counter Register)</p>
<p>JVM中PC寄存器是对物理寄存器的一种抽象模拟</p>
<p>程序计数器是唯一一个在JVM中没有规定任何OutOfMemoryError情况的的区域</p>
<p>PC寄存器的作用：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PC寄存器用来存储指向下一条指令的地址(偏移地址),</span> <span class="string">即将要执行的指令代码, 由执行引擎读取下一条指令.</span></span><br></pre></td></tr></table></figure>

<p>PC寄存器被设定为线程私有的原因:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">在多线程环境中,</span> <span class="string">一个特定的时间段只会执行其中某一个线程的方法, CPU会不停地做任务切换, 这样必然会导致线程中断和恢复, 为了能够准确地记录各个线程正在执行地当前字节码指令地址, 最好的办法自然是为每一个线程都分配一个PC寄存器, 这样一来各个线程之间便可以进行独立计算, 从而不会出现相互干扰的情况.</span></span><br></pre></td></tr></table></figure>

<p>CPU时间片即CPU分配给各个程序的时间, 每个线程被分配一个时间段,  称作它的时间片</p>
<p>如果线程正在执行的是一个Java方法 pc记录的是正在执行的虚拟机字节码指令的地址 如果正在执行的是本地方法 pc的值应该为空</p>
<h3 id="2-2-虚拟机栈"><a href="#2-2-虚拟机栈" class="headerlink" title="2.2 虚拟机栈"></a>2.2 虚拟机栈</h3><p>由于跨平台的设计, Java的指令都是根据栈来设计的, 因为不同平台CPU架构不同, 所以不能设计为基于寄存器的</p>
<p>虚拟机栈的 <strong>优点</strong>是: 指令集小, 编译器容易实现 <strong>缺点</strong>是性能下降, 实现同样的功能需要更多的指令</p>
<p>作用: 主管Java程序的运行, 它保存方法的局部变量、部分结果, 并参与方法的调用和返回</p>
<p>生命周期: 生命周期和线程一致</p>
<p>每个线程在创建时都会创建一个虚拟机栈, 其内部保存一个个的栈帧(Stack Frame), 对应着一次次Java方法调用</p>
<p>栈的特点：</p>
<ul>
<li>栈是一种快速有效的分配存储方式, 访问速度仅次于PC寄存器</li>
<li>JVM直接对虚拟机栈的操作只有两个<ul>
<li>每个方法执行, 伴随着进栈(入栈、压栈)</li>
<li>执行结束后的出栈工作</li>
</ul>
</li>
<li>对于栈来说不存在垃圾回收问题(但是存在OOM和SOF问题)</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-Xss1k/1m/1g</span> <span class="string">设置虚拟机栈内存的大小</span></span><br><span class="line"><span class="attr">-Xss1024</span> <span class="string">不加单位默认为字节</span></span><br></pre></td></tr></table></figure>

<p>栈运行原理:</p>
<ul>
<li>不同线程中所包含的栈帧是不允许存在相互引用的, 即不可能在一个栈帧之中引用另外一个线程的帧.</li>
<li>如果当前方法调用了其他方法, 方法返回之际, 当前栈帧回传会此方法的执行结果给前一个栈帧, 接着, 虚拟机会丢弃当前栈帧, 使得前一个栈帧重新成为当前栈帧.</li>
<li>Java方法有两种返回函数的方式, 一种是正常的函数返回, 使用return指令; 另一种是抛出异常. 不管使用哪种方式, 都会导致栈帧被弹出.</li>
</ul>
<h4 id="2-2-1-栈帧的内部结构"><a href="#2-2-1-栈帧的内部结构" class="headerlink" title="2.2.1 栈帧的内部结构"></a>2.2.1 栈帧的内部结构</h4><p>每个栈帧中储存着：</p>
<ul>
<li>局部变量表(Local Variables)</li>
<li>操作数栈(Operand Stack)(或表达式栈)</li>
<li>动态链接(Dynamic Linking)(或指向运行时常量池的方法引用)</li>
<li>方法返回地址(Return Address)(或方法正常退出或者异常退出的定义)</li>
<li>一些附加信息</li>
</ul>
<h4 id="2-2-2-局部变量表"><a href="#2-2-2-局部变量表" class="headerlink" title="2.2.2 局部变量表"></a>2.2.2 局部变量表</h4><ul>
<li>局部变量表也称之为局部变量数组或本地变量表</li>
<li>定义为一个数字数组, 主要用来储存方法参数和定义在方法体内的的局部变量, 这些数据类型包括各类基本数据类型、对象引用(reference类型 它并不等同于对象本身 可能是指向一个对象起始地址的引用指针 也可能指向一个代表对象的句柄或者其他与此对象相关的位置),  以及returnAddress(指向了一条字节码指令地址)类型</li>
<li>由于局部变量表是建立在线程的栈上, 是线程的私有数据, 因此不存在数据安全问题</li>
<li>局部变量表所需的容量大小是在编译期确定下来的, 并保存在方法的Code属性的maximun local variables数据项中。在方法运行期间是不会改变局部变量表的大小的</li>
<li>方法嵌套的次数由栈的大小决定。一般来说,栈越大, 方法嵌套调用次数越多。对一个函数而言,它的参数和局部变量越多, 使得局部变量表膨胀, 它的帧就越大, 以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间, 导致其嵌套调用次数就会减少</li>
<li>局部变量表只在当前方法调用中有效。在方法执行时, 虚拟机通过使用局部变量表完成参数值到参数列表的传递过程。当方法调用结束后, 随着方法栈的销毁,局部变量表也会销毁</li>
<li>局部变量表, 最基本的储存单是Slot(变量槽)</li>
<li>在《Java虚拟机规范》中对这个内存区域规定了两类异常状况: 如果线程请求的栈深度大于虚拟机所允许的深度 将抛出StackOverflowError异常; 如果Java 虚拟机栈容量可以动态扩展 当栈扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常</li>
<li>HotSpot虚拟机的栈是不支持动态扩展的</li>
</ul>
<h5 id="2-2-2-1关于Slot的理解"><a href="#2-2-2-1关于Slot的理解" class="headerlink" title="2.2.2.1关于Slot的理解"></a>2.2.2.1关于Slot的理解</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1&gt;</span> <span class="string">JVM会为局部变量表中的每一个Slot都分配一个访问索引, 通过这个索引1即可成功访问到局部变量表中指定的局部变量值</span></span><br><span class="line"><span class="attr">2&gt;</span> <span class="string">当一个实例方法调用的时候, 它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上</span></span><br><span class="line"><span class="attr">3&gt;</span> <span class="string">如果需要访问局部变量表中的一个64bit的局部变量值时, 只需要使用前一个索引即可(注:32位以内的类型只占一个和slot(包括returnAddress), 64位的类型(long和double占用两个slot))</span></span><br><span class="line"><span class="attr">4&gt;</span> <span class="string">如果当前帧是由构造方法或者实列方法创建的, 那么该对象引用this将会存放在index为0的slot处, 其余的参数按照参数顺序表顺序继续排列</span></span><br></pre></td></tr></table></figure>

<p>栈帧中局部变量表中的槽位是可以重用的, 如果一个局部变量过了其作用域, 那么在其作用域之后申明的新的局部变量可能会复用过期局部变量的槽位, 从而达到节省资源的目的</p>
<h5 id="2-2-2-2-总结"><a href="#2-2-2-2-总结" class="headerlink" title="2.2.2.2 总结"></a>2.2.2.2 总结</h5><ul>
<li>在栈帧中, 与性能调优最为密切的部分就是局部变量表, 在方法执行时, 虚拟机使用局部变量表完成方法的传递</li>
<li>局部变量中的变量也是重要的垃圾回收根节点, 只要被局部变量表中直接或者间接引用的对象都不会被回收</li>
</ul>
<h4 id="2-2-3-操作数栈"><a href="#2-2-3-操作数栈" class="headerlink" title="2.2.3 操作数栈"></a>2.2.3 操作数栈</h4><ul>
<li>操作数栈, 主要用于保存计算的中间结果, 同时作为计算过程中变量临时的储存空间</li>
<li>操作数栈就是JVM执行引擎的一个工作区, 当一个方法开始执行的时候, 一个新的栈帧也会随之被创建出来, 这个方法的操作数栈是空的</li>
<li>每一个操作数栈都会拥有一个明确的栈深度用于储存数值, 其所需的最大深度在编译器就定义好了, 保存在方法的Code属性中, 为max_stack的值</li>
<li>栈中的任何一个元素都可以是任意的Java数据类型<ul>
<li>32bit的类型占用一个栈单位深度</li>
<li>64bit的类型占用两个栈单位深度</li>
</ul>
</li>
<li>操作数栈并非采用访问索引的方式来进行数据访问的,  而是只能通过标准的入栈和出栈操作来完成一次数据访问</li>
<li>如果被调用的方法带有返回值的话, 其返回值将会被压入当前栈帧的操作数栈中, 并更新PC寄存器中下一条需要执行的字节码指令</li>
<li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配, 这由编译器在编译期间进行验证, 同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证</li>
<li>另外, 我们说Java虚拟机的解析引擎是基于栈的执行引擎, 其中的栈指的就是操作数栈</li>
</ul>
<h4 id="2-2-4-动态链接"><a href="#2-2-4-动态链接" class="headerlink" title="2.2.4 动态链接"></a>2.2.4 动态链接</h4><ul>
<li>每个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接</li>
<li>在Java源文件被编译到字节码文件中, 所有的变量和方法引用都作为符号引用(symbolic Reference) 保存在class文件的常量池里。比如描述一个方法调用了另外的其他方法时, 就是通过常量池中指向方法的符号引用来表示的, 那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</li>
</ul>
<h5 id="2-2-4-1-为什么需要常量池"><a href="#2-2-4-1-为什么需要常量池" class="headerlink" title="2.2.4.1 为什么需要常量池"></a>2.2.4.1 为什么需要常量池</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">常量池的作用就是提供一些符号和常量,</span> <span class="string">便于指令的识别以及资源的共享和复用</span></span><br></pre></td></tr></table></figure>

<h5 id="2-2-4-2-方法的调用"><a href="#2-2-4-2-方法的调用" class="headerlink" title="2.2.4.2 方法的调用"></a>2.2.4.2 方法的调用</h5><p>在JVM中, 将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p>
<ul>
<li>静态链接(静态绑定): 当一个字节码文件被装进JVM内部时, 如果被调用的目标方法在编译期可知, 且运行期保持不变, 这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</li>
<li>动态链接(动态绑定): 如果被调用的·1方法在编译期无法被确定下来, 也就是说, 只能够在程序运行期将调用方法的符号引用转换为直接引用, 由于这种引用转换过程具有动态性, 因此被称为动态链接</li>
</ul>
<h5 id="2-2-4-3-虚方法和非虚方法"><a href="#2-2-4-3-虚方法和非虚方法" class="headerlink" title="2.2.4.3 虚方法和非虚方法"></a>2.2.4.3 虚方法和非虚方法</h5><ul>
<li>普通调用指令<ul>
<li>invokestatic: 调用静态方法, 解阶段确定唯一方法版本</li>
<li>invokespecial: 调用<init>方法、私有方法以及父类方法, 解析阶段确定唯一方法版本</li>
<li>invokevirtual: 调用所有的虚方法</li>
<li>invokeinterface: 调用接口方法</li>
</ul>
</li>
<li>动态调用指令<ul>
<li>invokedunamic: 动态解析出需要调用的方法, 然后执行</li>
</ul>
</li>
</ul>
<p>前四条指令固化在虚拟机内部, 方法的调用执行不可人为干预, 而invokedynamic指令则支持由用户确定方法的版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法, 其余的(final修饰的除外)称为虚方法</p>
<h5 id="2-2-4-4-关于invokedynamic指令"><a href="#2-2-4-4-关于invokedynamic指令" class="headerlink" title="2.2.4.4 关于invokedynamic指令"></a>2.2.4.4 关于invokedynamic指令</h5><p>invokedynamic指令于Java7添加, 是为了能够让Java支持动态类型语言而做的一种改进(使用Lamabda表达式可以直接生成)</p>
<p>Java7中增加的动态类型语言支持的本质是对Java虚拟机规范的修改, 而不是对Java语言规则的修改</p>
<p>动态类型语言和静态类型语言</p>
<p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期, 满足前者就是静态类型语言, 反之是动态类型语言</p>
<p>静态类型语言是判断变量自身的类型信息; 动态类型语言是判断变量值的类型信息, 变量没有类型信息, 变量值才有类型信息</p>
<p>Java是静态类型的语言    </p>
<h4 id="2-2-5-方法返回地址"><a href="#2-2-5-方法返回地址" class="headerlink" title="2.2.5 方法返回地址"></a>2.2.5 方法返回地址</h4><p>存放调用该方法的pc寄存器的值</p>
<ul>
<li>无论方法正常退出还是异常退出都会回到该方法被调用的位置。方法正常退出时, 调用者的pc计数器的值作为返回地址, 即调用该方法的指令的下一条指令的地址, 而异常退出的, 返回地址是要通过异常表来确定, 栈帧中一般不会保存这部分信息</li>
<li>本质上, 方法的退出就是当前栈帧出栈的过程。此时, 需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等, 让调用者方法继续执行下去</li>
<li>正常完成出口和异常完成出口的区别在于: 通过异常完成出口退出的不会给它的上层调用者产生任何的返回值</li>
<li>执行引擎遇到任意一个方法返回的字节码指令(return),会有返回值传递给上层的方法调用者, 简称正常完成出口<ul>
<li>一个正常方法调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定</li>
<li>在字节码指令中, 返回指令包含ireturn(当前返回值是boolean、byte、char、short、int类型时使用)、lreturn、freturn、dreturn以及areturn(引用类型)。另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用</li>
</ul>
</li>
<li>在方法执行过程中遇到了异常, 并且这个异常没有在方法内处理, 也就是没有在本地的异常表中没有搜索到匹配的异常处理器, 就会导致方法退出, 简称异常完成出口(方法执行过程中抛出异常时的异常处理, 储存在一个处理表中)</li>
</ul>
<h4 id="2-2-6-一附加信息"><a href="#2-2-6-一附加信息" class="headerlink" title="2.2.6 一附加信息"></a>2.2.6 一附加信息</h4><p>栈帧中还允许携带与ava虚拟机实现相关的一些附加信息, 比如对程序调试提供支持的信息</p>
<h3 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h3><ul>
<li>Java虚拟机栈用于管理Java方法的调用, 而本地方法栈用于管理本地方法的调用</li>
<li>本地方法栈, 也是线程私有的</li>
<li>允许被实现成固定或者是可扩展的内存大小<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量, Java虚拟机将会抛出一个StackOverflowError异常</li>
<li>如果本地方法栈可以动态扩展, 并且在尝试扩展的时候无法申请到足够的内存, 或者在创建线程时没有足够的内存去创建对应的本地方法栈, 那么Java虚拟机将会抛出一个OutofMemoryError异常</li>
</ul>
</li>
<li>本地方法是使用C&#x2F;C++语言实现的</li>
<li>加载本地方法的具体做法是Native Method Stack中登记native方法, 在Execution Engine执行时加载本地方法库</li>
<li>当某个线程调用一个本地方法时, 它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限<ul>
<li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区</li>
<li>它甚至可以本地处理器中的寄存器</li>
<li>直接从本地内存的堆中分配任意数量的内存</li>
</ul>
</li>
<li>并不是所有的JVM都支持本地方法栈 因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构。如果JVM产品不打算支持native方法, 也可以无需实现本地方法栈</li>
<li>在HotSpot中, 直接将本地方法栈和虚拟机栈合二为一</li>
</ul>
<h3 id="2-4-堆"><a href="#2-4-堆" class="headerlink" title="2.4 堆"></a>2.4 堆</h3><ul>
<li>一个JVNM实例只存在一个堆内存, 堆也是Java内存管理的核心区域</li>
<li>Java堆内存的JVM启动的时候即被创建, 其空间大小也就确定了。堆区是JVM管理的最大一块内存空间(堆内存的大小是可以调节的)</li>
<li>《JVM虚拟机规范》规定, 堆可以处于物理上不连续的内存空间, 但是在逻辑上它应该被视为连续的</li>
<li>所有的的线程共享Java堆, 在这里还可以划分为线程私有的缓冲区(Thread Local Allocation Buffer TLAB)</li>
<li>堆, 是GC(Garbage Collection 垃圾回收器) 执行垃圾回收的重点区域</li>
<li>在方法结束后, 堆中的对象不会马上被移除, 仅仅在垃圾收集的时候才会移出(GC的启动也需要消耗系统资源, 所以GC并不会频繁的启动)</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印虚拟机参数(加号表示启用 减号表示不启用)</span></span><br><span class="line"><span class="attr">java</span> <span class="string">-XX:+PrintFlagsFinal | wc -l </span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-Xms20m</span> <span class="string">-Xmx20m(默认单位字节) -XX:+PrintGCDetails</span></span><br></pre></td></tr></table></figure>

<p>现代垃圾收集器都基于分代收集理论设计, 堆内存<strong>逻辑</strong>上细分为新生代、老年代以及元空间(Java8之前叫做永久代)</p>
<h4 id="2-4-1-堆空间大小的设置"><a href="#2-4-1-堆空间大小的设置" class="headerlink" title="2.4.1  堆空间大小的设置"></a>2.4.1  堆空间大小的设置</h4><ul>
<li><p>-Xms 用于设置堆区的起始内存(年轻代 +老年代), 等价于-XX:InitialHeapSize</p>
</li>
<li><p>-Xmx 则用于设置堆区的最大内存(年轻代 +老年代), 等价于-XX:MaxHeapSize</p>
</li>
<li><p>一旦堆区中的内存大小超过了-Xmx所指定的最大内存时, 将会抛出OutofMemoryError异常</p>
</li>
<li><p>通常会将-Xms和-Xmx两个参数配置相同的值, 其目的在于为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小, 从而提高性能</p>
</li>
<li><p>默认堆空间的大小</p>
<ul>
<li>初始内存大小:物理电脑内存 &#x2F; 64</li>
<li>最大内存大小: 物理内存大小 &#x2F; 4</li>
</ul>
</li>
<li><p>查看设置堆空间的参数的详细信息</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式一</span></span><br><span class="line"><span class="attr">1&gt;</span> <span class="string">jps</span></span><br><span class="line"><span class="attr">2&gt;</span> <span class="string">jstat -gc pid</span></span><br><span class="line"><span class="comment">#方式二</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">PrintGCDetails</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-4-2-年轻代和老年代"><a href="#2-4-2-年轻代和老年代" class="headerlink" title="2.4.2  年轻代和老年代"></a>2.4.2  年轻代和老年代</h4><ul>
<li><p>储存在JVM中Java对象可以被划分为两类</p>
<ul>
<li>一类是生命周期较短的瞬时对象, 这类对象的创建和消亡都非常迅速</li>
<li>另外一类对象的生命周期却非常长, 在某些极端情况下还能够与JVM的生命周期保持一致</li>
</ul>
</li>
<li><p>Java堆区进一步细分的话, 可以划分为年轻代(YoungGen)和老年代(OldGen)</p>
</li>
<li><p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间(有时也叫from区、to区 s0&#x2F;s1 空的为to区)</p>
</li>
<li><p>配置年轻代和老年代在堆结构的占比</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-XX</span>:<span class="string">NewRatio=2 表示新生代占1.老年代占2, 新生代占整个堆的1/3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看默认年轻代和老年代在堆结构的占比</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前所有java进程pid</span></span><br><span class="line"><span class="attr">jps</span></span><br><span class="line"><span class="comment"># 查看默认年轻代和老年代在堆结构的占比为2(新生代占1.老年代占2)</span></span><br><span class="line"><span class="attr">jinfo</span> <span class="string">-flag NewRatio pid</span></span><br><span class="line"><span class="attr">&gt;&gt;&gt;</span> <span class="string">-XX:NewRatio=2</span></span><br><span class="line"><span class="comment"># 查看Eden空间和另外两个Survivor空间缺省所占的比例(默认Eden空间占8份)</span></span><br><span class="line"><span class="attr">jinfo</span> <span class="string">-flag SurvivorRatio 进程pid</span></span><br><span class="line"><span class="attr">&gt;&gt;&gt;</span> <span class="string">-XX:SurvivorRatio=8</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在HotSpot中, Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1</p>
</li>
<li><p>可以使用选项-XX:SurvivorRatio调整这个空间比例</p>
</li>
<li><p>几乎所有的Java对象都是在Eden区被new出来的</p>
</li>
<li><p>绝大部分的Java对象的销毁都是在年轻代进行的</p>
</li>
<li><p>可以使用选项-Xmn设置新生代最大内存大小</p>
</li>
<li><p>关于垃圾回收: 频繁的新生区收集, 很少在养老区收集, 几乎不在元空间收集</p>
</li>
<li><p>YGC:年轻代中的垃圾回收器</p>
</li>
<li><p>FGC:老年代中的垃圾回收器</p>
</li>
</ul>
<h4 id="2-4-3-MinorGC-YGC-、MajorGC、-FullGC"><a href="#2-4-3-MinorGC-YGC-、MajorGC、-FullGC" class="headerlink" title="2.4.3  MinorGC(YGC)、MajorGC、 FullGC"></a>2.4.3  MinorGC(YGC)、MajorGC、 FullGC</h4><p>JVM在进行GC时, 并非每次都对上面三个内存(新生代、老年代、方法区)区域一起回收, 大部分回收的都是指新生代</p>
<p>针对HotSpot VM的实现, 它里面的GC按照回收区域又分为两大种类型: 一种是部分收集(Partial GC), 一种是整堆收集(Full GC)</p>
<ul>
<li>部分收集: 指目标不是完整收集整个Java堆的垃圾收集<ul>
<li>新生代收集(Minor GC &#x2F; Young GC) : 只是新生代(Eden&#x2F;S0, S1)的垃圾收集</li>
<li>老年代收集(Major GC &#x2F; Old GC) : 只是老年代的垃圾收集<ul>
<li>目前 , 只有CMS GC会有单独收集老年代的行为</li>
<li>注意, 很多时候Major GC会和 Full GC混淆使用, 需要具体分辨是老年代回收还是整堆回收</li>
</ul>
</li>
<li>混合收集(Mixed GC) : 收集整个新生代以及部分老年代的垃圾回收<ul>
<li>目前只有G1 GC会有这种行为</li>
</ul>
</li>
</ul>
</li>
<li>整堆收集(Full GC):  收集整个Java堆和方法区的垃圾收集</li>
</ul>
<h4 id="2-4-3-分代式GC策略的触发条件"><a href="#2-4-3-分代式GC策略的触发条件" class="headerlink" title="2.4.3 分代式GC策略的触发条件"></a>2.4.3 分代式GC策略的触发条件</h4><ul>
<li><p>年轻代GC(Minor GC)触发机制:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1&gt;</span> <span class="string">当年轻代空间不足时, 就会触发Minor GC, 这里的年轻代满指的是Eden满, Survivor满不会引起GC(每次Minor GC会清理年轻代的内存)</span></span><br><span class="line"><span class="attr">2&gt;</span> <span class="string">因为Java对象大多都具备朝生夕灭的特性, 所以Minor GC非常频繁, 一般回收速度也比较快</span></span><br><span class="line"><span class="attr">3&gt;</span> <span class="string">Minor GC会引发STW(Stop The World), 暂停其他用户的线程, 等待垃圾回收结束, 用户线程才恢复运行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>老年代(Major GC &#x2F; Full GC)触发机制:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1&gt;</span> <span class="string">指发生在老年代的GC, 对象从老年代消失, 即Major GC或者Full GC发生了</span></span><br><span class="line"><span class="attr">2&gt;</span> <span class="string">出现了Major GC, 经常会伴随至少一次的Minor GC(但非绝对的, 在Parallel Scavenge收集器的收集策略中) 注: 也就是在老年代空间不足时, 会先尝试进行Major GC的策略选择过程触发Minor GC。如果之后空间还不足, 则触发Major GC</span></span><br><span class="line"><span class="attr">3&gt;</span> <span class="string">Major GC的速度一般会比Minor GC慢10倍以上, STW的时间更长</span></span><br><span class="line"><span class="attr">4&gt;</span> <span class="string">如果Major GC后, 内存还不足, 就报OOM</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Full GC触发机制</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1&gt;</span> <span class="string">调用System.gc()时, 系统建议执行Full GC, 但是不必然执行</span></span><br><span class="line"><span class="attr">2&gt;</span> <span class="string">老年代空间不足</span></span><br><span class="line"><span class="attr">3&gt;</span> <span class="string">方法区空间不足</span></span><br><span class="line"><span class="attr">4&gt;</span> <span class="string">通过Minor GC后进入老年代的平均大小大于老年代的可用内存</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-4-5-堆空间分代思想"><a href="#2-4-5-堆空间分代思想" class="headerlink" title="2.4.5 堆空间分代思想"></a>2.4.5 堆空间分代思想</h4><p>堆分代的唯一理由就是<strong>优化GC性能</strong>   </p>
<p>经研究, 不同的对象的生命周期不同, 70%-90%的对象是临时对象</p>
<ul>
<li>新生代: 有Eden、两块大小相同的Survivor构成,  to总为空</li>
<li>老年代: 存放新生代中经历多次GC仍然存活的对象</li>
</ul>
<h4 id="2-4-6-内存分配策略"><a href="#2-4-6-内存分配策略" class="headerlink" title="2.4.6 内存分配策略"></a>2.4.6 内存分配策略</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">如果对象在Eden出生并经过第一次Minor</span> <span class="string">GC后仍然存活, 并且能被Survivor容纳的话, 将被移动到Survivor空间中, 并将对象年龄设为1。对象在Survivor区中没每经过一次Minor GC, 年龄就增加一岁, 当它的年龄增加到一定程度(默认为15岁, 每个JVM, 每个GC都有所不同)时, 就会被晋升到老年代中。</span></span><br><span class="line"><span class="attr">对象晋升老年代的年龄阈值可以通过选项</span> <span class="string">-XX:MaxTenuringThreshold来设置</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>优先分配到Eden</p>
</li>
<li><p>大对象直接分配到老年代(尽量避免程序中出现过多的大对象)</p>
</li>
<li><p>长期存活的对象分配到老年代</p>
</li>
<li><p>动态对象年龄判断</p>
<ul>
<li>如果Survivor区中相同年龄的的所有对象大小的总和大于survivor空间的一半, 年龄大于或者等于该年龄的对象可以直接进入老年代, 无须等到MaxTenuringThreshold种要求的年龄</li>
</ul>
</li>
<li><p>空间分配担保</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-XX</span>:<span class="string">HandlePromotionFailure(JDK7以后失效了)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-4-7-TLAB-Thread-Local-Allocation-Buffer"><a href="#2-4-7-TLAB-Thread-Local-Allocation-Buffer" class="headerlink" title="2.4.7 TLAB(Thread Local Allocation Buffer)"></a>2.4.7 TLAB(Thread Local Allocation Buffer)</h4><p>什么是TLAB?</p>
<ul>
<li><p>线程本地分配缓存区</p>
</li>
<li><p>从内存模型而不是垃圾回收的角度, 对Eden区继续进行划分, JVM为每个线程分配了一个私有的缓存区域, 它包含在Eden空间内</p>
</li>
<li><p>多线程同时分配内存时, 使用TLAB可以避免一系列的非线程安全问题, 同时还能够提升内存分配的吞吐量, 因此我们将这种内存的分配方式称之为快速分配策略</p>
</li>
</ul>
<p>为什么需要TLAB</p>
<ul>
<li>堆区是线程共享的区域, 任何线程都可以访问到堆区中的共享数据 由于对象实例的创建在JVM中非常频繁, 因此在并发环境中从堆区化分内存空间是线程不安全的</li>
<li>为避免多个线程操作同一地址, 需要使用加锁等机制, 进而影响分配速度</li>
</ul>
<p>tips:</p>
<ul>
<li>尽管不是所有的对象实例都能够在TLAB中成功分配内存, 但JVM确实是将TLAB作为内存分配的首选</li>
<li>在程序中, 可以通过选项<code>-XX:UseTLAB</code>设置是否开启TLAB空间(JDK8及其之后默认开启)</li>
<li>默认情况下, TLAB空间的内存非常小, 仅占有整个Eden空间的1%, 可以通过选项<code>-XX:TLABWasteTargetPercent</code>设置TLAB</li>
<li>一旦对象在TLAB空间分配内存失败, JVM就会尝试通过使用加锁机制来确保数据操作的原子性, 从而直接在Eden空间中分配内存</li>
</ul>
<h4 id="2-4-8-堆空间常用参数设置"><a href="#2-4-8-堆空间常用参数设置" class="headerlink" title="2.4.8 堆空间常用参数设置"></a>2.4.8 堆空间常用参数设置</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-XX</span>:<span class="string">+PrintFalgsFinal   查看所有参数的最终值</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">+PrintFlagsInitial 查看所有参数的默认初始值</span></span><br><span class="line"><span class="attr">-Xmn</span>=<span class="string">xxx               设置新生代的大小</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-9-逃逸分析"><a href="#2-4-9-逃逸分析" class="headerlink" title="2.4.9 逃逸分析"></a>2.4.9 逃逸分析</h4><p>堆是分配对象存储的唯一选择吗?</p>
<p>随着JIT编译器的发展与逃逸分析技术逐渐成熟, 栈上分配、标量替换优化技术将会导致一些微秒的变化, 所有的对象不一定都分配到堆上</p>
<p>在Java虚拟机中, 对象是在Java堆中分配内存的, 这是一个普遍的常识。但是有一种特殊的情况, 那就是如果经过逃逸分析后发现, 一个对象并没有逃逸出方法的话, 那么就可能会优化成栈上分配, 这样就无需在堆上分配内存, 也无需进行垃圾回收了, 即堆外存储技术</p>
<p>如何将堆上地对象分配到栈上, 需要使用逃逸分析手段</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">逃逸分析是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#逃逸分析的基本行为就是分析对象动态作用域:</span></span><br><span class="line"><span class="attr">当一个对象在方法中被定义后,</span> <span class="string">对象只在方法内部使用, 则认为没有发生逃逸</span></span><br><span class="line"><span class="attr">当一个对象在方法中被定义后,</span> <span class="string">它被外部方法所引用, 则认为发生逃逸, 比如作为调用参数传递到其他地方中</span></span><br></pre></td></tr></table></figure>

<p>tip: <strong>开发中能使用局部变量的, 就不要使用在方法外定义的变量</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启逃逸分析</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">+DoEscapeAnalysis</span></span><br><span class="line"><span class="comment">#关闭逃逸分析</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">-DoEscapeAnalysis</span></span><br><span class="line"><span class="comment">#JDK7之后默认开启</span></span><br></pre></td></tr></table></figure>

<h5 id="2-4-9-1-标量替换"><a href="#2-4-9-1-标量替换" class="headerlink" title="2.4.9 .1 标量替换"></a>2.4.9 .1 标量替换</h5><p>标量(Scalar) 是指一个无法再分解成更小的数据的数据</p>
<p>Java中原始数据类型就是标量</p>
<p>相对的, 那些还可以分解的数据叫做聚合量</p>
<p>Java中对象就是聚合量</p>
<p>在JIT阶段, 如果经过逃逸分析, 发现一个对象不会被外界访问的话, 那么经过JIT优化, 就会把这个对象拆解成若干个其他成员变量来代替, 这个过程就是标量替换</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#标量参数替换设置</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">EliminateAllocations(默认打开, 允许将对象打散分配在栈上)</span></span><br></pre></td></tr></table></figure>

<h3 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h3><p>《Java虚拟机规范》说明方法区在逻辑上是属于堆的一部分, 但是对于Java虚拟机的实现之一的HotSpot而言, 方法区还有一个别名叫做Non-Heap(非堆), 目的就是要和堆分开, 所以, 方法区看作是一块独立于Java堆的内存空间</p>
<p> 目前, 元空间(Metaspace)是方法区的具体落地实现</p>
<ul>
<li>方法区(Method Area)与堆一样, 是各个先线程共享的区域</li>
<li>方法区在JVM启动的时候被创建, 并且它的实际物理内存空间中和Java堆区一样都可以是不连续的</li>
<li>方法区的大小和堆空间一样, 可以选择固定大小或者可扩展</li>
<li>方法区的大小决定了系统可以保存多少个类, 如果系统定义了太多的类, 导致方法区溢出, 虚拟机同样会抛出内存溢出错误</li>
<li>关闭JVM就会释放这个区域的内存</li>
</ul>
<h4 id="2-5-1-HotSpot中方法区的演进"><a href="#2-5-1-HotSpot中方法区的演进" class="headerlink" title="2.5.1 HotSpot中方法区的演进"></a>2.5.1 HotSpot中方法区的演进</h4><ul>
<li>在JDK7及以前, 习惯上把方法区称为永久代。JDK8开始, 使用元空间取代了永久代</li>
<li>本质上, 方法区和永久代并不等价。仅是对于HotSpot而言的(HotSpot中永久代就是方法区的实现) ,《Java虚拟机规范》中对于如何实现方法区, 不做统一要求, 例如 BEA  JRocket &#x2F; IBM J9中不存在永久代的概念</li>
<li>在JDK8完全废弃了永久代的概念, 改用与JRocket、J9一样在本地内存中实现的元空间(Metaspace)来代替</li>
<li>元空间的本质和永久代类似, 都是JVM规范中方法区的实现, 不过元空间与永久代最大的区别在于: <strong>元空间不在虚拟机设置的内存中, 而是使用本地内存</strong></li>
<li>永久代、元空间二者并不只是名字变化了, 内部的结构也调整了</li>
<li>根据《Java虚拟机规范》的规定, 如果方法区无法满足新的内存分配需求, 将抛出OOM异常</li>
</ul>
<h4 id="2-5-2-设置方法区大小的参数"><a href="#2-5-2-设置方法区大小的参数" class="headerlink" title="2.5.2 设置方法区大小的参数"></a>2.5.2 设置方法区大小的参数</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置永久代空间的大小</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">PermSize</span></span><br><span class="line"><span class="comment"># 设置永久代空间的最大值</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">MaxPermSize</span></span><br><span class="line"><span class="comment"># 默认元空间的初始值大小</span></span><br><span class="line"><span class="attr">jps</span></span><br><span class="line"><span class="attr">jinfo</span> <span class="string">-flag MetaspaceSize pid</span></span><br><span class="line"><span class="attr">&gt;&gt;&gt;</span> <span class="string">-XX:MetaspaceSize=21807104</span></span><br><span class="line"><span class="comment"># 默认元空间的最大值</span></span><br><span class="line"><span class="attr">jinfo</span> <span class="string">-flag MaxMetaspaceSize pid</span></span><br><span class="line"><span class="attr">&gt;&gt;&gt;</span> <span class="string">-XX:MaxMetaspaceSize=18446744073709486080</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置元空间的初始值大小</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">MetaspaceSize=10m</span></span><br><span class="line"><span class="comment"># 设置元空间的最大值</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">MaxMetaspaceSize=100m</span></span><br></pre></td></tr></table></figure>

<h4 id="2-5-3-方法区的作用"><a href="#2-5-3-方法区的作用" class="headerlink" title="2.5.3 方法区的作用"></a>2.5.3 方法区的作用</h4><p>它用于储存已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等</p>
<h5 id="2-5-3-1-类型信息"><a href="#2-5-3-1-类型信息" class="headerlink" title="2.5.3.1 类型信息"></a>2.5.3.1 类型信息</h5><p>对每个加载的类型(类class、接口interface、枚举enum、注解annotation), JVM必须在方法区中存储以下类型信息</p>
<ul>
<li>这个类型的完整有效名称(包名.类名)</li>
<li>这个类型直接父类的完整有效名(对于interface和java.lang.Object都没有父类)</li>
<li>这个类型的修饰符(public, abstract, final的某个子集)</li>
<li>这个类型直接接口的一个有序列表</li>
</ul>
<h5 id="2-5-3-2-域-Field-信息"><a href="#2-5-3-2-域-Field-信息" class="headerlink" title="2.5.3.2 域(Field)信息"></a>2.5.3.2 域(Field)信息</h5><ul>
<li>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序</li>
<li>域的相关信息包括: 域名称、域类型、域修饰符(public, private, protected, static, volatile, transient的某个子集)</li>
</ul>
<h5 id="2-5-3-3-方法-Method-信息"><a href="#2-5-3-3-方法-Method-信息" class="headerlink" title="2.5.3.3 方法(Method)信息"></a>2.5.3.3 方法(Method)信息</h5><ul>
<li><p>方法名称</p>
</li>
<li><p>方法的返回类型</p>
</li>
<li><p>方法参数的数量和类型</p>
</li>
<li><p>方法的修饰符(public, private, protected, static, final, synchronized, native, abstract的一个子集)</p>
</li>
<li><p>方法的字节码文件、操作数栈、局部变量表及大小(abstract和native方法除外)</p>
</li>
<li><p>异常表(abstract和native方法除外)</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="2-5-3-4-class文件中常量池"><a href="#2-5-3-4-class文件中常量池" class="headerlink" title="2.5.3.4 class文件中常量池"></a>2.5.3.4 class文件中常量池</h5><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口描述信息外, 还包含一项信息那就是常量池表(Constant Pool Table),  包含各种字面量和对类型、域和方法的符号引用</p>
<p>一个Java源文件中的类、接口, 编译后产生一个字节码文件, 而Java中的字节码需要数据支持, 通常这种数据会很大以至于不能直接存到字节码里, 换另一种方式, 可以存到常量支持池中, 这个字节码包含了指向常量池的引用, 并在动态链接的时候使用运行时常量池(相当于Maven仓库一样)</p>
<p>常量池可以看做是一张表, 虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型</p>
<h5 id="2-5-3-5-运行时常量池"><a href="#2-5-3-5-运行时常量池" class="headerlink" title="2.5.3.5 运行时常量池"></a>2.5.3.5 运行时常量池</h5><ul>
<li><strong>class文件中的常量池经过类加载器放到方法区以后就叫做运行时常量池</strong></li>
<li>运行时常量池(Runtime Constant Pool) 是方法区的一部分</li>
<li>常量池表(Constant Pool Table) 是Class文件的一部分, 用于存放编译期生成的各种字面量与符号引用, <strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong></li>
<li>运行时常量池, 在加载类和接口到虚拟机后, 就会创建对应的运行时常量池</li>
<li>JVM为每个已加载的类型(类或者接口)都维护一个常量池。池中的数据项像数组项一样, 是通过索引访问的</li>
<li>运行时常量池中包含多种不同的常量, 包括编译期就已经明确的数值常量, 也包括到运行期解析后才能够获得的方法或者字段引用, 此时不再是常量池中的符号地址了, 这里换为真实地址</li>
<li>运行时常量池具有动态性</li>
<li>当创建类或者接口的运行时常量池时, 如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值, JVM将会抛出OOM</li>
</ul>
<h5 id="2-5-3-6-方法区的演进细节"><a href="#2-5-3-6-方法区的演进细节" class="headerlink" title="2.5.3.6 方法区的演进细节"></a>2.5.3.6 方法区的演进细节</h5><p>只有在HotSpot中才有永久代, BEA的JRocket和IBM的J9都是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现的细节,不受《Java虚拟机规范》管束, 并不要求同一</p>
<table>
<thead>
<tr>
<th>JDK6及之前</th>
<th>有永久代(permanent generation) , 字符串常量池、 静态变量存放在永久代上</th>
</tr>
</thead>
<tbody><tr>
<td>JDK7</td>
<td>有永久代, 但是已经逐步”去永久代”, 字符串常量池、静态变量移出, 保存在堆中(永久代仍然使用Java虚拟机内存)</td>
</tr>
<tr>
<td>JDK8及之后</td>
<td>无永久代, 类型信息、方法、字段、常量保存在本地内存的元空间(方法区), 但是字符串常量池、静态变量仍在堆中</td>
</tr>
</tbody></table>
<p>随着Java8的到来, HotSpot VM中再也见不到了永久代了。但是这并不意味着类的元数据信息也消失了, 这些数据被移到了一个与堆不相连的本地内存区域, 这个区域叫做元空间(Metaspace)</p>
<p>由于类的元数据分配在本地内存中。元空间的最大分配内存空间就是系统可用的内存空间</p>
<p>永久代为什么要被元空间替换?</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1&gt;</span> <span class="string">为元空间设置空间大小是很难确定的, 在某些场景中, 如果动态加载类过多, 容易产生Perm区的OOM, 而元空间与永久代之间的最大区别在于: 元空间并不在虚拟机中, 而是使用本地内存, 因此, 默认情况下, 元空间的大小仅受本地内内存限制</span></span><br><span class="line"><span class="attr">2&gt;</span> <span class="string">对永久代进行调优是很困难的</span></span><br></pre></td></tr></table></figure>

<h5 id="2-5-3-7-方法区的垃圾回收"><a href="#2-5-3-7-方法区的垃圾回收" class="headerlink" title="2.5.3.7 方法区的垃圾回收"></a>2.5.3.7 方法区的垃圾回收</h5><p>方法区的垃圾收集主要回收两部分内容: 常量池中废弃的常量和不再使用的类型</p>
<p>方法区内的常量池之中主要存放的两大类常量: 字面量和符号引用。字面量比较接近Java语言层次的常量概念, 如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念, 包括下面三类常量:</p>
<ul>
<li>类和接口的全限定类名</li>
<li>字段的名称和描述符</li>
<li>方法的名称的描述符</li>
</ul>
<p>HotSpot VM对常量池的回收策略是很明确的, 只要常量池中的常量没有被任何地方引用, 就可以被回收</p>
<p>回收废弃常量与回收Java堆中的对象非常类似</p>
<p>判断一个常量是否”废弃”还是相对简单, 而要判定一个类型是否”不再被使用的类”的条件就比较苛刻了:</p>
<ul>
<li>该类的所有实例都已经被回收, 也就是Java堆中不存在该类及其任何派生类的实例</li>
<li>加载该类的类加载已经被回收, 这个条件除非是经过精心设计的可替换类加载器的场景, 如OSGI、JSP的重加载等, 否者是很难达成的</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用, 无法在任何地方通过反射方法访问该类的方法</li>
</ul>
<p>Java虚拟机被允许对满足以上三个条件的无用类进行回收, 这里说的仅仅是”被允许”而并不是和对象一样, 没有了引用就必然会回收</p>
<p>在大量使用反射、动态代理、CGLib等字节码框架, 动态生成JSP以及OSGI这类频繁自定义类加载器的场景中, 通常都需要Java虚拟机具备类型卸载的能力, 以保证不会对方法区造成大的内存压力</p>
<h5 id="2-5-3-8-字符串常量池的位置为什么要调整"><a href="#2-5-3-8-字符串常量池的位置为什么要调整" class="headerlink" title="2.5.3.8 字符串常量池的位置为什么要调整?"></a>2.5.3.8 字符串常量池的位置为什么要调整?</h5><p>JDK7中将StringTable放到了堆空间中。因为永久代的回收效率很低, 在full gc时才会触发。而full gc是老年代的空间不足、永久代不足时才会触发, 这就导致StringTable回收效率不高, 而我们开发中会有大量的字符串被创建, 回收效率低, 导致永久代内存不足。放到堆里, 能够及时回收内存。</p>
<p><img src="https://cdn.qingweico.cn/blog/604e1e0d5aedab222c229f9b.png" alt="JVM"></p>
<h3 id="2-6-对象的创建"><a href="#2-6-对象的创建" class="headerlink" title="2.6 对象的创建"></a>2.6 对象的创建</h3><h4 id="2-6-1-判断对象对应的类是否加载、链接、初始化"><a href="#2-6-1-判断对象对应的类是否加载、链接、初始化" class="headerlink" title="2.6.1 判断对象对应的类是否加载、链接、初始化"></a>2.6.1 判断对象对应的类是否加载、链接、初始化</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">虚拟机遇到一条new指令。首先去检查这个指令的参数是否在Metaspace的常量池中定位到一个类的符号引用,</span> <span class="string">并且检查这个符号引用代表的类是否已经被加载、解析和初始化(即判断类元信息是否存在)。如果没有, 那么在双亲委派模式下, 使用当前类加载器ClassLoader+包名+类名为key进行查找对应的.class文件。如果没有文件,则抛出ClassNotFoundException异常, 如果找到, 则进行类加载, 并生成对应的Class类对象</span></span><br></pre></td></tr></table></figure>

<h4 id="2-6-2-为对象分配内"><a href="#2-6-2-为对象分配内" class="headerlink" title="2.6.2 为对象分配内"></a>2.6.2 为对象分配内</h4><p>首先计算对象占用空间大小,接着在堆中划分一块内存给新对象,如果实例成员变量是引用变量,仅分配引用变量空间即可, 即4个字节大小</p>
<ul>
<li>如果内存是规整的, 那么虚拟机将采用的是指针碰撞法(Bump The Pointer)来分配内存</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">指针碰撞法</span>: <span class="string">所有用过的内存在一边, 空闲的内存在另外一边, 中间放着一个指针作为分界点的指示器, 分配内存仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了.如果垃圾收集器选择的是Serial, ParNew这种基于压缩算法的, 虚拟机采用这分配方式, 一般使用带有compact(整理)过程的收集器时, 使用指针碰撞.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果内存是不规整的, 虚拟机需要维护一个列表</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">如果内存不是规整的,</span> <span class="string">已使用的内存和未使用的内存相互交错, 那么虚拟机将采用的是空闲列表法来为对象分配内存</span></span><br><span class="line"><span class="attr">虚拟机维护了一个列表,</span> <span class="string">记录哪些内存块是可用的, 再分配的时候从列表中找到一块足够大的空间划分给对象实例, 并更新列表上的内容, 这种分配方式成为(Free List).</span></span><br></pre></td></tr></table></figure>

<h4 id="2-6-3-处理并发安全问题"><a href="#2-6-3-处理并发安全问题" class="headerlink" title="2.6.3 处理并发安全问题"></a>2.6.3 处理并发安全问题</h4><ul>
<li>采用CAS失败重试, 区域加锁保证更新的原子性</li>
<li>每个线程预先分配一块TLAB</li>
</ul>
<h4 id="2-6-4-初始化分配到的空间"><a href="#2-6-4-初始化分配到的空间" class="headerlink" title="2.6.4 初始化分配到的空间"></a>2.6.4 初始化分配到的空间</h4><p>所有属性设置默认值, 保证对象实例字段在不赋值时可以直接使用</p>
<ul>
<li>属性的默认初始化</li>
</ul>
<h4 id="2-6-5-设置对象的对象头"><a href="#2-6-5-设置对象的对象头" class="headerlink" title="2.6.5 设置对象的对象头"></a>2.6.5 设置对象的对象头</h4><p>将对象的所属类(即类的元数据信息), 对象hashCode和对象的GC信息, 锁信息等数据存储在对象的对象头中, 这个过程的具体设置方式取决于JVM实现</p>
<h4 id="2-6-6-执行init方法进行初始化"><a href="#2-6-6-执行init方法进行初始化" class="headerlink" title="2.6.6 执行init方法进行初始化"></a>2.6.6 执行init方法进行初始化</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">在Java程序的视角看,</span> <span class="string">初始化才正式开始,初始化成员变量, 执行实例化代码块, 调用类的构造方法, 并把堆内对象的首地址赋值给引用变量. 因此一般来说(由字节码中是否跟随有invokespecial指令所决定), new指令之后会接着执行方法, 把对象按照程序员的意愿进行初始化, 这样一个真正可用的对象才算完全创建出来</span></span><br></pre></td></tr></table></figure>

<ul>
<li>显示初始化</li>
<li>代码块中的初始化</li>
<li>构造器中初始化</li>
</ul>
<h3 id="2-7-对象的内存布局"><a href="#2-7-对象的内存布局" class="headerlink" title="2.7 对象的内存布局"></a>2.7 对象的内存布局</h3><h4 id="2-7-1对象头-Header"><a href="#2-7-1对象头-Header" class="headerlink" title="2.7.1对象头(Header)"></a>2.7.1对象头(Header)</h4><ul>
<li>运行时元数据(Mark Word)<ul>
<li>哈希值</li>
<li>GC分代年龄</li>
<li>锁状态标志(3位)<ul>
<li>是否上锁</li>
<li>轻量级锁</li>
<li>重量级锁</li>
<li>是否被GC标记</li>
<li>是否偏向</li>
</ul>
</li>
<li>Lock Records Address<ul>
<li>轻量级锁(指向栈中的锁记录)</li>
<li>检查Mark Word是否指向当前线程的栈</li>
</ul>
</li>
<li>Monitor Address</li>
<li>Forwarding Address</li>
<li>线程持有的锁</li>
<li>偏向线程ID</li>
<li>偏向时间戳</li>
</ul>
</li>
<li>类型指针: 指向类元数据InstanceClass, 确定该对象所属的类型</li>
<li>如果是数组, 还需记录数组的长度</li>
</ul>
<h4 id="2-7-2-实例数据-Instance-Data"><a href="#2-7-2-实例数据-Instance-Data" class="headerlink" title="2.7. 2 实例数据 (Instance Data)"></a>2.7. 2 实例数据 (Instance Data)</h4><p>它是对象真正存储的有效信息, 包括程序代码中定义的各种类型的字段(包括从父类继承下来的本身拥有的字段)</p>
<p>规则:</p>
<ul>
<li>相同宽度的字段总是被分配在一起</li>
<li>父类中定义的变量会出现在子类之前</li>
<li>如果CompactFields参数为true(默认为true): 子类的窄变量可能插入到父类变量的空隙</li>
</ul>
<h4 id="2-7-3-对齐填充-Padding"><a href="#2-7-3-对齐填充-Padding" class="headerlink" title="2.7.3 对齐填充(Padding)"></a>2.7.3 对齐填充(Padding)</h4><p>不是必须的, 也没有特别的含义, 仅仅起到占位符的作用</p>
<p>由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍, 即任何对象的大小都必须是8字节的整数倍, 如果对象实例数据部分没有对其的话, 就要通过字节填齐来补全</p>
<p><img src="https://cdn.qingweico.cn/blog/603658cc5f4313ce25534991.png"></p>
<h4 id="2-7-4-工具-JOL-x3D-Java-Object-Layout"><a href="#2-7-4-工具-JOL-x3D-Java-Object-Layout" class="headerlink" title="2.7.4 工具: JOL &#x3D; Java Object Layout"></a>2.7.4 工具: JOL &#x3D; Java Object Layout</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&lt;dependencies&gt;</span></span><br><span class="line">    <span class="attr">&lt;!--</span> <span class="string">https://mvnrepository.com/artifact/org.openjdk.jol/jol-core --&gt;</span></span><br><span class="line">    <span class="attr">&lt;dependency&gt;</span></span><br><span class="line">        <span class="attr">&lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</span></span><br><span class="line">        <span class="attr">&lt;artifactId&gt;jol-core&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="attr">&lt;version&gt;0.9&lt;/version&gt;</span></span><br><span class="line">    <span class="attr">&lt;/dependency&gt;</span></span><br><span class="line"><span class="attr">&lt;/dependencies&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectLayout</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前两个object header 为markword占用8个字节, 第三个object header 为类型指针(class pointer) 占用4个字节</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">java.lang.Object</span> <span class="string">object internals:</span></span><br><span class="line"> <span class="attr">OFFSET</span>  <span class="string">SIZE   TYPE DESCRIPTION                               VALUE</span></span><br><span class="line">      <span class="attr">0</span>     <span class="string">4        (object header)                           05 00 00 00 (00000101 00000000 00000000 00000000) (5)</span></span><br><span class="line">      <span class="attr">4</span>     <span class="string">4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span></span><br><span class="line">      <span class="attr">8</span>     <span class="string">4        (object header)                           94 20 00 00 (10010100 00100000 00000000 00000000) (8340)</span></span><br><span class="line">     <span class="attr">12</span>     <span class="string">4        (loss due to the next object alignment)</span></span><br><span class="line"><span class="attr">Instance</span> <span class="string">size: 16 bytes</span></span><br><span class="line"><span class="attr">Space</span> <span class="string">losses: 0 bytes internal + 4 bytes external = 4 bytes total</span></span><br><span class="line"></span><br><span class="line"><span class="attr">java.lang.Object</span> <span class="string">object internals:</span></span><br><span class="line"> <span class="attr">OFFSET</span>  <span class="string">SIZE   TYPE DESCRIPTION                               VALUE</span></span><br><span class="line">      <span class="attr">0</span>     <span class="string">4        (object header)                           05 88 d2 25 (00000101 10001000 11010010 00100101) (634554373)</span></span><br><span class="line">      <span class="attr">4</span>     <span class="string">4        (object header)                           0d 02 00 00 (00001101 00000010 00000000 00000000) (525)</span></span><br><span class="line">      <span class="attr">8</span>     <span class="string">4        (object header)                           94 20 00 00 (10010100 00100000 00000000 00000000) (8340)</span></span><br><span class="line">     <span class="attr">12</span>     <span class="string">4        (loss due to the next object alignment)</span></span><br><span class="line"><span class="attr">Instance</span> <span class="string">size: 16 bytes</span></span><br><span class="line"><span class="attr">Space</span> <span class="string">losses: 0 bytes internal + 4 bytes external = 4 bytes total</span></span><br></pre></td></tr></table></figure>

<h4 id="2-7-5-关闭指针压缩"><a href="#2-7-5-关闭指针压缩" class="headerlink" title="2.7.5 关闭指针压缩"></a>2.7.5 关闭指针压缩</h4><ul>
<li><p>-XX:+PrintCommandLineFlags -version: 打印HotSpotVM 采用的自动优化参数</p>
</li>
<li><p>-XX:+UseCompressedClassPointers: 开启类指针压缩</p>
</li>
<li><p>-XX:+UseCompressedOops: 开启普通对象指针压缩</p>
</li>
</ul>
<p>Java中默认开启指针压缩, 使用虚拟机参数<code>-XX:-UseCompressedClassPointers</code>来关闭此选项。 关闭后类型指针(class pointer)占用8个字节, 即第三个和第四个object header</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">java.lang.Object</span> <span class="string">object internals:</span></span><br><span class="line"> <span class="attr">OFFSET</span>  <span class="string">SIZE   TYPE DESCRIPTION                               VALUE</span></span><br><span class="line">      <span class="attr">0</span>     <span class="string">4        (object header)                           05 00 00 00 (00000101 00000000 00000000 00000000) (5)</span></span><br><span class="line">      <span class="attr">4</span>     <span class="string">4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span></span><br><span class="line">      <span class="attr">8</span>     <span class="string">4        (object header)                           d8 1f a5 f0 (11011000 00011111 10100101 11110000) (-257613864)</span></span><br><span class="line">     <span class="attr">12</span>     <span class="string">4        (object header)                           c8 01 00 00 (11001000 00000001 00000000 00000000) (456)</span></span><br><span class="line"><span class="attr">Instance</span> <span class="string">size: 16 bytes</span></span><br><span class="line"><span class="attr">Space</span> <span class="string">losses: 0 bytes internal + 0 bytes external = 0 bytes total</span></span><br><span class="line"></span><br><span class="line"><span class="attr">java.lang.Object</span> <span class="string">object internals:</span></span><br><span class="line"> <span class="attr">OFFSET</span>  <span class="string">SIZE   TYPE DESCRIPTION                               VALUE</span></span><br><span class="line">      <span class="attr">0</span>     <span class="string">4        (object header)                           05 98 59 d1 (00000101 10011000 01011001 11010001) (-782657531)</span></span><br><span class="line">      <span class="attr">4</span>     <span class="string">4        (object header)                           c8 01 00 00 (11001000 00000001 00000000 00000000) (456)</span></span><br><span class="line">      <span class="attr">8</span>     <span class="string">4        (object header)                           d8 1f a5 f0 (11011000 00011111 10100101 11110000) (-257613864)</span></span><br><span class="line">     <span class="attr">12</span>     <span class="string">4        (object header)                           c8 01 00 00 (11001000 00000001 00000000 00000000) (456)</span></span><br><span class="line"><span class="attr">Instance</span> <span class="string">size: 16 bytes</span></span><br><span class="line"><span class="attr">Space</span> <span class="string">losses: 0 bytes internal + 0 bytes external = 0 bytes total</span></span><br></pre></td></tr></table></figure>

<h3 id="2-8-对象访问定位"><a href="#2-8-对象访问定位" class="headerlink" title="2.8 对象访问定位"></a>2.8 对象访问定位</h3><p>访问对象的方式主要有两种:</p>
<ul>
<li>句柄访问</li>
</ul>
<p><img src="https://cdn.qingweico.cn/blog/60379b175f4313ce25471152.png"></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">句柄访问的缺点</span>: <span class="string">1&gt; 需要在内存中开辟额外的空间供句柄池存储数据 2&gt; 访问对象需要经过多次地址寻址</span></span><br><span class="line"><span class="attr">优点</span>: <span class="string">当对象被移动(垃圾回收时移动对象很普遍)时, 只会改变句柄中的实例数据指针, 而reference本身不需要修改 </span></span><br></pre></td></tr></table></figure>

<ul>
<li>直接指针(HotSpot采用)</li>
</ul>
<p>使用直接指针来访问最大的好处就是速度更快,它节省了一次指针定位的时间开销</p>
<p><img src="https://cdn.qingweico.cn/blog/60379b0f5f4313ce25470a05.png"></p>
<h3 id="2-9-直接内存-堆外内存"><a href="#2-9-直接内存-堆外内存" class="headerlink" title="2.9 直接内存(堆外内存)"></a>2.9 直接内存(堆外内存)</h3><ul>
<li>直接内存不是虚拟机运行时数据区的一部分, 也不是《Java虚拟机规范》中定义的内存区域</li>
<li>直接内存是Java堆外的、直接向系统申请的内存空间</li>
<li>来源于NIO, 通过存在堆中的DirectByteBuffer操作Native内存</li>
<li>通常访问直接内存的速度会优先于Java堆, 即读写性能高<ul>
<li>出于性能考虑, 读写频繁的场所可能会考虑使用直接内存</li>
<li>Java的NIO库允许Java程序使用直接内存, 用于数据缓冲</li>
</ul>
</li>
<li>直接内存也会出现OOM</li>
<li>Java中使用DirectByteBuffer类来操作直接内存</li>
<li>由于直接内存在Java堆外, 因此它的大小不会直接受限于<code>-Xmx</code>指定的最大堆大小, 但是系统内存是有限的, Java堆和直接内存的总和依然受限于操作系统能给出的最大内存</li>
<li>直接内存的缺点:<ul>
<li>分配回收成本较高</li>
<li>不受JVM内存回收管理</li>
</ul>
</li>
<li>直接内存大小可以通过<code>-XX:MaxDirectMemorySize</code>设置</li>
<li>如果不指定, 默认与堆的最大值<code>-Xmx</code>参数值保持一致</li>
</ul>
<h3 id="2-10-Java内存状况分析"><a href="#2-10-Java内存状况分析" class="headerlink" title="2.10 Java内存状况分析"></a>2.10 Java内存状况分析</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jconsole</span></span><br><span class="line"><span class="attr">jvisualvm</span></span><br><span class="line"><span class="attr">jstat</span></span><br><span class="line"><span class="attr">jmap</span></span><br><span class="line"><span class="attr">jProfiler</span></span><br></pre></td></tr></table></figure>

<h2 id="3-执行引擎"><a href="#3-执行引擎" class="headerlink" title="3 执行引擎"></a>3 执行引擎</h2><p>执行引擎是Java虚拟机核心的组成部分之一</p>
<p>“虚拟机”是一个相对于”物理机”的概念, 这两种机器都有代码执行的能力, 其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面的, 而虚拟机的执行引擎则是由软件自行实现的, 因此可以不受物理条件制约地定制指令集与执行引擎的结构体系, 能够执行那些不被硬件直接支持的指令集格式</p>
<p>JVM的主要任务是负责装载字节码到其内部, 但是字节码并不能够直接运行在操作系统上, 因为字节码指令并非等价于本地机器指令, 它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表以及其他辅助信息,而执行引擎(Execution Engine)的主要任务就是<strong>将字节码指令解释&#x2F;编译为对应平台上的本地机器指令才可以</strong>, JVM中的执行引擎充当了将高级语言翻译为机器语言的译者</p>
<h3 id="3-1-执行引擎的工作过程"><a href="#3-1-执行引擎的工作过程" class="headerlink" title="3.1 执行引擎的工作过程"></a>3.1 执行引擎的工作过程</h3><ul>
<li>执行引擎在执行过程中执行的字节码指令完全依赖于PC寄存器</li>
<li>每当执行完一项指令操作后, PC寄存器就会更新下一条需要被执行的指令地址</li>
<li>当然方法在执行的过程中, 执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到储存在Java堆中的对象实例信息, 以及通过对象头中的元数据指针定位到目标对象的类型信息</li>
<li>所有的Java虚拟机的执行引擎输入、输出都是一致的: 输入的是字节码二进制流, 处理过程是字节码解析执行的等效过程, 输出的是执行结果</li>
</ul>
<h3 id="3-2-Java代码编译和执行过程"><a href="#3-2-Java代码编译和执行过程" class="headerlink" title="3.2 Java代码编译和执行过程"></a>3.2 Java代码编译和执行过程</h3><ul>
<li>解释器(Interpreter): 当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方法执行, 将每条字节码文件中的内容”翻译”为对应平台的本地机器指令执行</li>
<li>JIT(Just In Time Compile) 编译器: 就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言</li>
<li>Java是半编译半解释型的语言。之前Java仅有解释执行, 后来Java也发展出可以直接生成本地代码的编译器。现在JVM在执行Java代码的时候, 通常都会将解释执行和编译执行二者结合起来进行</li>
</ul>
<h3 id="3-3-指令-amp-汇编"><a href="#3-3-指令-amp-汇编" class="headerlink" title="3.3 指令&amp;汇编"></a>3.3 指令&amp;汇编</h3><h4 id="3-3-1-指令"><a href="#3-3-1-指令" class="headerlink" title="3.3.1 指令"></a>3.3.1 指令</h4><p>指令就是把机器码特定的0和1序列, 简化成对应的指令, 由于不同的硬件平台, 执行同一个操作, 对应的机器码可能不同, 所以不同的硬件平台的同一种指令(比如mov), 对应的机器码也可能不同</p>
<h4 id="3-3-2-指令集"><a href="#3-3-2-指令集" class="headerlink" title="3.3.2 指令集"></a>3.3.2 指令集</h4><p>不同的硬件平台,各自支持的指令是有差别的,因此每个平台所支持的指令称之为对应平台的指令集</p>
<h4 id="3-3-3-汇编语言"><a href="#3-3-3-汇编语言" class="headerlink" title="3.3.3 汇编语言"></a>3.3.3 汇编语言</h4><ul>
<li>由于指令的可读性还是太差,于是产了汇编语言</li>
<li>在汇编语言中,使用助记符(Mnemonics)代替机器指令的操作码,用地址符号(Symbol)或者标号(Label)代替指令或者操作数的地址</li>
<li>在不同的硬件平台,汇编语言对应着不同的机器语言指令集,通过汇编过程转换成机器指令(由于计算机只认识指令码,所以用汇编语言编写的程序还必须翻译成机器指令码,计算机才能识别和识别)</li>
</ul>
<h3 id="3-4-JIT编译器"><a href="#3-4-JIT编译器" class="headerlink" title="3.4 JIT编译器"></a>3.4 JIT编译器</h3><p>HotSpot VM是目前市面上高性能虚拟机的代表作之一,它采用解释器与即时编译器并存的架构。在Java VM运行的时候,解释器和即时编译器能够相互协作,各自取长补短,尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间</p>
<p>JRocket VM内部就不含解释器, 字节码全部都依靠即时编译器编译后执行(这就是为什么JRocket VM速度很快的原因)</p>
<p>为什么JIT编译这么快,HotSpot VM仍然使用解释器呢?</p>
<ul>
<li><p>当程序启动后,解释器可以马上发挥作用,省去了编译的时间,立即执行。而编译器要想发挥作用,把代码编译成本地代码,需要一定的执行时间,但编译为本地代码,执行效率高</p>
</li>
<li><p>所以尽管JRocket VM中程序的执行性能会非常高效,但是在程序启动时必然需要花费更长的时间来进行编译。对于服务端应用来说,启动并非是关注点,但是对于那些看重启动时间的应用场景而言,或许就需要采用解释器与即时编译并存的架构来换取一个平衡点。在此模式下,<strong>当Java虚拟机启动时,解释器可以首先发挥作用,而不必等待即时编译器全部编译完成后再执行,这样可以省去许多不必要的编译时间。随着时间的推移,编译器发挥作用,把越来越多的代码编译成本地代码,获得更高的执行效率</strong></p>
</li>
</ul>
<p>Java语言的”编译期”其实是一段”不确定”的操作过程,因为它可能是指一个<strong>前端编译器</strong>——把.java文件转变为.class文件的过程,也可能指虚拟机的<strong>后端运行期编译器</strong>(JIT编译器, Just In Time Compiler)把字节码转变为机器码的过程,还可能是指使用<strong>静态提前编译器</strong>(AOT编译器  Ahead of Time Compiler)直接把.java文件编译为本地机器代码的过程</p>
<p>JIT编译器: HotSpot VM的 C1、 C2编译器</p>
<p>AOT编译器: GNU Compiler for Java(GCJ)、 Excelsior JET</p>
<h4 id="3-4-1-热点代码及探测方式"><a href="#3-4-1-热点代码及探测方式" class="headerlink" title="3.4.1 热点代码及探测方式"></a>3.4.1 热点代码及探测方式</h4><p>是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令,则需要根据代码被调用执行频率而定。那些需要被编译为本地代码的字节码,也被称之为”热点代码”,JIT编译器在运行时会针对那些频繁被调用的”热点代码”, JIT编译器在运行时会针对那些频繁被调用的”热点代码”做出深度优化,将其直接编译为对应平台德玩本地机器指令,以此提升Java程序执行性能</p>
<ul>
<li>一个被多次调用的方法,或者是一个方法体内部循环次数较多的循环体都可以被称之为”热点代码”,因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中,因此也被称为栈上替换,简称为OSR(On Stack Replacement)编译</li>
<li>HotSpot VM采用的热点探测方式是基于计数器的热点探测</li>
<li>采用基于计数器的热点探测,HotSpot VM将会为每一个方法都建立2个不同类型的计数器,分别为方法调用计数器(Invocation Counter)和回边计数器(Back Edge)<ul>
<li>方法调用计数器用于统计方法的调用次数</li>
<li>回边计数器则用于统计循环体执行的循环次数</li>
</ul>
</li>
<li>方法调用计数器</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 热度衰减</span></span><br><span class="line"><span class="attr">-</span> <span class="string">这个计数器就用于统计方法被调用的次数, 它的默认阈值在Client模式下是1500次, 在Server模式下是10000次。超过这个阈值就会触发JIT编译</span></span><br><span class="line"><span class="attr">-</span> <span class="string">这个阈值可以通过虚拟机参数 -XX:CompileThreshold来设置</span></span><br><span class="line"><span class="attr">-</span> <span class="string">当一个方法被调用时,会检查该方法是否存在被JIT编译过的版本,如果存在,则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本,则将此方法的调用计数器值加1,然后判断方法调用计数器与回边计数器之和是否超过方法调用计数器的阈值。如果已超过阈值,那么将会向即时编译器提交一个该方法的代码编译请求</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-</span> <span class="string">如果不做任何设置,方法调用计数器统计的并不是方法被调用的绝对次数,而是一个相对的执行频率,即一段时间之内方法被调用的次数,当超过一定的时间限度,如果方法的调用次数仍然不足以让它提交给即时编译器编译,那么这个方法的调用计数器就会被减少一半,这个过程称之为方法调用计数器热度的衰减(Counter Decay),而这段时间就称为此方法统计的半衰周期(Counter Half Life Time)</span></span><br><span class="line"><span class="attr">-</span> <span class="string">进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的,可以使用虚拟机参数-XX:-UseCounterDecay来关闭热度衰减, 让方法统计器统计方法调用的绝对次数,这样,只要系统运行时间足够长,绝大部分方法都会被编译成本地代码</span></span><br><span class="line"><span class="attr">-</span> <span class="string">可以使用 -XX:CounterHalfLifeTime参数设置半衰周期的时间(s)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>回边计数器: 它的作用是统计一个方法中循环体代码执行的次数,在字节码中遇到控制流向跳转的指令称为”回边”(Back Edge)。建立回边计数器的目的就是为了触发OSR编译</li>
</ul>
<h3 id="3-5-执行模式-amp-C1、C2编译器"><a href="#3-5-执行模式-amp-C1、C2编译器" class="headerlink" title="3.5 执行模式 &amp; C1、C2编译器"></a>3.5 执行模式 &amp; C1、C2编译器</h3><h4 id="3-5-1-设置HotSpot的执行模式"><a href="#3-5-1-设置HotSpot的执行模式" class="headerlink" title="3.5.1 设置HotSpot的执行模式"></a>3.5.1 设置HotSpot的执行模式</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启解释执行模式</span></span><br><span class="line"><span class="attr">java</span> <span class="string">-Xint -version</span></span><br><span class="line"><span class="comment"># 开启编译执行模式</span></span><br><span class="line"><span class="attr">java</span> <span class="string">-Xcomp -version</span></span><br></pre></td></tr></table></figure>

<h4 id="3-5-2-HotSpot-VM中JIT分类"><a href="#3-5-2-HotSpot-VM中JIT分类" class="headerlink" title="3.5.2 HotSpot VM中JIT分类"></a>3.5.2 HotSpot VM中JIT分类</h4><p>在HotSpot VM中内嵌有两个JIT编译器, 分别为Client Compile和Server Compile, 但大多数情况下简称为C1编译器和C2编译器</p>
<ul>
<li>-client: 指定Java虚拟机运行在Client模式下, 并使用C1编译器(#C1编译器对字节码进行简单和可靠的优化, 耗时短, 以达到更快的编译速度)</li>
<li>-server: 指定Java虚拟机运行在Server模式下, 并使用C2编译器(#C2进行耗时较长的优化, 以及激进优化, 但优化的代码执行效率更高)</li>
</ul>
<h4 id="3-5-3-C1和C2编译器不同的优化策略"><a href="#3-5-3-C1和C2编译器不同的优化策略" class="headerlink" title="3.5.3 C1和C2编译器不同的优化策略"></a>3.5.3 C1和C2编译器不同的优化策略</h4><ul>
<li>C1编译器上主要有方法内联、去虚拟化、冗余消除</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-</span> <span class="string">方法内联: 将引用的函数代码编译到引用点处, 这样可以减少栈帧的生成, 减少参数传递以及跳转的过程</span></span><br><span class="line"><span class="attr">-</span> <span class="string">去虚拟化: 对唯一的实现类进行内联</span></span><br><span class="line"><span class="attr">-</span> <span class="string">冗余消除: 在运行期间把一些不会执行的代码折叠</span></span><br></pre></td></tr></table></figure>

<ul>
<li>C2的优化主要是在全局层面, 逃逸分析是优化的基础</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-</span> <span class="string">标量替换: 用标量值代替聚合对象的属性值</span></span><br><span class="line"><span class="attr">-</span> <span class="string">栈上分配: 对于未逃逸的对象分配空间在栈上而不是堆上</span></span><br><span class="line"><span class="attr">-</span> <span class="string">同步消除: 消除同步操作, 通常指synchronized</span></span><br></pre></td></tr></table></figure>

<p>一般来说,JIT编译出的机器码性能比解释器高,C2编译器启动时长比C1编译器慢,系统稳定执行后,C2编译器执行速度远远快于C1编译器</p>
<h3 id="3-6-Graal-amp-AOT编译器"><a href="#3-6-Graal-amp-AOT编译器" class="headerlink" title="3.6 Graal &amp; AOT编译器"></a>3.6 Graal &amp; AOT编译器</h3><p>自JDK10起, HotSpot加入了一个全新的即时编译器: Graal编译器</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 激活Graal的虚拟机参数</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler</span></span><br></pre></td></tr></table></figure>

<p>JDK9引入了AOT编译器(静态提前编译器, Ahead Of Compiler)</p>
<p>JDK9引入了实验性AOT编译工具jaotc 它借助了Graal编译器, 将所输入的Java类文件转换为机器码, 并存放至生成的动态共享库之中</p>
<p>所谓的AOT编译, 是与即使编译相对立的一个概念 即时编译是指在程序运行过程中将字节码转换为可在硬件上直接运行的机器码, 并部署至托管环境中的过程。 而AOT编译指的是在程序运行之前, 便将字节码转换为机器码的过程</p>
<p>优点: </p>
<ul>
<li>Java虚拟机加载已经预编译成二进制库,  可以直接运行,  不必等待即使编译器的预热</li>
</ul>
<p>缺点: </p>
<ul>
<li>破坏了Java一次编译, 到处运行的特点,必须为每个不同硬件、OS编译对应的发行包</li>
<li>降低了Java链接过程中的动态性, 加载的代码在编译期就必须全部已知</li>
<li>还需要持续优化中,最初只支持Linux x64 java base</li>
</ul>
<h2 id="4-String的基本特性"><a href="#4-String的基本特性" class="headerlink" title="4 String的基本特性"></a>4 String的基本特性</h2><ul>
<li>字符串常量池中是不会储存相同内容的字符串</li>
<li>字符串常量池存储在堆中(jdk8及其之后), 而jdk7及其之前是存储在永久代中</li>
<li>String 的String Pool是一个固定大小的Hashtable,如果放进String Pool的String非常多,就会造成Hash冲突严重,从而导致链表会很长,而链表很长会直接造成的影响就是当调用String.intern()时性能下降</li>
<li>可以使用<code>-XX:StingTableSize</code>设置StringTable的长度</li>
<li>uintx StringTableSize&#x3D;10 is outside the allowed range [ 128 … 16777216 ]</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认字符串常池的大小(JDK12)</span></span><br><span class="line"><span class="attr">jps</span></span><br><span class="line"><span class="attr">jinfo</span> <span class="string">-flag StringTableSize java进程id</span></span><br><span class="line"><span class="attr">&gt;&gt;&gt;</span> <span class="string">-XX:StringTableSize=65536</span></span><br></pre></td></tr></table></figure>

<p>Java语言规范里要求完全相同的字符串常量, 应该包含同样的Unicode字符序列(包含同一份码点序列的常量), 并且必须是指向同一个String类实例</p>
<h3 id="4-1-intern-的总结"><a href="#4-1-intern-的总结" class="headerlink" title="4.1 intern() 的总结"></a>4.1 intern() 的总结</h3><ul>
<li>JDK6中, 将这个字符串对象尝试放入到串池中。如果串池中没有,则并不会放入,返回已有的串池中对象的地址。如果没有会把此对象复制一份放入串池,并返回串池中的对象地址</li>
<li>JDK7起,将这个字符串对象尝试放入到串池。如果串池中有,则并不会放入。返回已有的串池中的对象地址。如果没有则会把对象的引用地址复制一份,放入串池,并返回串池中的引用地址</li>
</ul>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -Xlog:gc* 代替 -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"># XX:+PrintStringTableStatistics打印字符串常量池中的统计信息</span></span><br><span class="line"><span class="attr">-Xms10m</span> <span class="string">-Xmx10m -XX:+PrintStringTableStatistics -Xlog:gc*</span></span><br></pre></td></tr></table></figure>

<h2 id="5-垃圾回收"><a href="#5-垃圾回收" class="headerlink" title="5 垃圾回收"></a>5 垃圾回收</h2><p>什么是垃圾?</p>
<p>垃圾是指在运行程序中没有任何指针指向的对象</p>
<h3 id="5-1-垃圾标记阶段"><a href="#5-1-垃圾标记阶段" class="headerlink" title="5.1 垃圾标记阶段"></a>5.1 垃圾标记阶段</h3><ul>
<li>在堆中存放着几乎所有的Java对象实例,在GC执行垃圾回收之前,首先需要区分出内存中哪些是存活对象,哪些是已经死亡的对象,只有被标记为已经死亡的对象,GC才会在执行垃圾回收时,释放掉其所占有的内存空间,因此这个过程可以成为垃圾回收阶段</li>
<li>当一个对象已经不再被任何的存活对象继续引用时,就可以宣告为已经死亡</li>
<li>判断对象存活一般有两种方式: 引用计数算法和可达性分析算法</li>
</ul>
<h4 id="5-1-1-引用计数算法-标记阶段"><a href="#5-1-1-引用计数算法-标记阶段" class="headerlink" title="5.1.1 引用计数算法(标记阶段)"></a>5.1.1 引用计数算法(标记阶段)</h4><ul>
<li>引用计数算法(Reference Counting)对每个对象保存一个整型的引用计数器属性,用于记录对象被引用的情况</li>
<li>优点: 实现简单,垃圾对象便于辨识; 判定效率高, 回收没有延迟性</li>
<li>缺点:<ul>
<li>它需要单独的字段储存计数器,这样的做法增加了储存开销</li>
<li>每次赋值都需要更新计数器,伴随着加法和减法操作,这增加了时间开销</li>
<li>引用计数器有一个严重的问题,即无法处理循环引用的情况,导致在Java的垃圾回收器中没有使用这类算法</li>
</ul>
</li>
</ul>
<h4 id="5-1-2-标记-清除算法-清除阶段"><a href="#5-1-2-标记-清除算法-清除阶段" class="headerlink" title="5.1.2 标记-清除算法(清除阶段)"></a>5.1.2 标记-清除算法(清除阶段)</h4><p>最早出现也是最基础的算法(Mark - Sweep) 于1960年由Lisp之父John McCarthy提出</p>
<p>分为两个阶段: 首先标记出需要回收的对象,在标记完成后,统一回收掉所有被标记的对象,也可以反过来,标记存活的对象,统一回收所有未被标记的对象 标记过程就是对象是否属于垃圾的判定过程</p>
<h4 id="5-1-3-可达性分析算法-根搜索算法、追踪性垃圾收集-标记阶段"><a href="#5-1-3-可达性分析算法-根搜索算法、追踪性垃圾收集-标记阶段" class="headerlink" title="5.1.3 可达性分析算法(根搜索算法、追踪性垃圾收集)(标记阶段)"></a>5.1.3 可达性分析算法(根搜索算法、追踪性垃圾收集)(标记阶段)</h4><ul>
<li>相对于引用计数算法而言,可达性分析算法不仅同样具备实现简单和执行高效等特点, 更重要的是该算法可以有效解决在引用计数算法中循环引用的问题,防止内存泄漏的发生</li>
</ul>
<h3 id="5-2-GC-Roots"><a href="#5-2-GC-Roots" class="headerlink" title="5.2 GC Roots"></a>5.2 GC Roots</h3><p>在Java语言中, GC Roots包括以下几类元素</p>
<ul>
<li>虚拟机栈中引用的对象: 各个线程被调用的方法中使用到的参数、局部变量、临时变量等</li>
<li>本地方法栈内JNI引用的对象</li>
<li>方法区中类静态属性引用的对象 比如Java类的引用类型静态变量</li>
<li>方法区中常量引用的对象 比如字符串常量池里的引用</li>
<li>所有被同步锁synchronized持有的对象</li>
<li>Java虚拟机内部的引用: 基本数据类型对应的Class对象,一些常驻的异常对象(NullPointerException、OutOfMemoryError), 系统类加载器</li>
<li>反映java虚拟机内部的JMXBean、JVM中注册的回调、本地代码缓存等</li>
<li>如果要使用可达性分析算法来判断内存是否可以回收, 那么分析工必须在一个能保障一致性的快照中进行 这点不满足的话分析结果的准确性就无法保证</li>
</ul>
<p>除了固定的GC Roots集合以外 还可以有其他对象临时性地加入 比如 分代收集和局部回收(Partial GC)</p>
<h3 id="5-3-对象的finalization机制"><a href="#5-3-对象的finalization机制" class="headerlink" title="5.3 对象的finalization机制"></a>5.3 对象的finalization机制</h3><p>Java语言提供了对象终止机制来允许开发人员提供对象被销毁之前的自定义处理逻辑</p>
<ul>
<li>当垃圾回收器发现没有引用指向一个对象 即垃圾回收此对象之前 总会先调用这个对象的finalize()方法</li>
<li>finalize()方法允许在子类中被重写 用于在对象被回收时进行资源释放</li>
</ul>
<p>永远不要主动调用某个对象的finalize()方法 应该交给垃圾回收机制调用</p>
<ul>
<li>在finalize()时可能会导致对象复活</li>
<li>finalize() 方法的执行时间是没有保障的 他完全由GC线程决定 极端情况下 若不发生GC 则finalize()方法将没有执行机会</li>
<li>一个糟糕的finalize()会严重影响GC的性能</li>
</ul>
<p>Java虚拟机中的对象可能的三种状态</p>
<ul>
<li>可触及的: 从根节点开始 可以到达这个对象</li>
<li>可复活的: 对象的所有引用都被释放 但是对象有可能在finalize()中复活</li>
<li>不可触及的: 对象的finalize()被调用 并且没有复活 那么就会进入不可触及状态 不可触及的对象不可能被复活 因为finalize()方法只会被调用一次</li>
</ul>
<p>一个无法触及的对象有可能在某一个条件下复活自己</p>
<p>判断一个对象是否可回收 至少要经历两次标记过程</p>
<ul>
<li>如果对象到GC Roots没有引用链 则进行第一次标记</li>
<li>进行筛选 判断此对象是否有必要执行finalize() 方法<ul>
<li>如果对象没有重写finalize方法 或者finalize方法已经被虚拟机调用过了 则虚拟机认为该对象没有必要执行finalize方法 此对象被判定为不可触及的</li>
<li>如果对象重写了finalize方法且还未执行过 那么 对象都被插入到F-Queue队列中: 由虚拟机自动创建的、低优先级的Finalizer线程触发其finalize方法执行</li>
<li>finalize方法是对象逃脱死亡的最后机会, 稍后GC会对F-Queue队列中的对象进行第二次标记 如果对象在finalize方法中与引用链上的任何一个对象建立了联系 那么在第二次标记时 对象会被移除”即将回收”集合 之后 若对象再次出现没有引用存在的情况 在这个情况下 finalize方法不会被再次调用 对象会直接变成不可触及的状态 也就是说 一个对象的finalize方法只会被调用一次</li>
</ul>
</li>
</ul>
<p>目前在JVM中比较常见的三种垃圾回收算法是标记清除算法(Mark-Sweep)、复制算法(Copying)、标记压缩算法(Mark-Compact)</p>
<h3 id="5-4-垃圾清除阶段"><a href="#5-4-垃圾清除阶段" class="headerlink" title="5.4 垃圾清除阶段"></a>5.4 垃圾清除阶段</h3><h4 id="5-4-1-标记清除算法-Mark-Sweep"><a href="#5-4-1-标记清除算法-Mark-Sweep" class="headerlink" title="5.4.1 标记清除算法(Mark-Sweep)"></a>5.4.1 标记清除算法(Mark-Sweep)</h4><p>执行过程: 当堆中的有效内存空间被耗尽时 就会停止整个程序(STW) 然后进行两项工作 第一项是标记 第二项则是清除</p>
<ul>
<li>标记: Collector从引用根节点开始遍历 标记所有被引用的对象 一般是在对象的Header中记录为可达对象 </li>
<li>清除: Collector对堆内存从头到尾进行线性的遍历 如果发现某个对象在其Header中没有标记为可达对象 则将其回收</li>
</ul>
<p>缺点: </p>
<ul>
<li>效率不算高</li>
<li>在进行GC的时候 需要停止整个应用程序</li>
<li>这种方式清理出来的空闲内存是不连续的, 产生内存碎片 需要维护一个空闲列表</li>
</ul>
<p>何为清除:</p>
<ul>
<li>所谓的清除并不是真的置空 而是把需要清除的对象地址保存在空闲的地址列表里 下次有新对象需要加载时 判断垃圾的位置空间是否够用 如果够用直接覆盖</li>
</ul>
<h4 id="5-4-2-复制算法-Copying"><a href="#5-4-2-复制算法-Copying" class="headerlink" title="5.4.2 复制算法(Copying)"></a>5.4.2 复制算法(Copying)</h4><p>核心思想</p>
<p>将活着的内存空间分为两块 每次只使用其中一块 在垃圾回收时将正在使用的内存中存活的对象赋值到未被使用的内存中 之后清除正在使用的内存块的所有对象 交换两个内存的角色 最后完成垃圾回收</p>
<p>优点</p>
<ul>
<li>没有标记和清除过程 实现简单 运行高效</li>
<li>可以保证空间的连续性 不会出现碎片问题</li>
</ul>
<p>缺点</p>
<ul>
<li>需要两倍的内存空间</li>
<li>对于G1这种拆分成大量region的GC 复制而不是移动 意味着GC需要维护region之间对象引用的关系 不管是内存占用或者是时间开销也不小</li>
</ul>
<p>如果系统中的非垃圾对象很多 那么复制算法会复制很多存活的对象 代价很大</p>
<p>应用场景</p>
<p>在新生代 对常规应用的垃圾回收 一次通常可以回收70%-99%的内存空间 回收性价比很高</p>
<h4 id="5-4-3-标记-压缩-标记-整理-Mark-Compact-算法"><a href="#5-4-3-标记-压缩-标记-整理-Mark-Compact-算法" class="headerlink" title="5.4.3 标记-压缩(标记-整理 Mark-Compact) 算法"></a>5.4.3 标记-压缩(标记-整理 Mark-Compact) 算法</h4><p>背景</p>
<p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下 这种情况下新生代经常发生 但是在老年代中 更常见的情况是大部分对象都是存活对象 如果依然使用复制算法 由于存活对象较多 复制的成本也将很高 因此 基于老年代垃圾回收的特性 需要使用其他的算法</p>
<p>执行过程</p>
<p>第一阶段和标记清除-算法一样 从根节点开始标记所有被引用对象</p>
<p>第二阶段将所有的存活对象压缩到内存的一端 按顺序排放 之后清除边界外所有的空间</p>
<p>优点</p>
<ul>
<li>消除了标记-清除算法当中 内存区域分散的缺点  再给新对象分配内存时 JVM只需持有一个内存的起始地址即可</li>
<li>消除了复制算法中 内存减半的高额代价</li>
</ul>
<p>缺点</p>
<ul>
<li>从效率上来说 标记-整理算法要低于复制算法</li>
<li>移动对象的同时 如果对象被其他对象引用 则还需调整引用的地址</li>
<li>移动过程中 需要全程暂停用户应用程序(STW)</li>
</ul>
<table>
<thead>
<tr>
<th>&#x2F;</th>
<th>Mark-Sweep</th>
<th>Mark-Compact</th>
<th>Copying</th>
</tr>
</thead>
<tbody><tr>
<td>速度</td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td>空间开销</td>
<td>少(但会堆积碎片)</td>
<td>少(不堆积碎片)</td>
<td>通常需要存活对象的2倍大小(不堆积碎片)</td>
</tr>
<tr>
<td>移动对象</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<h3 id="5-5-分代收集算法"><a href="#5-5-分代收集算法" class="headerlink" title="5.5 分代收集算法"></a>5.5 分代收集算法</h3><h3 id="5-6-增量收集算法"><a href="#5-6-增量收集算法" class="headerlink" title="5.6 增量收集算法"></a>5.6 增量收集算法</h3><p>基本思想</p>
<p>如果一次将所有的垃圾进行处理 需要造成系统长时间的停顿 那么就可以让垃圾回收线程和应用程序交替执行 每次 垃圾回收只会收集一小片区域的内存空间 接着切换到应用程序线程 来回切换 直到垃圾回收完成</p>
<p>增量收集算法的基础仍然是传统的标记-清除和复制算法 增量收集算法通过对线程间冲突的妥善处理 允许垃圾收集线程以分阶段的方式完成标记、清理和复制工作</p>
<p>缺点</p>
<p>使用这种方式 由于在垃圾回收过程中 间断性地还执行了应用程序代码 所以能够减少系统的停顿时间 但是 因为线程切换和上下文转换的消耗 会使得垃圾回收的总体成本上升 造成系统的吞吐量的下降</p>
<h3 id="5-7-分区算法"><a href="#5-7-分区算法" class="headerlink" title="5.7 分区算法"></a>5.7 分区算法</h3><p>一般来说 在相同条件下 对空间越大 一次GC时需要的时间就越长 有关GC产生的停顿也越长 为了更好地控制GC产生的停顿时间 将一块大的内存区域分割成多个小块 根据目标的停顿时间 每次合理地回收若干个小区间 而不是整个堆空间 从而减少一次GC所产生地停顿</p>
<p>分代算法将按照对象的生命周期长短划分为两个部分 分区算法将整个堆空间划分成连续的不同小区间region</p>
<p>每一个小区间都独立使用、独立回收 这种算法的好处是可以控制一次回收多少个小区间</p>
<h3 id="5-8-System-gc"><a href="#5-8-System-gc" class="headerlink" title="5.8 System.gc()"></a>5.8 System.gc()</h3><p>在默认情况下 通过System.gc() 或者Runtime.getRuntime().gc()的调用 会显示触发Full GC 同时对老年代和新生代进行回收 尝试释放被丢弃对象占用的内存</p>
<p>然而System.gc() 无法保证对垃圾收集器的调用</p>
<h3 id="5-9-内存溢出"><a href="#5-9-内存溢出" class="headerlink" title="5.9 内存溢出"></a>5.9 内存溢出</h3><p>内存溢出(OOM): 没有内存空间 并且垃圾收集器也无法提供更过内存</p>
<p>在抛出OutOfMemoryError之前 通常垃圾回收器会被触发 当然也不是在任何情况下垃圾回收器都会被触发 当分配一个超大数组且超过堆的最大值时 JVM可以判断出垃圾回收器并不能解决这个问题 所以直接抛出OOM</p>
<h3 id="5-10-内存泄漏"><a href="#5-10-内存泄漏" class="headerlink" title="5.10 内存泄漏"></a>5.10 内存泄漏</h3><p>举例</p>
<ul>
<li>单例模式 单例的生命周期和应用程序是一样的 如果持有对外部对象的引用的话 那么这个对象是不能被回收的 会导致内存泄漏的产生</li>
<li>一些提供close的资源未关闭导致的内存泄漏 比如数据库连接 网络连接 或者io连接必须手动close</li>
</ul>
<h3 id="5-11-垃圾收集器"><a href="#5-11-垃圾收集器" class="headerlink" title="5.11 垃圾收集器"></a>5.11 垃圾收集器</h3><img src="https://cdn.qingweico.cn/blog/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="垃圾收集器" />

<h4 id="5-11-1-Serial-收集器"><a href="#5-11-1-Serial-收集器" class="headerlink" title="5.11.1 Serial 收集器"></a>5.11.1 Serial 收集器</h4><p>一个单线程工作的收集器 </p>
<p>单线程的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作 更重要的是强调在它进行垃圾收集时 必须暂停其他所有工作的线程 直到它收集结束</p>
<h4 id="5-11-2-ParNew-收集器"><a href="#5-11-2-ParNew-收集器" class="headerlink" title="5.11.2 ParNew 收集器"></a>5.11.2 ParNew 收集器</h4><p>实质上是Serial 收集器的多线程并行版本 </p>
<h4 id="5-11-3-Parallel-Scavenge-收集器"><a href="#5-11-3-Parallel-Scavenge-收集器" class="headerlink" title="5.11.3 Parallel Scavenge 收集器"></a>5.11.3 Parallel Scavenge 收集器</h4><p>Parallel Scavenge也是一款新生代收集器 同样是基于标记-复制算法实现的收集器 也是能够并行收集的多线程收集器</p>
<p>Parallel Scavenge的特点是它的关注点和其他收集器不同 CMS等收集器的关注点是尽可能地缩短垃圾回收时用户线程的停顿时间 而Parallel Scavenge 收集器的目标则是达到一个可控的吞吐量(Throughput) 所谓的吞吐量就是运行用户代码的时间与处理器总消耗时间(运行用户代码时间 + 运行垃圾收集时间)的比值</p>
<h4 id="5-11-4-Serial-Old-收集器"><a href="#5-11-4-Serial-Old-收集器" class="headerlink" title="5.11.4 Serial Old 收集器"></a>5.11.4 Serial Old 收集器</h4><p>Serial Old 是Serial收集器的老年代版本 同样是一个单线程收集器 使用标记整理算法</p>
<p>这个收集器的主要意义也是供客户端模式下的HotSpot 虚拟机使用</p>
<p>如果在服务端模式下 也可能有两种用途</p>
<ul>
<li>一种是在JDK 5 以及之前的版本中与Parallel Scavenge 收集器搭配使用</li>
<li>另外一种就是作为 CMS收集器发生失败时的后备预案 在并发收集时发生Concurrent Mode Failure时使用</li>
</ul>
<h4 id="5-11-5-Parallel-Old-收集器"><a href="#5-11-5-Parallel-Old-收集器" class="headerlink" title="5.11.5 Parallel Old 收集器"></a>5.11.5 Parallel Old 收集器</h4><p>Parallel Old 是Parallel Scavenge 收集器的老年代版本 支持多线程并行收集 基于标记-整理算法实现</p>
<p>JDK6 时提供</p>
<h4 id="5-11-6-CMS-收集器"><a href="#5-11-6-CMS-收集器" class="headerlink" title="5.11.6 CMS 收集器"></a>5.11.6 CMS 收集器</h4><p>CMS(Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器</p>
<p>CMS 收集器基于标记-清除算法实现的 整个过程分为四个步骤</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除</li>
</ul>
<p>初始标记和重新标记需要STW</p>
<p>初始标记仅仅只是标记一下GC Roots能直接关联到的对象 速度很快</p>
<p>并发标记阶段就是从GC Roots直接关联的对象开始遍历整个对象图的过程</p>
<h4 id="5-11-7-Garbage-First-收集器"><a href="#5-11-7-Garbage-First-收集器" class="headerlink" title="5.11.7 Garbage First 收集器"></a>5.11.7 Garbage First 收集器</h4><p>简称G1 收集器是垃圾收集器技术发展历史上的里程碑式的成果</p>

    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">rss</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JVM/" rel="tag"># JVM</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/24/Java-Concurrency-in-Practice/" rel="prev" title="Java Concurrency in Practice">
      <i class="fa fa-chevron-left"></i> Java Concurrency in Practice
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/08/19/article/" rel="next" title="心灵">
      心灵 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Deep-understanding-of-the-Java-Virtual-Machine"><span class="nav-number">1.</span> <span class="nav-text">Deep understanding of the Java Virtual Machine</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">1.1.</span> <span class="nav-text">1 类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 类的加载过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 类加载器的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3 双亲委派机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="nav-number">1.2.</span> <span class="nav-text">2 运行时数据区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-PC%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 PC寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 虚拟机栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E6%A0%88%E5%B8%A7%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">2.2.1 栈帧的内部结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">2.2.2 局部变量表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-2-1%E5%85%B3%E4%BA%8ESlot%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.2.2.2.1.</span> <span class="nav-text">2.2.2.1关于Slot的理解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-2-2-%E6%80%BB%E7%BB%93"><span class="nav-number">1.2.2.2.2.</span> <span class="nav-text">2.2.2.2 总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">2.2.3 操作数栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">2.2.4 动态链接</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-4-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">1.2.2.4.1.</span> <span class="nav-text">2.2.4.1 为什么需要常量池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-4-2-%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="nav-number">1.2.2.4.2.</span> <span class="nav-text">2.2.4.2 方法的调用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-4-3-%E8%99%9A%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%9E%E8%99%9A%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.2.4.3.</span> <span class="nav-text">2.2.4.3 虚方法和非虚方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-4-4-%E5%85%B3%E4%BA%8Einvokedynamic%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.2.4.4.</span> <span class="nav-text">2.2.4.4 关于invokedynamic指令</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-5-%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">2.2.5 方法返回地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-6-%E4%B8%80%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF"><span class="nav-number">1.2.2.6.</span> <span class="nav-text">2.2.6 一附加信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 本地方法栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%A0%86"><span class="nav-number">1.2.4.</span> <span class="nav-text">2.4 堆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-%E5%A0%86%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">2.4.1  堆空间大小的设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-%E5%B9%B4%E8%BD%BB%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">2.4.2  年轻代和老年代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-3-MinorGC-YGC-%E3%80%81MajorGC%E3%80%81-FullGC"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">2.4.3  MinorGC(YGC)、MajorGC、 FullGC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-3-%E5%88%86%E4%BB%A3%E5%BC%8FGC%E7%AD%96%E7%95%A5%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">2.4.3 分代式GC策略的触发条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-5-%E5%A0%86%E7%A9%BA%E9%97%B4%E5%88%86%E4%BB%A3%E6%80%9D%E6%83%B3"><span class="nav-number">1.2.4.5.</span> <span class="nav-text">2.4.5 堆空间分代思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-6-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-number">1.2.4.6.</span> <span class="nav-text">2.4.6 内存分配策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-7-TLAB-Thread-Local-Allocation-Buffer"><span class="nav-number">1.2.4.7.</span> <span class="nav-text">2.4.7 TLAB(Thread Local Allocation Buffer)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-8-%E5%A0%86%E7%A9%BA%E9%97%B4%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.2.4.8.</span> <span class="nav-text">2.4.8 堆空间常用参数设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-9-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="nav-number">1.2.4.9.</span> <span class="nav-text">2.4.9 逃逸分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-9-1-%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2"><span class="nav-number">1.2.4.9.1.</span> <span class="nav-text">2.4.9 .1 标量替换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">1.2.5.</span> <span class="nav-text">2.5 方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-1-HotSpot%E4%B8%AD%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">2.5.1 HotSpot中方法区的演进</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-2-%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%E5%8C%BA%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">2.5.2 设置方法区大小的参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-3-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">2.5.3 方法区的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-3-1-%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="nav-number">1.2.5.3.1.</span> <span class="nav-text">2.5.3.1 类型信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-3-2-%E5%9F%9F-Field-%E4%BF%A1%E6%81%AF"><span class="nav-number">1.2.5.3.2.</span> <span class="nav-text">2.5.3.2 域(Field)信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-3-3-%E6%96%B9%E6%B3%95-Method-%E4%BF%A1%E6%81%AF"><span class="nav-number">1.2.5.3.3.</span> <span class="nav-text">2.5.3.3 方法(Method)信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-3-4-class%E6%96%87%E4%BB%B6%E4%B8%AD%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">1.2.5.3.4.</span> <span class="nav-text">2.5.3.4 class文件中常量池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-3-5-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">1.2.5.3.5.</span> <span class="nav-text">2.5.3.5 运行时常量池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-3-6-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B%E7%BB%86%E8%8A%82"><span class="nav-number">1.2.5.3.6.</span> <span class="nav-text">2.5.3.6 方法区的演进细节</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-3-7-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">1.2.5.3.7.</span> <span class="nav-text">2.5.3.7 方法区的垃圾回收</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-3-8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E4%BD%8D%E7%BD%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%B0%83%E6%95%B4"><span class="nav-number">1.2.5.3.8.</span> <span class="nav-text">2.5.3.8 字符串常量池的位置为什么要调整?</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">1.2.6.</span> <span class="nav-text">2.6 对象的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-1-%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%AF%B9%E5%BA%94%E7%9A%84%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8A%A0%E8%BD%BD%E3%80%81%E9%93%BE%E6%8E%A5%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">2.6.1 判断对象对应的类是否加载、链接、初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-2-%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%86%85"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">2.6.2 为对象分配内</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-3-%E5%A4%84%E7%90%86%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">2.6.3 处理并发安全问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-4-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%86%E9%85%8D%E5%88%B0%E7%9A%84%E7%A9%BA%E9%97%B4"><span class="nav-number">1.2.6.4.</span> <span class="nav-text">2.6.4 初始化分配到的空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-5-%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="nav-number">1.2.6.5.</span> <span class="nav-text">2.6.5 设置对象的对象头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-6-%E6%89%A7%E8%A1%8Cinit%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.2.6.6.</span> <span class="nav-text">2.6.6 执行init方法进行初始化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">1.2.7.</span> <span class="nav-text">2.7 对象的内存布局</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-1%E5%AF%B9%E8%B1%A1%E5%A4%B4-Header"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">2.7.1对象头(Header)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-2-%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE-Instance-Data"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">2.7. 2 实例数据 (Instance Data)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-3-%E5%AF%B9%E9%BD%90%E5%A1%AB%E5%85%85-Padding"><span class="nav-number">1.2.7.3.</span> <span class="nav-text">2.7.3 对齐填充(Padding)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-4-%E5%B7%A5%E5%85%B7-JOL-x3D-Java-Object-Layout"><span class="nav-number">1.2.7.4.</span> <span class="nav-text">2.7.4 工具: JOL &#x3D; Java Object Layout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-5-%E5%85%B3%E9%97%AD%E6%8C%87%E9%92%88%E5%8E%8B%E7%BC%A9"><span class="nav-number">1.2.7.5.</span> <span class="nav-text">2.7.5 关闭指针压缩</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="nav-number">1.2.8.</span> <span class="nav-text">2.8 对象访问定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98-%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98"><span class="nav-number">1.2.9.</span> <span class="nav-text">2.9 直接内存(堆外内存)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-10-Java%E5%86%85%E5%AD%98%E7%8A%B6%E5%86%B5%E5%88%86%E6%9E%90"><span class="nav-number">1.2.10.</span> <span class="nav-text">2.10 Java内存状况分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="nav-number">1.3.</span> <span class="nav-text">3 执行引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 执行引擎的工作过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Java%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2 Java代码编译和执行过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E6%8C%87%E4%BB%A4-amp-%E6%B1%87%E7%BC%96"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.3 指令&amp;汇编</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E6%8C%87%E4%BB%A4"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">3.3.1 指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">3.3.2 指令集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">3.3.3 汇编语言</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-JIT%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-number">1.3.4.</span> <span class="nav-text">3.4 JIT编译器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-%E7%83%AD%E7%82%B9%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%8E%A2%E6%B5%8B%E6%96%B9%E5%BC%8F"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">3.4.1 热点代码及探测方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%BC%8F-amp-C1%E3%80%81C2%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-number">1.3.5.</span> <span class="nav-text">3.5 执行模式 &amp; C1、C2编译器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-%E8%AE%BE%E7%BD%AEHotSpot%E7%9A%84%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">3.5.1 设置HotSpot的执行模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-HotSpot-VM%E4%B8%ADJIT%E5%88%86%E7%B1%BB"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">3.5.2 HotSpot VM中JIT分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-3-C1%E5%92%8CC2%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="nav-number">1.3.5.3.</span> <span class="nav-text">3.5.3 C1和C2编译器不同的优化策略</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-Graal-amp-AOT%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-number">1.3.6.</span> <span class="nav-text">3.6 Graal &amp; AOT编译器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-String%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="nav-number">1.4.</span> <span class="nav-text">4 String的基本特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-intern-%E7%9A%84%E6%80%BB%E7%BB%93"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1 intern() 的总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">1.5.</span> <span class="nav-text">5 垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E5%9E%83%E5%9C%BE%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5"><span class="nav-number">1.5.1.</span> <span class="nav-text">5.1 垃圾标记阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95-%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">5.1.1 引用计数算法(标记阶段)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95-%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">5.1.2 标记-清除算法(清除阶段)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95-%E6%A0%B9%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E3%80%81%E8%BF%BD%E8%B8%AA%E6%80%A7%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86-%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">5.1.3 可达性分析算法(根搜索算法、追踪性垃圾收集)(标记阶段)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-GC-Roots"><span class="nav-number">1.5.2.</span> <span class="nav-text">5.2 GC Roots</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E5%AF%B9%E8%B1%A1%E7%9A%84finalization%E6%9C%BA%E5%88%B6"><span class="nav-number">1.5.3.</span> <span class="nav-text">5.3 对象的finalization机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E5%9E%83%E5%9C%BE%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5"><span class="nav-number">1.5.4.</span> <span class="nav-text">5.4 垃圾清除阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-1-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95-Mark-Sweep"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">5.4.1 标记清除算法(Mark-Sweep)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-2-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95-Copying"><span class="nav-number">1.5.4.2.</span> <span class="nav-text">5.4.2 复制算法(Copying)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-3-%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9-%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86-Mark-Compact-%E7%AE%97%E6%B3%95"><span class="nav-number">1.5.4.3.</span> <span class="nav-text">5.4.3 标记-压缩(标记-整理 Mark-Compact) 算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">1.5.5.</span> <span class="nav-text">5.5 分代收集算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">1.5.6.</span> <span class="nav-text">5.6 增量收集算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7-%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95"><span class="nav-number">1.5.7.</span> <span class="nav-text">5.7 分区算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-8-System-gc"><span class="nav-number">1.5.8.</span> <span class="nav-text">5.8 System.gc()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-9-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-number">1.5.9.</span> <span class="nav-text">5.9 内存溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-10-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">1.5.10.</span> <span class="nav-text">5.10 内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-11-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.5.11.</span> <span class="nav-text">5.11 垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-11-1-Serial-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.5.11.1.</span> <span class="nav-text">5.11.1 Serial 收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-11-2-ParNew-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.5.11.2.</span> <span class="nav-text">5.11.2 ParNew 收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-11-3-Parallel-Scavenge-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.5.11.3.</span> <span class="nav-text">5.11.3 Parallel Scavenge 收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-11-4-Serial-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.5.11.4.</span> <span class="nav-text">5.11.4 Serial Old 收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-11-5-Parallel-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.5.11.5.</span> <span class="nav-text">5.11.5 Parallel Old 收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-11-6-CMS-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.5.11.6.</span> <span class="nav-text">5.11.6 CMS 收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-11-7-Garbage-First-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.5.11.7.</span> <span class="nav-text">5.11.7 Garbage First 收集器</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="启明"
      src="https://cdn.qingweico.cn/blog/53fd3cbe09ce49fe809c0dbb32a2f232.jfif">
  <p class="site-author-name" itemprop="name">启明</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/qingweico" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;qingweico" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zqingwei99@gmail.com" title="E-Mail → mailto:zqingwei99@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">豫ICP备2020030311号 </a>
  </div>
<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">启明</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">36k</span>
</div>

<div class="busuanzi-count">
    <script async="" src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="site-uv">
      <i class="fa fa-user"></i>
      访问用户: <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 人
    </span>
    <div class="powered-by"> | </div>
    <span class="site-uv">
      <i class="fa fa-eye"></i>
      访问次数: <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次
    </span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
