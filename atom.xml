<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>流金岁月</title>
  
  <subtitle>流金岁月</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-02T10:46:05.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>启明</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netty</title>
    <link href="http://example.com/2022/01/02/Netty/"/>
    <id>http://example.com/2022/01/02/Netty/</id>
    <published>2022-01-02T10:46:05.000Z</published>
    <updated>2022-01-02T10:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Netty模型"><a href="#Netty模型" class="headerlink" title="Netty模型"></a>Netty模型</h3><ul><li>Netty抽象出两组线程池: BossGroup专门负责接受客户端连接, WorkerGroup专门负责网络读写操作</li><li>NioEventLoop表示一个不断循环执行处理任务的线程, 每个NioEventLoop都有一个selector, 用于监听绑定在其上的socket网络通道</li><li>NioEventLoop内部采用串行化设计, 从消息的读取和处理以及发送始终由IO线程NioEventLoop负责</li></ul><blockquote><p>NioEventLoopGroup下包含多个NioEventLoop</p><p>每个NioEventLoop中包含一个Selector 一个taskQueue</p><p>每个NioEventLoop的Selector上可以注册监听多个NioChannel</p><p>每个NioChannel 只会绑定在唯一的NioEventLoop上</p><p>每个NioChannel都绑定有一个自己的ChannelPipeline</p></blockquote><span id="more"></span><h3 id="异步模型"><a href="#异步模型" class="headerlink" title="异步模型"></a>异步模型</h3><ul><li><p>异步的概念和同步相对, 当异步过程调用发出后, 调用者不能立即得到结果, 实际处理这个调用的组件在完成过后, 通过状态、通知和回调来通知调用者</p></li><li><p>Netty中的I&#x2F;O操作是异步的, 包括bind write connect等操作会简单的返回一个ChannelFuture</p></li><li><p>调用者并不能立刻获得结果, 而是通过Future-Listener机制, 用户可以方便的主动获取或者通过通知机制获得IO操作结果</p></li><li><p>Netty的异步模型是建立在future和callback之上的; Future的核心思想是: 在调用一个比较耗时的方法时立马返回一个Future, 后续可以通过Future去监控方法的处理过程</p></li><li><p>Future表示异步的执行结果, 可以通过它提供的方法来检测执行是否完成</p></li></ul><h3 id="Netty的组件设计"><a href="#Netty的组件设计" class="headerlink" title="Netty的组件设计"></a>Netty的组件设计</h3><p>netty的主要组件有 </p><ul><li>Channel </li><li>EventLoop </li><li>ChannelFuture</li><li>ChannelHandler </li><li>ChannelPipe</li></ul><p>ChannelHandler 充当了处理入站和出站数据的应用程序逻辑的容器;业务逻辑通常写在一个或者多个ChannelHandler中</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Netty模型&quot;&gt;&lt;a href=&quot;#Netty模型&quot; class=&quot;headerlink&quot; title=&quot;Netty模型&quot;&gt;&lt;/a&gt;Netty模型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Netty抽象出两组线程池: BossGroup专门负责接受客户端连接, WorkerGroup专门负责网络读写操作&lt;/li&gt;
&lt;li&gt;NioEventLoop表示一个不断循环执行处理任务的线程, 每个NioEventLoop都有一个selector, 用于监听绑定在其上的socket网络通道&lt;/li&gt;
&lt;li&gt;NioEventLoop内部采用串行化设计, 从消息的读取和处理以及发送始终由IO线程NioEventLoop负责&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;NioEventLoopGroup下包含多个NioEventLoop&lt;/p&gt;
&lt;p&gt;每个NioEventLoop中包含一个Selector 一个taskQueue&lt;/p&gt;
&lt;p&gt;每个NioEventLoop的Selector上可以注册监听多个NioChannel&lt;/p&gt;
&lt;p&gt;每个NioChannel 只会绑定在唯一的NioEventLoop上&lt;/p&gt;
&lt;p&gt;每个NioChannel都绑定有一个自己的ChannelPipeline&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Netty" scheme="http://example.com/categories/Netty/"/>
    
    
    <category term="框架" scheme="http://example.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>面试题集合</title>
    <link href="http://example.com/2021/11/12/2021-10-28/"/>
    <id>http://example.com/2021/11/12/2021-10-28/</id>
    <published>2021-11-12T10:46:05.000Z</published>
    <updated>2022-02-11T03:23:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="面试题集合"><a href="#面试题集合" class="headerlink" title="面试题集合"></a>面试题集合</h1><p>解决高并发要关注线程和I&#x2F;O模型、数据库选型、缓存优化、缓冲区设计、解耦和消息队分布式服务设计等等方面的设计</p><p>LinkedHashMap是一个元素间用链表相连的哈希表</p><p>HashMap就是哈希表实现的Map; TreeMap就是用树实现的Map, Map是一种映射关系</p><p>AQS解决了Java语言没有实现同步原语底层框架的问题</p><p>B+树是一颗支持区间查找的B树</p><p>DNS是一个经典的分布式设计</p><p>BigTable是另一个</p><p>元编程是程序改写程序</p><span id="more"></span><h2 id="Buffer的原理和使用场景"><a href="#Buffer的原理和使用场景" class="headerlink" title="Buffer的原理和使用场景:"></a>Buffer的原理和使用场景:</h2><p>流是数据的载体, 代表随时间产生的数据</p><p>缓冲区是数据临时存放的区域, 起缓冲作用</p><p>缓冲的本质是排队, 流的本质是是数据</p><p>没有缓冲: 拒绝服务; 性能低下</p><p>有缓冲: 排队处理; 批量处理</p><ul><li>排队处理请求避免拒绝服务</li><li>批量写入磁盘快过多次写入</li><li>批量执行sql快过多次执行</li></ul><p>数据拷贝的成本: </p><ul><li>网卡 &gt;&gt; 内核空间(DMA)</li><li>内核空间 &gt;&gt; 用户空间缓冲区</li><li>用户空间缓冲区 &gt;&gt; 处理线程</li></ul><p>为什么不将设备的数据直接拷贝到用户空间</p><ul><li>进程的隔离</li><li>内核是连接设备和进程的桥梁, 用户程序直接沟通设备非常危险</li></ul><p>缓冲区的实现原理:</p><p>单向缓冲区:</p><ul><li>P: Position 下一个可写入的位置</li><li>L: Limit 缓冲区实际的写入限制</li><li>C: Capacity 缓冲区物理的写入限制</li></ul><p>flip反转操作:将读操作转换写操作, Position变为0, Limit变为Position的位置</p><p>clear清空缓冲区操作:Position置为零, Limit置为Capacity</p><p>rewind操作: 重新读操作 将Position置为0</p><h2 id="反射的概念"><a href="#反射的概念" class="headerlink" title="反射的概念"></a>反射的概念</h2><p>反射(reflection) 运行时查看、反观程序内部结构、甚至修改</p><ul><li>运行时数据(通常称为元数据MetaData)   模块、类、函数、注解、源代码</li><li>反观自身<ul><li>通过字符串找到一个类, 并调用某个方法</li><li>查看类的属性、方法</li><li>查看注解</li></ul></li><li>运行时修改   运行时修改的是Bytecode</li></ul><p>面向切面编程(Aspect Oriented Programming)</p><ul><li>关注点分离原则(Separation of Concern) </li><li>如何理解切面(Aspect) <ul><li>程序有一个关注点 + 多个其他关注点(Aspect)</li><li>可以配置主关注点和其他关注点一起工作</li></ul></li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>常见的RuntimeException异常</p><ul><li>IllegalMonitorStateException</li><li>NulPointerException</li><li>ClassCastException</li><li>IllegalArgumentException</li><li>IndexOutOfBoundsException</li><li>NumberFormatException</li><li>ArrayStoreException</li><li>UnsupportedOperationException</li></ul><p>非RuntimeException</p><ul><li>ClassNotFoundException</li><li>IOException</li></ul><p>常见的Error</p><ul><li><p>UnsupportedClassVersionError</p></li><li><p>NoClassDefFoundError</p></li><li><p>StackOverflowError</p></li><li><p>OutOfMemoryError</p></li></ul><p>Spring中所有的异常基于org.springframework.core.NestedRuntimeException</p><p>try-catch的性能</p><p>Java异常处理消耗性能的地方</p><ul><li>try-catch块影响JVM的优化</li><li>异常对象实例需要保存栈快照等信息</li></ul><p>Java的异常处理机制</p><ul><li>抛出异常: 创建异常对象, 交由运行时系统处理</li><li>捕获异常: 寻找合适的异常处理器处理异常, 否者终止运行</li></ul><p>Java异常处理原则</p><p>具体明确: 抛出的异常应能通过异常类名和message准确说明异常的类型和产生异常的原因</p><p>提早抛出: 应尽可能早的发现并抛出异常, 便于精准定位问题</p><p>延迟捕获: 异常的捕获和处理应尽可能延迟, 让掌握更多信息的作用域来处理异常</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk14 HashMap::putVal</span></span><br><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">    treeifyBin(tab, hash);</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk14 ConcurrentHashMap::putVal</span></span><br><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">    treeifyBin(tab, i);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk14 HashMap</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numberOfLeadingZeros</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// HD, Count leading 0&#x27;s</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="type">return</span> <span class="variable">i</span> <span class="operator">=</span>= <span class="number">0</span> ? <span class="number">32</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt; <span class="number">16</span>) &#123; n -= <span class="number">16</span>; i &gt;&gt;&gt;= <span class="number">16</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">8</span>) &#123; n -=  <span class="number">8</span>; i &gt;&gt;&gt;=  <span class="number">8</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">4</span>) &#123; n -=  <span class="number">4</span>; i &gt;&gt;&gt;=  <span class="number">4</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &lt;&lt;  <span class="number">2</span>) &#123; n -=  <span class="number">2</span>; i &gt;&gt;&gt;=  <span class="number">2</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> n - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>   <span class="variable">MIN_VALUE</span> <span class="operator">=</span> <span class="number">0x80000000</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">highestOneBit</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i &amp; (MIN_VALUE &gt;&gt;&gt; numberOfLeadingZeros(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdk7 HashMap</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">roundUpToPowerOf2</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="comment">// assert number &gt;= 0 : &quot;number must be non-negative&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">        ? MAXIMUM_CAPACITY</span><br><span class="line">        : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">highestOneBit</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">// HD, Figure 3-1</span></span><br><span class="line">        i |= (i &gt;&gt;  <span class="number">1</span>);</span><br><span class="line">        i |= (i &gt;&gt;  <span class="number">2</span>);</span><br><span class="line">        i |= (i &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">        i |= (i &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">        i |= (i &gt;&gt; <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">return</span> i - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap-put方法的逻辑-jdk14"><a href="#HashMap-put方法的逻辑-jdk14" class="headerlink" title="HashMap: put方法的逻辑(jdk14)"></a>HashMap: put方法的逻辑(jdk14)</h3><ul><li>如果HashMap未被初始化过, 则初始化</li><li>对key求hash, 计算下标</li><li>如果没有碰撞, 直接放入桶中</li><li>如果发生碰撞, 以链表的方式链接单后面</li><li>如果链表长度超过阈值, 则树化</li><li>如果链表长度低于6, 则链表化</li><li>如果节点已存在则替换旧值</li><li>如果桶满了(threshold &#x3D; 容量 * 加载因子), 则扩容 resize 2倍</li></ul><p>如何有效减少碰撞</p><ul><li>使用扰动函数, 促使元素位置分布均匀, 减少碰撞几率</li><li>使用final对象并采用合适的equals()和hashCode()方法</li></ul><p>扩容问题</p><ul><li>多线程环境下: 调整大小会存在条件竞争, 容易造成死锁</li><li>rehashing是一个比较耗时的过程</li></ul><h3 id="ConcurrentHashMap-put方法的逻辑-jdk14"><a href="#ConcurrentHashMap-put方法的逻辑-jdk14" class="headerlink" title="ConcurrentHashMap: put方法的逻辑(jdk14)"></a>ConcurrentHashMap: put方法的逻辑(jdk14)</h3><ul><li>判断Node[]数组是否初始化, 没有则进行初始化</li><li>通过hash定位数组的索引坐标, 是否有Node节点, 如果没有则使用CAS进行添加(链表的头节点), 添加失败则进入下一次循环</li><li>若检查到内部正在扩容, 则帮助它一块扩容(helpTransfer)</li><li>如果链表的头节点不为空, 则使用synchronized锁住头节点(链表、红黑二叉树的头元素)<ul><li>如果是Node(链表结构), 则执行链表的添加操作</li><li>如果是TreeNode(树形结构), 则执行树添加操纵</li><li>如果ReservationNode(和ConcurrentHashMap的本地缓存相关) 则抛出异常</li></ul></li><li>判断链表长度已经达到临界值8, 若是则树化</li></ul><p>CAS + synchronized 比jdk7使用Segment 锁拆的更细, 性能提升了很多</p><p>首先使用无锁操作CAS插入头节点, 失败则循环重试</p><p>若头节点已存在, 则尝试获取头节点的同步锁, 再进行操作</p><p>ConcurrentHashMap博大精深(50多个内部类)</p><p>注意点: </p><ul><li>ConcurrentHashMap中的size()方法和mappingCount()方法的异同, 两者计算是否准确</li><li>多线程下如何进行扩容</li></ul><h2 id="J-U-C知识梳理"><a href="#J-U-C知识梳理" class="headerlink" title="J.U.C知识梳理"></a>J.U.C知识梳理</h2><p>JUC包的分类</p><ul><li>线程执行器executors</li><li>锁locks</li><li>原子变量atomic</li><li>并发工具类tools</li><li>并发集合collections</li></ul><h3 id="tools"><a href="#tools" class="headerlink" title="tools"></a>tools</h3><ul><li>CountDownLatch</li><li>CyclicBarrier</li><li>Semaphore</li><li>Executors</li><li>Exchanger</li></ul><h3 id="locks"><a href="#locks" class="headerlink" title="locks"></a>locks</h3><ul><li><p>Lock</p><ul><li>ReentrantLock</li><li>ReentrantReadWriteLock.ReadLock</li><li>ReentrantReadWriteLock.WriteLock</li></ul></li><li><p>Condition</p></li><li><p>ReadWriteLock</p><ul><li>ReentrantReadWriteLock</li></ul></li><li><p>LockSupport</p></li></ul><h3 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h3><p>基本数据类型</p><ul><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicLong</li></ul><p>数组</p><ul><li>AtomicIntegerArray</li><li>AtomicLongArray</li><li>AtomicReferenceArray</li></ul><p>引用类型</p><ul><li>AtomicReference</li><li>AtomicStampedReference</li><li>AtomicMarkableReference</li></ul><p>对象属性更新</p><ul><li>AtomicLongFieldUpdater</li><li>AtomicIntegerFieldUpdater</li><li>AtomicReferenceFieldUpdater</li></ul><p>累加器</p><ul><li>DoubleAccumulator</li><li>DoubleAdder</li><li>LongAccumulator</li><li>LongAdder</li></ul><h3 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h3><ul><li>Queue<ul><li>ConcurrentLinkedQueue</li><li>BlockingQueue<ul><li>ArrayBlockQueue</li><li>DelayQueue</li><li>LinkedBlockingQueue</li><li>PriorityBlockingQueue</li><li>SynchronousQueue</li></ul></li><li>Deque<ul><li>ArrayDeque</li><li>LinkedList</li><li>BlockingDeque<ul><li>LinkedBlockingQueue</li></ul></li></ul></li></ul></li><li>CopyOnWriteArrayList</li><li>CopyOnWriteArraySet</li><li>ConcurrentSkipSet</li><li>ConcurrentMap<ul><li>ConcurrentHashMap</li><li>ConcurrentNavigableMap<ul><li>ConcurrentSkipListMap</li></ul></li></ul></li></ul><h3 id="executor"><a href="#executor" class="headerlink" title="executor"></a>executor</h3><ul><li>Future<ul><li>RunnableFuture<ul><li>RunnableScheduleFuture</li><li>FutureTask</li></ul></li><li>ScheduledFuture</li></ul></li><li>Callable</li><li>Executor<ul><li>ExecutorService<ul><li>ScheduledExecutorService<ul><li>ScheduledThreadPoolExecutor</li></ul></li><li>ThreadPoolExecutor</li></ul></li></ul></li><li>CompletionService<ul><li>ExecutorCompletionService</li></ul></li><li>RejectedExecutionHandler<ul><li>ThreadPoolExecutor.DiscardPolicy</li><li>ThreadPoolExecutor.DiscardOldestPolicy</li><li>ThreadPoolExecutor.CallerRunsPolicy</li><li>ThreadPoolExecutor.AbortPolicy</li></ul></li><li>TimeUnit</li></ul><h2 id="Java的IO机制"><a href="#Java的IO机制" class="headerlink" title="Java的IO机制"></a>Java的IO机制</h2><p>ServerSocket是一个文件, 存放着所有连进来的client FD</p><h3 id="I-x2F-O多路复用"><a href="#I-x2F-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h3><p>调用系统级别的select&#x2F;poll&#x2F;epoll</p><p>select、poll、epoll的区别</p><table><thead><tr><th></th><th>支持一个进程所能打开的最大连接数</th><th>FD剧增后带来的IO效率问题</th><th>消息传递方式</th></tr></thead><tbody><tr><td>select</td><td>单个进程所能打开的最大连接数由FD_SETSIZE宏定义 其大小是32个整数的大小(在32位机器上大小是32＊32, 64位机器则是32 * 64) 可以对其进行修改 但是需要重新编译内核 其性能也无法保证</td><td>因为每次调用时都会对连接进行线性遍历 所以随着FD的增加会造成遍历速度的线性下降的性能问题</td><td>内核需要将消息传递到用户空间 需要内核的拷贝动作</td></tr><tr><td>poll</td><td>本质和select没有区别 但是它没有最大连接数的限制 其原因是它是基于链表来储存的</td><td>同上</td><td>同上</td></tr><tr><td>epoll</td><td>虽然连接数有上限 但是很大 1G内存的机器可以打开10万左右的连接</td><td>由于epoll是根据每个FD上的回调函数来实现的 只有活跃的的socket才会主动调用callback 所以在活跃socket较少的情况下 使用epoll不会有线性下降的性能问题 但是所有socket都活跃的情况下 可能会有性能问题</td><td>通过内核和用户空间共享一块内存来实现 性能较高</td></tr></tbody></table><p>单个线程处理多个Socket</p><ul><li>核心问题: 内核分发消息</li><li>select模型: 线程维护一个Socket FD的列表</li><li>epoll模型: 内核维护一个高效的二叉搜索树</li></ul><p>性能提升归根结底是算法和数据结构, 并不是同步异步以及阻塞和非阻塞的原因</p><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><p>Block-IO InputStream和OutputStream; Reader和Writer</p><p>同步阻塞</p><p>API设计: 操作会阻塞线程(让线程休眠)</p><p>原理: 利用CPU的中断</p><ul><li>阻塞的线程进入休眠, 将执行权限交给其他线程</li><li>优点: 阻塞时不会占用系统资源, 程序好理解</li><li>缺点: 高并发场景需要更多的线程资源, 线程的休眠唤醒需要成本</li></ul><p>适用范围 一般的高并发场景可以考虑(并行量特别大的场景除外)</p><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p><img src="https://cdn.qingweico.cn/blog/20211018151300.png" alt="20211018151300"></p><p>jdk1.4中引入了NIO</p><p>NonBlock-IO: 构建多路复用的, 同步非阻塞的IO操作</p><p>API设计: 操作不会阻塞线程, 读不到就返回null</p><p>特点: 程序需要不断地去主动询问内核数据是否已准备好</p><p>NIO的核心</p><ul><li>Channels</li><li>Buffers</li><li>Selectors</li></ul><p>Channel</p><ul><li>FileChannel<ul><li>transferTo: 把FileChannel中的数据拷到另外一个Channel</li><li>transferFrom: 把另外一个Channel中的数据拷贝到FileChannel</li></ul></li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><p>避免了两次用户态到内核态的切换 即”零拷贝” 效率高</p><p>Buffers</p><ul><li>八大数据类型除了String外都有各自对应的Buffer</li><li>MappedByteBuffer: 内存映射文件</li></ul><p>Selectors</p><h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><p><img src="C:\Users\周庆伟\AppData\Roaming\Typora\typora-user-images\image-20211020124829333.png" alt="image-20211020124829333"></p><p>原理: 由专门的数据结构负责统计发生的I&#x2F;O 再允许程序监听变更</p><p>API设计: 异步编程; 基于Future</p><p>原理 </p><ul><li>利用线程池技术、协程技术调度所有Future计算</li></ul><p>本质</p><ul><li>异步转同步</li></ul><p>AIO如何进一步加工处理结果</p><ul><li>基于回调: 实现CompletionHandler接口</li><li>返回Future: 通过isDone()查看是否准备好, 通过get() 等待返回数据</li></ul><p>通常结合epoll和directmemory技术</p><p>directmemory: DirectMapping</p><p>由内核创建一个堆外的内存, 再将堆外的内存给到JVM进程, 当数据到达网卡时, 由内核将数据拷贝至堆外缓冲区</p><p>本质: 堆外的缓冲区; 优点: 减少一次拷贝</p><table><thead><tr><th align="left">属性&#x2F;模型</th><th>阻塞</th><th>非阻塞NIO</th><th>异步AIO</th></tr></thead><tbody><tr><td align="left">blocking</td><td>阻塞同步</td><td>非阻塞同步</td><td>非阻塞异步</td></tr><tr><td align="left">线程数(server :  client)</td><td>1:1</td><td>1:N</td><td>0:N</td></tr><tr><td align="left">复杂度</td><td>简单</td><td>较复杂</td><td>复杂</td></tr><tr><td align="left">吞吐量</td><td>低</td><td>高</td><td>高</td></tr></tbody></table><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>链表是一种抽象(有很多的实现)的数据结构聚合(数据和操作的容器)</p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>栈的作用是配合执行程序, 提供执行程序的必须内存空间</p><p>栈储存程序执行时的临时数据</p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>吞吐量(Throughput): 程序工作时间占比(没有STW: GC没有占用CPU的时间)</p><p>多线程GC不一定能够提高Throughput</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># JVM参数 控制吞吐量</span></span><br><span class="line"><span class="attr">-XX</span>: <span class="string">GCTimeRatio=99</span></span><br></pre></td></tr></table></figure><p>JVM参数</p><ul><li>标准参数  -classpath</li><li>-X 扩展参数(非标准; 不保证每个JVM都支持) -Xmx256m 设置堆的最大大小</li><li>-XX 开发用(比如打印详细日志) -XX: +PrintGCDetails</li></ul><h3 id="Latency"><a href="#Latency" class="headerlink" title="Latency"></a>Latency</h3><p>指GC造成的停顿时间(STW时间)</p><ul><li>Pause Time: 一次STW的时间</li><li>吞吐量大并不一定代表延迟就低, 取决于Latency是否集中</li><li>多线程可以减少Latency</li><li>内存更大也可以减少Latency</li></ul><h3 id="FootPrint"><a href="#FootPrint" class="headerlink" title="FootPrint"></a>FootPrint</h3><p>指最终应用对内存的需求</p><p>内存使用100M&#x2F;s 回收速度80M&#x2F;s 每10s一次GC(STW全部回收)  &gt;&gt; FootPrint: 200M</p><p>假如GC可以无限使用CPU &gt;&gt; FootPrint 可以很低, 而延迟却很高</p><p>假如每次GC可以不中断 &gt;&gt; 高延迟</p><p>阿姆达定律是衡量并行计算的重要依据</p><h3 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h3><p>引用计数</p><p>Root Tracing</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">查看GC参数</span></span><br><span class="line">java -XX:+PrintCommandLineFlags -version</span><br></pre></td></tr></table></figure><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><h4 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h4><p>使用的算法是Root Tracing &amp; Mark-Sweep; 单线程, GC完才能继续</p><p>-XX: +UseSerialGC</p><p>适用的场景 </p><ul><li>吞吐量小, 内存回收量不大</li><li>容忍延迟, 不在意卡顿</li><li>单核, 内存小, 0~100M</li></ul><h4 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h4><h4 id="Parallel-并行"><a href="#Parallel-并行" class="headerlink" title="Parallel(并行)"></a>Parallel(并行)</h4><p>提供最大的Throughput</p><p>多线程 GC完才能继续</p><p>-XX:UseParallelGC</p><p>算法: Root Tracing &amp; Mark - Sweep</p><p>场景: 吞吐量要求 &gt; 延迟要求</p><h4 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h4><h4 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h4><h4 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h4><h4 id="Concurrent-Mark-Sweep-CMS"><a href="#Concurrent-Mark-Sweep-CMS" class="headerlink" title="Concurrent Mark Sweep(CMS)"></a>Concurrent Mark Sweep(CMS)</h4><p>减少Pause Time</p><h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><h4 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h4><h4 id="Shenandoah"><a href="#Shenandoah" class="headerlink" title="Shenandoah"></a>Shenandoah</h4><h4 id="Epsilon"><a href="#Epsilon" class="headerlink" title="Epsilon"></a>Epsilon</h4><h3 id="GC-的分代模型与分区模型"><a href="#GC-的分代模型与分区模型" class="headerlink" title="GC 的分代模型与分区模型"></a>GC 的分代模型与分区模型</h3><h3 id="JVM调试工具"><a href="#JVM调试工具" class="headerlink" title="JVM调试工具"></a>JVM调试工具</h3><h4 id="Jmeter"><a href="#Jmeter" class="headerlink" title="Jmeter"></a>Jmeter</h4><h4 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h4><h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><p>Java Virtual Machine statistics monitoring tool Java统计监控工具</p><p>eg</p><ul><li><p>man jstat</p></li><li><p>jstat -gcutil  pid: 显示关于垃圾收集的摘要 统计数据</p></li></ul><h4 id="jstatd"><a href="#jstatd" class="headerlink" title="jstatd"></a>jstatd</h4><p>jstat的守护进程 </p><p>RMI服务器应用程序</p><p><a href="https://docs.oracle.com/javase/1.5.0/docs/guide/security/PolicyFiles.html"><a href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/PolicyFiles.html">政策文件语法</a></a></p><h4 id="jcmd"><a href="#jcmd" class="headerlink" title="jcmd"></a>jcmd</h4><p>eg</p><ul><li>jcmd  pid GC.heap_info</li><li>jcmd pid VM.flags -all 查看虚拟机参数</li></ul><h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><ul><li>Java Memory Map</li><li>打印JVM实例的共享对象映射、堆内详细信息(支持远程调试)</li></ul><p>eg:</p><ul><li>jmap -dump:live,format&#x3D;b,file&#x3D;heap.bin pid</li><li>jhat heap.bin(Started HTTP server on port 7000)</li></ul><h4 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h4><p>分析java堆的命令, 可以将堆中的对象以html的形式显示出来 配合jmap命令使用</p><h4 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h4><ul><li>Java Configuration Info</li><li>查看修改虚拟机配置(支持远程)</li></ul><p>eg: </p><ul><li>jinfo pid 查看pid参数配置</li><li>jinfo -flag -XX:InitialHeapSize&#x3D;536870912&#x3D;536870912 pid(flag ‘-XX:InitialHeapSize’ cannot be changed)</li></ul><h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><ul><li>Java Stack Tace</li><li>打印Java的Srtack(支持远程调试)</li></ul><p>eg:</p><ul><li>jstack pid</li></ul><h4 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h4><h3 id="invoke调用"><a href="#invoke调用" class="headerlink" title="invoke调用"></a>invoke调用</h3><ul><li>invokespecial call super(), private, init()</li><li>invokedynamic call lambda +- 可以绕过检查、限制, 提高性能</li><li>invokestatic call static method</li><li>invokevirtual<ul><li>虚函数: 可以重写的函数</li><li>static private final 除外</li></ul></li><li>invokeinterface call interface</li></ul><h3 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h3><ul><li><p>load </p><ul><li><p>ClassLoader</p></li><li><p>static initializer&#x2F; static fields</p></li><li><p>&#96;&#96;&#96;java<br>static {}</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">  -</span> 触发原因: new/访问静态资源/loader加载等</span><br><span class="line"></span><br><span class="line"><span class="bullet">  -</span> finish &gt;&gt; loaded</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> create</span><br><span class="line"></span><br><span class="line"><span class="bullet">  -</span> allocate memory</span><br><span class="line"><span class="bullet">  -</span> constructor</span><br><span class="line"><span class="bullet">  -</span> finish &gt;&gt; created</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> live</span><br><span class="line"></span><br><span class="line"><span class="bullet">  -</span> in use  GC Root可以找到, 且被使用</span><br><span class="line"><span class="bullet">  -</span> invisible 泄漏 GC Root 可以找到, 但是没被使用</span><br><span class="line"><span class="bullet">  -</span> unreachable GC Root 不可达(会被回收)</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> destroy/gc</span><br><span class="line"></span><br><span class="line"><span class="bullet">  -</span> collected</span><br><span class="line"><span class="bullet">  -</span> finalize(终结)</span><br><span class="line"><span class="bullet">  -</span> deallocated</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">## 网络</span></span><br><span class="line"></span><br><span class="line">TCP中滑动窗口解决了可靠性以及传输速率问题</span><br><span class="line"></span><br><span class="line"><span class="section">## 线程池的作用</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 降低资源消耗: 通过池化技术重复利用已创建的线程, 降低线程创建和销毁造成的损耗</span><br><span class="line"><span class="bullet">-</span> 提高响应速度: 任务到达时, 无需等待线程创建即可立即执行</span><br><span class="line"><span class="bullet">-</span> 提高线程的可管理性: 线程是稀缺资源, 如果无限制的创建, 不仅会消耗系统资源还会因为线程的不合理分布导致资源调度失衡, 降低系统的稳定性; 使用线程池可以进行统一的分配、调优和监控</span><br><span class="line"><span class="bullet">-</span> 提供更多更强大的功能: 线程池具备可扩展性, 允许开发人员向其中增加更多的功能</span><br><span class="line"></span><br><span class="line">不建议使用Executors: 因为默认的Executors线程池底层是基于ThreadPoolExecutor构造函数封装的, 采用无界队列存放缓存任务, 会无限缓存任务容易发生内存溢出, 会导致最大的线程数失效</span><br><span class="line"></span><br><span class="line">ThreadPoolExecutor的继承关系</span><br><span class="line"></span><br><span class="line">![<span class="string">图1 ThreadPoolExecutor UML类图</span>](<span class="link">https://cdn.qingweico.cn/blog/912883e51327e0c7a9d753d11896326511272.png</span>)</span><br><span class="line"></span><br><span class="line">线程池中线程的生命周期状态</span><br><span class="line"></span><br><span class="line">![<span class="string">img</span>](<span class="link">https://cdn.qingweico.cn/blog/62853fa44bfa47d63143babe3b5a4c6e82532.png</span>)</span><br><span class="line"></span><br><span class="line">生命周期转换</span><br><span class="line"></span><br><span class="line">![<span class="string">图3 线程池生命周期</span>](<span class="link">https://cdn.qingweico.cn/blog/582d1606d57ff99aa0e5f8fc59c7819329028.png</span>)</span><br><span class="line"></span><br><span class="line">拒绝策略</span><br><span class="line"></span><br><span class="line">![<span class="string">9ffb64cc4c64c0cb8d38dac01c89c905178456</span>](<span class="link">https://cdn.qingweico.cn/blog/9ffb64cc4c64c0cb8d38dac01c89c905178456.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## MQ</span></span><br><span class="line"></span><br><span class="line"><span class="section">### mq的作用</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 异步处理</span><br><span class="line"><span class="bullet">-</span> 实现解耦</span><br><span class="line"><span class="bullet">-</span> 流量削峰</span><br><span class="line"></span><br><span class="line"><span class="section">### MQ与多线程实现异步的区别</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 多线程方式实现异步会消耗cpu资源, , 会发生cpu竞争的问题</span><br><span class="line"><span class="bullet">-</span> MQ方式实现异步解耦是完全解耦, 适合于大型项目可能会影响业务线程执行</span><br><span class="line"><span class="bullet">-</span> 小的项目可以使用多线程实现异步</span><br><span class="line"></span><br><span class="line"><span class="section">### mq如何避免消息堆积的问题</span></span><br><span class="line"></span><br><span class="line">产生背景: 生产者投递消息的速率与消费者消费的速率完全不匹配</span><br><span class="line"></span><br><span class="line">前者大于后者, 导致消息堆积的问题</span><br><span class="line"></span><br><span class="line">注意: rabbitmq中如果消息被消费成功, 则消息会被立即删除; 而kafka和rocketmq中消息被消费成功则不会立即删除</span><br><span class="line"></span><br><span class="line">解决: A 提高消费者消费的速率 B: 消费者应该以批量的形式获取消息, 减少网络传输的次数</span><br><span class="line"></span><br><span class="line">MQ如何保证消息不丢失</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> MQ服务器端将消息持久化到硬盘</span><br><span class="line"><span class="bullet">-</span> 生产者确保消息投递到mq服务器端, 使用消息确认机制</span><br><span class="line"><span class="bullet">-</span> 消费者必须确认消息消费成功(rabbitmq才会将消息删除, kafka或者rocketmq才会提交offset)</span><br><span class="line"></span><br><span class="line"><span class="section">### 生产者投递消息 mq宕机了如何处理</span></span><br><span class="line"></span><br><span class="line">生产者投递消息会将msg消息内容记录下来, 若发生消息投递失败, 可以根据该日志记录实现补偿机制(获取到msg日志消息内容实现重试)</span><br><span class="line"></span><br><span class="line"><span class="section">### mq如何保证消息顺序一致性</span></span><br><span class="line"></span><br><span class="line">产生背景: mq服务器集群或者mq采用分区模型架构存放消息, 每个分区对于一个消费者消费消息</span><br><span class="line"></span><br><span class="line">解决: 消息一定要投递到同一个mq、同一个分区模型、最终被同一个消费者消费</span><br><span class="line"></span><br><span class="line">核心原理: 设定相同的消息key, 根据相同的消息key, 计算hash, 存放在同一个分区中</span><br><span class="line"></span><br><span class="line">大多数的项目是不需要保证mq消息顺序一致性的问题, 只有在一些特定的场景中可能会需要; 比如MySQL和Redis实现异步同步数据</span><br><span class="line"></span><br><span class="line">若保证了消息的顺序一致性, 则会降低消费者消费的速率</span><br><span class="line"></span><br><span class="line"><span class="section">### mq如何保证消息幂等性</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 消费者获取消息, 如果消费消息失败, mq服务器则会间隔的形式实现重试策略</span><br><span class="line"><span class="bullet">-</span> 重试过程中, 需要保证业务幂等性问题, 保证业务不能够重复执行</span><br><span class="line"><span class="bullet">-</span> 可以通过全局的消息id, 提前查询, 如果该业务逻辑已经执行过, 则不会重复执行</span><br><span class="line"><span class="bullet">-</span> 也需要在db层保证幂等性问题, 唯一主键约束、乐观锁等</span><br><span class="line"></span><br><span class="line"><span class="section">### MySQL与Redis如何保证数据一致性</span></span><br><span class="line"></span><br><span class="line">产生背景:</span><br><span class="line"></span><br><span class="line">在分布式领域中同步数据 很难保证强一致性策略 都是采用最终一致性思想 短暂的数据延迟是允许的 但是最终数据必须要保证一致性</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 直接删除Redis缓存 (延迟双删策略 适合小项目)</span><br><span class="line"><span class="bullet">-</span> 基于MQ异步同步更新</span><br><span class="line"><span class="bullet">-</span> 基于canal框架订阅binlog同步</span><br><span class="line"></span><br><span class="line"><span class="section">### 基于canal框架订阅binlog同步</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> canal服务器伪装成mysql从节点订阅mysql主节点的binlog文件</span><br><span class="line"><span class="bullet">-</span> 当mysql主节点binlog文件发生变化时 则会给canal服务器端</span><br><span class="line"><span class="bullet">-</span> canal服务器将binlog文件转化为json的格式给MQ</span><br><span class="line"><span class="bullet">-</span> 消费者订阅MQ消息实现以异步的形式将数据同步到redis</span><br><span class="line"></span><br><span class="line"><span class="section">## 线程</span></span><br><span class="line"></span><br><span class="line">Java从1.1开始就不再采用用户级线程</span><br><span class="line"></span><br><span class="line"><span class="section">### java中线程的状态</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> NEW</span><br><span class="line"><span class="bullet">-</span> RUNNABLE</span><br><span class="line"><span class="bullet">-</span> WAITING</span><br><span class="line"><span class="bullet">-</span> TIME<span class="emphasis">_WAITING</span></span><br><span class="line"><span class="emphasis">- BLOCKED</span></span><br><span class="line"><span class="emphasis">- TERMINATED</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">Thread.join() : WAITING</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">Thread.sleep() : TIME_</span>WAITING</span><br><span class="line"></span><br><span class="line">网络请求: BLOCKED</span><br><span class="line"></span><br><span class="line">![<span class="string">a524e12c79382f8eacd0d84b6babbc2b</span>](<span class="link">http://cdn.qingweico.cn/blog/a524e12c79382f8eacd0d84b6babbc2b.png</span>)</span><br><span class="line"></span><br><span class="line">临界区(critical section): 发生竞争的区域(访问共享资源)</span><br><span class="line"></span><br><span class="line"><span class="section">### 解决竞争的办法</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 减少竞争</span><br><span class="line"><span class="bullet">-</span> 实现原子操作</span><br><span class="line"><span class="bullet">-</span> TAS指令: 可以看作是cas的一个特例(只支持0到1的更新)</span><br><span class="line"><span class="bullet">-</span> 互斥</span><br><span class="line"></span><br><span class="line"><span class="section">### 什么是同步</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 执行同步</span><br><span class="line"><span class="bullet">-</span> 数据同步</span><br><span class="line"></span><br><span class="line"><span class="section">### synchronized和ReentrantLock的区别</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Non-Blocking的算法(tryLock) + 支持timeout</span><br><span class="line"><span class="bullet">-</span> 后者使用更灵活</span><br><span class="line"><span class="bullet">-</span> ReentrantLock提供中断能力(lock.lockInterruptibly())</span><br><span class="line"><span class="bullet">-</span> synchronized经过性能优化: 早期Java没有轻量级锁的设计</span><br><span class="line"></span><br><span class="line"><span class="section">### synchronized关键字的设计</span></span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 一种不完全的实现方案</span></span><br><span class="line"></span><br><span class="line"><span class="code">```java</span></span><br><span class="line"><span class="code">enter(&amp;lcok) &#123;</span></span><br><span class="line"><span class="code">    while(!cas(&amp;lock, 0, 1)) &#123;</span></span><br><span class="line"><span class="code">        // 休眠</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">leave(&amp;lock) &#123;</span></span><br><span class="line"><span class="code">    lock = 0;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code">enter(&amp;lock);</span></span><br><span class="line"><span class="code">// 临界区</span></span><br><span class="line"><span class="code">leave(&amp;lock);</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>对休眠的三种理解: </p><ul><li>休眠少量的CPU周期(自旋锁)</li><li>定时休眠 (Thread.sleep)</li><li>信号休眠  信号唤醒(wait&#x2F;notify)</li></ul><blockquote><p>改版</p></blockquote><ul><li>尝试获取锁 &gt;&gt; 自旋少量次数获取锁 ? 得到锁 : 休眠  &gt;&gt; (唤醒) &gt;&gt; 尝试获取锁</li><li>优势: 提高在竞争较少时的性能</li><li>怎么实现唤醒一个线程的功能(操作系统API修改线程的状态以及JVM知道那些线程在休眠)</li></ul><p>synchronized需要实现的功能</p><ul><li>需要实现加锁和解锁的逻辑</li><li>需要自旋锁到休眠的升级逻辑</li><li>API设计:每个对象都可以上锁</li><li>线程可以在竞争不到资源时休眠</li><li>释放资源时唤醒休眠线程</li></ul><blockquote><p>monitor</p></blockquote><p>每个对象都关联一个monitor</p><p>偏向锁、轻量级锁以及重量级锁</p><h3 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h3><p>java同步器整体架构</p><p><img src="https://cdn.qingweico.cn/blog/fc66d0fafe49a6ba9cccae041cc9b286.png" alt="fc66d0fafe49a6ba9cccae041cc9b286"></p><p>Java提供的同步器开发框架</p><p>作用: 将用户和真正意义上的底层隔离: 用户实现同步控制算法时不再需要使用JVM提供的最底层的API </p><p>AQS区别于synchronized(built-in or intrinsic lock) Java提供的另一个实现同步的体系</p><p><img src="http://cdn.qingweico.cn/blog/d609a8ff2bc13468e341259d43aa70aa.png" alt="d609a8ff2bc13468e341259d43aa70aa"></p><p>AQS的功能特性</p><ul><li>基于Java实现</li><li>提供同步原语和高性能生产消费者结构</li><li>提供Non-Blocking能力(cas和tryLock)</li><li>提供定时能力</li><li>提供中断能力</li><li>提供线程间协作(Condition)</li><li>提供扩展数据结构的能力</li><li>内部提供整数状态</li><li>封装cas操作(acquire和release都是基于cas状态)以及内部封装高性能CLH队列(cas失败自动进入队列 条件等待自动进入队列)</li></ul><p>信号量(Semaphore)的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">queue = &#123;&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">localState</span> <span class="operator">=</span> state;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    localState = state;</span><br><span class="line">    <span class="keyword">if</span>(localState == <span class="number">0</span>) &#123;</span><br><span class="line">        queue.add(Thread.currentThread());</span><br><span class="line">        LockSupport.park();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">while</span>(!Unsafe.cas(&amp;state, localState, localState - <span class="number">1</span>))</span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line"><span class="keyword">while</span>(!Unsafe.cas(&amp;state, state, state + <span class="number">1</span>)) &#123;</span><br><span class="line">    LockSupport.unpark(queue.remove());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spin_lock并不是cas loop</p><p>但是cas_loop是spin_loop</p><p>CLH的解决方案:</p><p>尾部插入 头部删除</p><p>避免了双向链表且单链表性能好</p><p>说出6个Java的同步器</p><ul><li>ReentrantLock</li><li>Semaphore</li><li>CyclicBarrier</li><li>CountDownLatch</li><li>Phaser</li><li>Exchanger</li></ul><h3 id="Reentrant与synchronized的相似点"><a href="#Reentrant与synchronized的相似点" class="headerlink" title="Reentrant与synchronized的相似点"></a>Reentrant与synchronized的相似点</h3><ul><li>临界区保护 提供加锁和解锁的能力</li><li>都可重入</li><li>都提供线程之间的协作</li><li>提供锁的升级逻辑<ul><li>monitor: 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</li><li>AQS: cas -&gt; 休眠-&gt; 排队竞争</li></ul></li><li>都提供等待队列<ul><li>monitor: EnterList WaitSet</li><li>AQS: CLH队列</li></ul></li></ul><h3 id="Reentrant与synchronized的区别"><a href="#Reentrant与synchronized的区别" class="headerlink" title="Reentrant与synchronized的区别"></a>Reentrant与synchronized的区别</h3><ul><li>基于AQS vs 基于monitor</li><li>Java生态 vs 非Java生态</li><li>相应线程中断(InterruptedException) vs 不响应</li><li>提供tryLock vs 不提供</li><li>跨block vs 单block</li><li>可配置公平性 vs 不可配置</li></ul><p><img src="https://cdn.qingweico.cn/blog/412d294ff5535bbcddc0d979b2a339e6102264.png" alt="img"></p><h3 id="ReentrantLock-中公平锁和非公平锁的获取流程"><a href="#ReentrantLock-中公平锁和非公平锁的获取流程" class="headerlink" title="ReentrantLock 中公平锁和非公平锁的获取流程"></a>ReentrantLock 中公平锁和非公平锁的获取流程</h3><p>公平锁:</p><ul><li>当前线程获取锁的状态</li><li>判断锁的状态</li><li>若锁为自由状态(0), 判断是否需要入队; 若是, 则addwaiter进行入队操作; 若为否, 则cas加锁成功返回true,  cas加锁失败则进行入队操作</li><li>若锁为非自由状态(不是0), 判断是否重入; 若不是重入, 加锁失败, 则进行入队操作,  若是重入则直接获取锁成功; 入队后判断是否需要进行自旋获取锁; 若是, 则开始尝试自旋获取锁, 否则阻塞;</li></ul><p>非公平锁: </p><ul><li>首先进行cas加锁, 若成功获取锁则设置持有锁的线程为当前线程, 返回true, 否则判断是否重入; 若不是重入, 加锁失败, 返回false; 若是重入则获取锁成功, 返回true</li><li>若cas加锁失败, 则获取当前锁的状态; 若锁为自由状态, 尝试cas加锁; 若成功获取锁则返回true; 否者获取锁失败, 返回false</li><li>同公平锁</li></ul><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>信号量的作用是什么: 控制并发量</p><p>实现场景: 可以实现生产者消费者</p><p>为什么ArrayBlockingQueue不用Semaphore实现: 因为条件变量性能更好</p><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p> CyclicBarrier解决了什么问题:</p><ul><li>多个线程协作(通信)处理任务的问题: 实现了一套协作机制(循环 + 屏障)</li></ul><p>CountDownLatch也是解决了同样的问题, 不过只是一次CyclicBarrier周期</p><p>为什么不用ReentrantLock + 条件变量? </p><p>因为CyclicBarrier的场景具有通用性 抽象成数据结构更有价值 比如处理大量的数据和任务</p><h3 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h3><h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><p> 用于线程之间交换数据</p><p>场景: 利用Exchanger在生产者和消费者之间交换数据</p><p>解决了什么问题: 线程间交换数据(交换是一个高效的操作) 但是只能用于两个线程之间</p><p>总结</p><p>同步器解决了什么问题</p><ul><li>同步</li><li>协作模式</li></ul><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>并发三要素</p><ul><li>原子性 (线程切换带来的原子性问题)</li><li>有序性 (编译优化带来的有序性问题)</li><li>可见性 (缓存导致的可见性问题)</li></ul><h3 id="内存一致性"><a href="#内存一致性" class="headerlink" title="内存一致性"></a>内存一致性</h3><p>绝对意义上的并行并不存在</p><p>绝对意义上的并行: 指令A和指令B绝对意义上同时执行并且同时产生结果</p><p>不存在同一个时刻某个变量有多种状态(比如两个写内存的指令 不可能写完之后内存处于两种不同的状态)</p><ul><li>线性一致: 任何时刻都一致<ul><li>Sequential Consistency</li><li>单线程环境中永远线性一致</li></ul></li><li>弱一致性: 部分时刻一致 (partial) <ul><li>Weak Consistency</li><li>需要同步原语(primitives): 锁、信号量 happens-before原则、volatile 若不使用原语工具 Java是弱一致性</li></ul></li><li>没有一致性</li></ul><p>内存不一致的原因(相对于不同的观察者线程来说是不一致的):</p><ul><li>分级缓存策略</li><li>指令重排</li></ul><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><ul><li>确保语义上对变量的读、写操作顺序被观察到<ul><li>对volatile变量的读、写不会被重排到对它后续的读写之后(阻止指令重排)</li><li>保证写入的只可以马上同步到CPU缓存中(写入后要求CPU马上刷新缓存等价于synchronized的monitorexit的作用)</li><li>保证读取到最新版本的数据(读l3、主存甚至使用内存屏障 不同的CPU架构会有不同的实现方式)</li></ul></li><li>如果逻辑上变量的写在读之前发生 那么确保观察到的结果 写也在读之前发生<ul><li>即happens-before原则</li><li>确保有序性和可见性</li></ul></li></ul><p>符合happens-before规则</p><ul><li>单线程规则: 单线程对内存的访问符合happens-before规则</li><li>Monitor规则: synchronized对锁的释放happens-before对锁的获取</li><li>volatile规则: volatile 变量的操作happens-before对它的后续操作且周围的指令不会重排序</li><li>AtomicReference</li><li>Thread-Start规则: start()调用前的操作happens-before线程内的程序</li><li>Thread.join()规则: 线程的最后一条指令happens-before join后的第一条指令</li><li>happens-before具有传递性 若A happens-before B、B happens-before  C 则A happens-before C</li></ul><p>happens-before不是时间关系</p><ul><li>happens-before是发生顺序和观察到的结果关系</li><li>A happens-before B 指的是若A在B之前发生 那么A带来的变化在B可以观察到</li><li>happens-before是partial ordering(参考AtomicReference) 重要的顺序保证 其他仍然可以重排</li></ul><p>并发编程三要素</p><ul><li>原子性</li><li>有序性</li><li>可见性</li></ul><h3 id="解释一下volatile"><a href="#解释一下volatile" class="headerlink" title="解释一下volatile?"></a>解释一下volatile?</h3><ul><li>volatile变量读写是会增加内存屏障</li><li>volatile变量读写时会禁用局部指令重排</li><li>保证对volatile的操作happens-before另一个操作</li></ul><p>读屏障就是在读取volatile变量之前增加一条将变量内容从内存读入CPU缓存的指令</p><p>写屏障就是在volatile变量写入之后 将变量的值从CPU缓存写入内存中</p><p>指令重排是一种CPU策略 通过交换指令执行顺序获得最佳性能</p><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>延迟队列</p><p>作用: 控制流速</p><p>为什么要控制: 大量任务来领 系统负载超过临界点</p><ul><li>线程切换频繁</li><li>虚拟内存频繁交换</li><li>I&#x2F;O资源竞争</li></ul><p>方案:</p><ul><li>延迟队列</li><li>支持反向压力: 阻塞任务的提交者</li><li>访问拒绝: 拒绝任务的提交者</li></ul><p><img src="https://cdn.qingweico.cn/blog/725a3db5114d95675f2098c12dc331c3316963.png" alt="725a3db5114d95675f2098c12dc331c3316963"></p><p><img src="https://cdn.qingweico.cn/blog/a20efe788caf4f07a4ad027639c80b1d.png" alt="img"></p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>什么是悲观锁</p><p>站在mysql的角度分析: 当多个线程对同一行数据实现修改的时候 最后只有一个线程才能修改成功 若某个线程获取到行锁 则其他线程不能够对该数据做任何修改操作 切实阻塞状态</p><p>站在java的角度分析: 如果没有获取到锁 则会阻塞等待 后期唤醒锁的成本就会非常高</p><p>什么是乐观锁</p><p>乐观锁比较乐观 通过预期值或者版本号比较 如果不一致的情况则通过循环控制修改 当前线程不会被阻塞  效率比较高 但是乐观锁比较消耗CPU的资源</p><p>锁的重入性: 在同一个线程中锁可以不断传递, 可以直接获取</p><p>锁粗化就是将多个同步块的数量减少, 并将单个同步块的作用范围扩大 本质上就是将多次上锁、解锁的请求合并为同一次请求</p><p>锁消除就是虚拟机编译器在运行时检测到了共享数据没有锁的竞争, 从而将这些锁进行消除</p><p>用Mark Word中最低的三位代表锁状态, 其中1位是偏向锁位, 两位是普通锁位</p><p>轻量级锁是 JDK 6时加入的新型锁机制, 轻量级锁并不是用来代替重量级锁的, 它设计的初衷是在没有多线程竞争的前提下, 减少传统的重量级锁使用操作系统互斥量产生的性能消耗</p><p>轻量级锁的加锁过程: 在代码即将进入同步块的时候, 如果此同步对象没有被锁定(锁标志位为01状态), 虚拟机首先将在当前线程的栈帧中建立一个名为锁记录(Lock Record)的空间, 用于储存锁对象目前的Mark Word的拷贝, 然后虚拟机使用CAS操作尝试把对象的Mark Word 更新为指向Lock Record 的指针, 如果这个更新成功了, 即代表这个线程拥有了这个线程的锁, 并且Mark Word 的锁标志将转变为00 , 表示此对象处于轻量级锁定状态</p><p>自旋锁在 JDK1.4.2 中引入, 使用 -XX:+UseSpinning 来开启; JDK 6 中变为默认开启, 并且引入了自适应的自旋锁</p><p>竞争加剧: 有线程超过10次自旋, -XX:PreBlockSpin, 或者自旋线程数超过CPU核数的一半, 1.6之后, 加入自适应自旋 Adapative Self Spinning , JVM自己控制</p><p>自适应自旋锁意味着自旋的时间(次数)不再固定, 而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定; 如果在同一个锁对象上, 自旋等待刚刚成功获得过锁, 并且持有锁的线程正在运行中, 那么虚拟机就会认为这次自旋也是很有可能再次成功, 进而它将允许自旋等待持续相对更长的时间; 如果对于某个锁, 自旋很少成功获得过, 那在以后尝试获取这个锁时将可能省略掉自旋过程, 直接阻塞线程, 避免浪费处理器资源</p><p>偏向锁由于有锁撤销的过程revoke, 会消耗系统资源, 所以, 在锁争用特别激烈的时候, 用偏向锁未必效率高, 还不如直接使用轻量级锁</p><p>偏向锁: 也是 JDK 6中引入的一项锁优化措施, 它的目的是消除数据在无竞争情况下的同步原语, 进一步提高程序的运行性能</p><p>默认情况 偏向锁有个时延,  默认是4秒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设定时延参数</span></span><br><span class="line">-XX:BiasedLockingStartupDelay=<span class="number">0</span></span><br></pre></td></tr></table></figure><p>上偏向锁，指的就是, 把Mark Word的线程ID改为自己线程ID的过程</p><p>批量重偏向或者批量撤销(锁的降级方式: 只有在极端情况下出现, 一般不会出现)</p><p>JDK11, 打开就是偏向锁, 而JDK8默认对象头是无锁</p><p><img src="https://cdn.qingweico.cn/blog/Snipaste_2021-01-29_21-54-41.png" alt="Snipaste_2021-01-29_21-54-41"> </p><h2 id="无锁编程"><a href="#无锁编程" class="headerlink" title="无锁编程"></a>无锁编程</h2><h3 id="Lock-Free"><a href="#Lock-Free" class="headerlink" title="Lock-Free"></a>Lock-Free</h3><p>定义: 线程之间互相隔离  一个线程的延迟、阻塞、故障不会影响其他线程 同一时刻至少有一个线程可以进步</p><p>场景: </p><ul><li>CLH 队列 &gt;&gt; 线程通过cas竞争加入队列</li><li>SynchronousQueue cas竞争实现transfer操作(双向栈后者双向队列 )</li></ul><p>自旋锁(spinlock)不是LockFree</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spin_lock();</span><br><span class="line">i++;</span><br><span class="line">spin_unlock();</span><br></pre></td></tr></table></figure><h3 id="Obstruction-Free"><a href="#Obstruction-Free" class="headerlink" title="Obstruction Free"></a>Obstruction Free</h3><ul><li>线程间隔离(一个线程的延迟不影响其他线程的进步)</li><li>不要求一定有线程进步</li><li>线程最终可以进步</li></ul><p>Lock Free是在Obstruction Free的基础上保证至少有一个线程进步</p><h3 id="Wait-Free"><a href="#Wait-Free" class="headerlink" title="Wait Free"></a>Wait Free</h3><ul><li>在Lock Free的基础上保证所有线程同时进步</li><li>比Lock Free有更强的限制条件</li><li>场景: CopyOnWrite的读线程<ul><li>先拷贝o1 &gt;&gt; o2</li><li>更新o2</li><li>替换指向o1的引用</li></ul></li></ul><h3 id="Lockless-不用锁-和-LockFree-无锁-的区别"><a href="#Lockless-不用锁-和-LockFree-无锁-的区别" class="headerlink" title="Lockless(不用锁) 和 LockFree(无锁)的区别"></a>Lockless(不用锁) 和 LockFree(无锁)的区别</h3><p>不用锁的算法通常都是Lockless 线程之间可能回互相影响 例如阻塞队列(本质还是排队)</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>哪些地方用到: </p><ul><li>Spring事务模板</li><li>Spring MVC获取HttpRequest</li><li>AOP LCN分布式事务、分布式服务追踪框架源码</li></ul><p>ThreadLocal与synchronized区别</p><p> 都可以实现在多线程环境中保证线程安全</p><p>不同</p><ul><li>前者在每个线程中都有自己独立的局部变量; 空间换时间, 变量之间相互隔离, 相对来说效率比synchronized高</li><li>后者当多个线程竞争到同一个资源的时候, 最终只能有一个线程访问, 采用时间换空间的方式, 保证线程的安全问题</li></ul><h3 id="谈谈你对ThreadLocal的理解"><a href="#谈谈你对ThreadLocal的理解" class="headerlink" title="谈谈你对ThreadLocal的理解"></a>谈谈你对ThreadLocal的理解</h3><p>ThreadLocal提供了线程本地变量, 它可以保证访问到的变量属于当前线程, 每个线程都保存一个变量副本, 每个线程的变量都不同; ThreadLocal相当于提供了一种线程隔离, 将变量与线程相绑定, 实现传递数据, 线程隔离</p><p>ThreadLocal底层实现原理</p><ul><li>每个线程中都有自立独立的ThreadLocalMap对象</li><li>如果当前线程对应的ThreadLocalMap对象为空的情况下, 则创建该ThreadLocalMap对象, 并且赋值键值对</li><li>key为当前线程所创建的ThreadLocal对象, value就是object变量值</li></ul><h3 id="为什么线程缓存的是ThreadLocalMap对象"><a href="#为什么线程缓存的是ThreadLocalMap对象" class="headerlink" title="为什么线程缓存的是ThreadLocalMap对象"></a>为什么线程缓存的是ThreadLocalMap对象</h3><p>因为每个ThreadLocal对象只能缓存一个变量</p><p>而每个线程中可能会缓存有多个变量即多个ThreadLocal对象  而ThreadLocalMap可以存放n多个不同的ThreadLocal对象</p><p>强、软、弱、虚引用的区别</p><h3 id="强引用-软引用-弱引用-虚引用"><a href="#强引用-软引用-弱引用-虚引用" class="headerlink" title="强引用 软引用 弱引用 虚引用"></a>强引用 软引用 弱引用 虚引用</h3><p>强引用: 当内存不足时 JVM开始进行GC 对于强引用对象 就算是出现了OOM也不会对该引用斤进行回收</p><p>软引用: 当系统内存充足的时候不会被回收 而当系统内存不足时就会被回收 软引用通常用在对内存敏感的程序中 比如高速缓存就用到软引用 内存够用时就保留 不够时就回收</p><p>弱引用: 弱引用需要用到java.lang.ref.WeakReference来来实现 它比软引用生命周期更短 对于只有弱引用的对象来说 只要有GC 不管JVM的内存空间够不够用都会回收该对象占用的空间</p><p>虚引用: 虚引用需要java.lang.ref.PhantomReference类来实现 虚引用就是形同虚设 与其他几种引用不同 虚引用并不会决定对象的生命周期</p><h3 id="ThreadLocal为何会引发内存泄漏"><a href="#ThreadLocal为何会引发内存泄漏" class="headerlink" title="ThreadLocal为何会引发内存泄漏"></a>ThreadLocal为何会引发内存泄漏</h3><p>内存泄漏: 申请了内存 但是内存得不到释放</p><p>内存泄漏溢出:  申请内存时 发现申请内存不足 就会报错</p><p>原因:每个线程中都有自己独立的ThreadLocalMap对象 key为ThreadLocal对象 value是变量的值 </p><p>key为ThreadLocal作为Entry对象的key 是<em><strong>弱引用</strong></em> 而当ThreadLocal指向null的时候 Entry对象中的key变为空 该对象一直无法被GC回收 一直占用系统内存 有可能发生内存泄漏的问题</p><h3 id="如何防御ThreadLocal内存泄漏的问题"><a href="#如何防御ThreadLocal内存泄漏的问题" class="headerlink" title="如何防御ThreadLocal内存泄漏的问题"></a>如何防御ThreadLocal内存泄漏的问题</h3><ul><li>调用remove方法将不用的数据移出</li></ul><p>ThreadLocalMap与当前线程的生命周期一致</p><p>尽量不要使用全局的ThreadLocal</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>事务范围内没有上锁 即事务可以并发的启动</p><p>select for update触发了行锁</p><p>脏读(Dirty Read): 看到了未提交的变更</p><p>幻读(Phantom Read) 看到不存在的数据(未提交新创建的行或者未提交已删除的行)</p><p>MVCC: multiple version concurrency control(多版本并发控制)</p><p>数据库一致性即事务执行前后关系不被破坏</p><p>锁</p><ul><li>共享锁  允许读读 不可以读写或者写写</li><li>互斥锁</li></ul><p>select * from table for 触发表级的共享锁</p><p>select * from table where id &#x3D; 1 for update 触发行级的共享锁</p><p>数据库的持久性: 没有100%的持久性</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存起源于CPU缓存</p><p>缓存是为了加速数据访问的存储</p><ul><li>降低延迟</li><li>提高吞吐量</li></ul><p>读</p><ul><li>缓存穿透: 没有读到数据 读取缓存后的存储 如果在短时间内大量的请求没有命中则会发生缓存击穿</li><li>命中即缓存条目存在</li><li>穿透即没有命中</li></ul><p>写</p><ul><li>写入穿透 双写缓存和储存</li><li>回写<ul><li>先写缓存</li><li>延迟写入储存 比如按时延迟 缓冲延迟(redis中的订单列表) 其他事件触发(volatile)</li></ul></li></ul><p>LRU(Least Recently Used)</p><p>LFU(Least Frequent Used)</p><p>MRU(Most Recently Used)</p><p>多级缓存: 布隆过滤器</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;面试题集合&quot;&gt;&lt;a href=&quot;#面试题集合&quot; class=&quot;headerlink&quot; title=&quot;面试题集合&quot;&gt;&lt;/a&gt;面试题集合&lt;/h1&gt;&lt;p&gt;解决高并发要关注线程和I&amp;#x2F;O模型、数据库选型、缓存优化、缓冲区设计、解耦和消息队分布式服务设计等等方面的设计&lt;/p&gt;
&lt;p&gt;LinkedHashMap是一个元素间用链表相连的哈希表&lt;/p&gt;
&lt;p&gt;HashMap就是哈希表实现的Map; TreeMap就是用树实现的Map, Map是一种映射关系&lt;/p&gt;
&lt;p&gt;AQS解决了Java语言没有实现同步原语底层框架的问题&lt;/p&gt;
&lt;p&gt;B+树是一颗支持区间查找的B树&lt;/p&gt;
&lt;p&gt;DNS是一个经典的分布式设计&lt;/p&gt;
&lt;p&gt;BigTable是另一个&lt;/p&gt;
&lt;p&gt;元编程是程序改写程序&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Mongodb</title>
    <link href="http://example.com/2021/10/02/MongoDB/"/>
    <id>http://example.com/2021/10/02/MongoDB/</id>
    <published>2021-10-02T10:46:05.000Z</published>
    <updated>2021-10-02T10:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>[TOC]</p><h2 id="安装配置mongodb"><a href="#安装配置mongodb" class="headerlink" title="安装配置mongodb"></a>安装配置mongodb</h2><p>centos7.x</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-5.0.3-rc0.tgz /opt</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -zxvf mongodb-linux-x86_64-rhel70-5.0.3-rc0.tgz -C  /usr/local</span><br><span class="line"><span class="comment"># 重命名</span></span><br><span class="line"><span class="built_in">mv</span> mongodb-linux-x86_64-rhel70-5.0.3-rc0 mongodb</span><br></pre></td></tr></table></figure><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="comment"># Set MongoDB Configuration</span></span><br><span class="line"><span class="built_in">export</span> PATH=/usr/local/mongodb/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="comment"># 查看MongoDB版本</span></span><br><span class="line">mongo -verison</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> mongodb</span><br><span class="line"><span class="comment"># 用于储存数据库文件数据</span></span><br><span class="line"><span class="built_in">mkdir</span> data/db -p</span><br><span class="line"><span class="built_in">mkdir</span> data/logs</span><br><span class="line"><span class="comment"># 用于储存日志w</span></span><br><span class="line"><span class="built_in">cd</span> data/logs</span><br><span class="line"><span class="built_in">touch</span> mongodb.log</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在mongodb根目下创建核心配置文件</span></span><br><span class="line">vim mongodb.conf</span><br><span class="line"><span class="comment"># ========================================</span></span><br><span class="line"><span class="comment"># 端口号</span></span><br><span class="line">port=27017</span><br><span class="line"><span class="comment"># 数据库文件位置</span></span><br><span class="line">dbpath=/usr/local/mongodb/data/db</span><br><span class="line"><span class="comment"># 日志文件位置</span></span><br><span class="line">logpath=/usr/local/mongodb/data/logs/mongodb.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以追加日志的形式记录</span></span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 滤掉无用日志信息,若需要调试使用请设置为false</span></span><br><span class="line">quiet=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 以后台方式运行</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 最大同时连接数</span></span><br><span class="line">maxConns=100</span><br><span class="line"><span class="comment"># 不启用验证权限</span></span><br><span class="line">noauth=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 启用用户账号权限</span></span><br><span class="line"><span class="comment"># auth=true</span></span><br><span class="line"><span class="comment"># 开启日志,默认true</span></span><br><span class="line">journal=<span class="literal">true</span></span><br><span class="line"><span class="comment"># 提供外网访问,不对ip进行绑定,原理同redis的bindip</span></span><br><span class="line">bind_ip = 0.0.0.0</span><br><span class="line"><span class="comment"># ========================================</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动mongodb</span></span><br><span class="line">mongod -f mongodb.conf</span><br></pre></td></tr></table></figure><h2 id="创建mongodb用户账号权限"><a href="#创建mongodb用户账号权限" class="headerlink" title="创建mongodb用户账号权限"></a>创建mongodb用户账号权限</h2><p>修改配置文件mongodb.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不启用验证权限</span></span><br><span class="line"><span class="comment"># noauth=true</span></span><br><span class="line"><span class="comment"># 启用用户账号权限</span></span><br><span class="line">auth=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 重启mongodb</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入mongo控制台</span></span><br><span class="line">mongo</span><br><span class="line"><span class="comment"># 切换到admin库</span></span><br><span class="line">use admin</span><br><span class="line"><span class="comment"># 创建用户 账号和密码为root root 角色为root</span></span><br><span class="line">db.createUser(&#123;user: <span class="string">&quot;root&quot;</span>, <span class="built_in">pwd</span>: <span class="string">&quot;root&quot;</span>, roles: [<span class="string">&quot;root&quot;</span>]&#125;)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">角色名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Read</td><td align="left">允许用户读取指定数据库</td></tr><tr><td align="left">readWrite</td><td align="left">允许用户读写指定数据库</td></tr><tr><td align="left">dbAdmin</td><td align="left">允许用户在指定数据库中执行管理函数,如索引创建、删除,查看统计或访问system.profile</td></tr><tr><td align="left">userAdmin</td><td align="left">允许用户向system.users集合写入,可以找指定数据库里创建、删除和管理用户</td></tr><tr><td align="left">clusterAdmin</td><td align="left">只在admin数据库中可用, 赋予用户所有分片和复制集相关函数的管理权限</td></tr><tr><td align="left">readAnyDatabase</td><td align="left">只在admin数据库中可用, 赋予用户所有数据库的读权限</td></tr><tr><td align="left">readWriteAnyDatabase</td><td align="left">只在admin数据库中可用, 赋予用户所有数据库的读写权限</td></tr><tr><td align="left">userAdminAnyDatabase</td><td align="left">只在admin数据库中可用, 赋予用户所有数据库的userAdmin权限</td></tr><tr><td align="left">dbAdminAnyDatabase</td><td align="left">只在admin数据库中可用, 赋予用户所有数据库的dbAdmin权限</td></tr><tr><td align="left">root</td><td align="left">只在admin数据库中可用, 超级账号,超级权限</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登陆</span></span><br><span class="line">db.auth(<span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>)</span><br><span class="line"><span class="comment"># 查看用户</span></span><br><span class="line">show <span class="built_in">users</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;安装配置mongodb&quot;&gt;&lt;a href=&quot;#安装配置mongodb&quot; class=&quot;headerlink&quot; title=&quot;安装配置mongodb&quot;&gt;&lt;/a&gt;安装配置mongodb&lt;/h2&gt;&lt;p&gt;centos7.x&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 下载&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-5.0.3-rc0.tgz /opt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 解压&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tar -zxvf mongodb-linux-x86_64-rhel70-5.0.3-rc0.tgz -C  /usr/local&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 重命名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;mv&lt;/span&gt; mongodb-linux-x86_64-rhel70-5.0.3-rc0 mongodb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="NoSQL" scheme="http://example.com/categories/NoSQL/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="NoSQL" scheme="http://example.com/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>FastDFS</title>
    <link href="http://example.com/2021/06/12/FastDFS/"/>
    <id>http://example.com/2021/06/12/FastDFS/</id>
    <published>2021-06-12T01:12:05.000Z</published>
    <updated>2021-06-12T01:12:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FastDFS"><a href="#FastDFS" class="headerlink" title="FastDFS"></a>FastDFS</h1><p><a href="https://github.com/happyfish100/fastdfs/wiki">安装教程</a></p><table><thead><tr><th>centos</th><th>7.x</th></tr></thead><tbody><tr><td>libfastcommon</td><td>FastDFS分离出的一些公用函数包</td></tr><tr><td>FastDFS</td><td>FastDFS本体</td></tr><tr><td>fastdfs-nginx-module</td><td>FastDFS和nginx的关联模块</td></tr><tr><td>nginx</td><td>nginx1.15.4</td></tr></tbody></table><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译环境</span></span><br><span class="line">yum install git gcc gcc-c++ make automake autoconf libtool pcre pcre-devel zlib zlib-devel openssl-devel wget vim -y</span><br></pre></td></tr></table></figure><p>libfastcommon-1.0.42.tar.gz</p><p>fastdfs-nginx-module-1.22.tar.gz</p><p>fastdfs-6.04.tar.gz</p><p>安装包放在&#x2F;opt目录下</p><p>全部解压到&#x2F;usr&#x2F;local&#x2F;dfs目录中</p><h3 id="安装libfastcommon"><a href="#安装libfastcommon" class="headerlink" title="安装libfastcommon"></a>安装libfastcommon</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> libfastcommon-1.0.42/</span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">./make.sh &amp;&amp; ./make.sh install</span><br></pre></td></tr></table></figure><h3 id="安装FastDFS"><a href="#安装FastDFS" class="headerlink" title="安装FastDFS"></a>安装FastDFS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> fastdfs-6.04/</span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">./make.sh &amp;&amp; ./make.sh install</span><br><span class="line"><span class="comment"># 将conf目录下所有配置文复制(移动)到/etc/fdfs/</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改tracker.conf配置文件</span></span><br><span class="line"><span class="comment">#####################################</span></span><br><span class="line"><span class="comment"># 存储日志和数据的根目录</span></span><br><span class="line">base_path =/usr/local/fastdfs/tracker</span><br><span class="line"><span class="comment">#####################################</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动tracker服务</span></span><br><span class="line">/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改storage.conf配置文件</span></span><br><span class="line"><span class="comment">#####################################</span></span><br><span class="line">group_name=upload</span><br><span class="line"><span class="comment"># 存储日志和数据的根目录</span></span><br><span class="line">base_path=/usr/local/fastdfs/storage</span><br><span class="line">store_path0=/usr/local/fastdfs/storage</span><br><span class="line">tracker_server=192.168.0.105:22122</span><br><span class="line"><span class="comment"># http访问文件的端口 和nginx端口号保持一致</span></span><br><span class="line">http.server_port=8888</span><br><span class="line"><span class="comment">#####################################</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动storage服务</span></span><br><span class="line">/usr/bin/fdfs_storaged /etc/fdfs/storage.conf</span><br></pre></td></tr></table></figure><h2 id="安装fastdfs-nginx-module"><a href="#安装fastdfs-nginx-module" class="headerlink" title="安装fastdfs-nginx-module"></a>安装fastdfs-nginx-module</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/local/dfs/fastdfs-nginx-module-1.22/src/mod_fastdfs.conf /etc/fdfs</span><br></pre></td></tr></table></figure><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加fastdfs-nginx-module模块</span></span><br><span class="line">./configure --add-module=/usr/local/dfs/fastdfs-nginx-module-1.22/src/</span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改mod_fastdfs.conf配置文件</span></span><br><span class="line"><span class="comment">#####################################</span></span><br><span class="line"><span class="comment"># the base path to store log files</span></span><br><span class="line">base_path=/usr/local/fastdfs/storage/tmp</span><br><span class="line">tracker_server=192.168.0.105:22122</span><br><span class="line"><span class="comment"># the group name of the local storage server</span></span><br><span class="line">group_name=upload</span><br><span class="line"><span class="comment"># url 是否包含组名(upload)</span></span><br><span class="line">url_have_group_name = <span class="literal">true</span></span><br><span class="line"><span class="comment"># the paths must be exist</span></span><br><span class="line"><span class="comment"># must same as storage.conf</span></span><br><span class="line">store_path0=/usr/local/fastdfs/storage</span><br><span class="line"><span class="comment">#####################################</span></span><br></pre></td></tr></table></figure><h2 id="配置nginx访问"><a href="#配置nginx访问" class="headerlink" title="配置nginx访问"></a>配置nginx访问</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       8888;    <span class="comment">## 该端口为storage.conf中的http.server_port相同</span></span><br><span class="line">    server_name  localhost;</span><br><span class="line">    location upload/M00 &#123;</span><br><span class="line">        ngx_fastdfs_module;</span><br><span class="line">    &#125;</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">    root   html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;FastDFS&quot;&gt;&lt;a href=&quot;#FastDFS&quot; class=&quot;headerlink&quot; title=&quot;FastDFS&quot;&gt;&lt;/a&gt;FastDFS&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/happyfish100/fastdfs/wiki&quot;&gt;安装教程&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;centos&lt;/th&gt;
&lt;th&gt;7.x&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;libfastcommon&lt;/td&gt;
&lt;td&gt;FastDFS分离出的一些公用函数包&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FastDFS&lt;/td&gt;
&lt;td&gt;FastDFS本体&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fastdfs-nginx-module&lt;/td&gt;
&lt;td&gt;FastDFS和nginx的关联模块&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nginx&lt;/td&gt;
&lt;td&gt;nginx1.15.4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>MySQL主从复制</title>
    <link href="http://example.com/2020/08/19/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://example.com/2020/08/19/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</id>
    <published>2020-08-19T10:46:05.000Z</published>
    <updated>2022-02-17T10:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="MySQL主从复制"><a href="#MySQL主从复制" class="headerlink" title="MySQL主从复制"></a>MySQL主从复制</h1><h2 id="主机-window-修改my-ini配置文件-当window作为主机"><a href="#主机-window-修改my-ini配置文件-当window作为主机" class="headerlink" title="主机(window)修改my.ini配置文件 (当window作为主机)"></a>主机(window)修改my.ini配置文件 (当window作为主机)</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The TCP/IP Port the MySQL Server will listen on</span></span><br><span class="line"><span class="attr">port</span>=<span class="string">3306</span></span><br><span class="line"><span class="comment"># 主服务器唯一ID</span></span><br><span class="line"><span class="attr">server-id</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># 启用二进制日志</span></span><br><span class="line"><span class="attr">log-bin</span>=<span class="string">&quot;E:\mysql\log\mysql-bin&quot;</span></span><br><span class="line"><span class="comment"># Error Logging.</span></span><br><span class="line"><span class="attr">log-error</span>=<span class="string">&quot;E:\mysql\error\mysql-err&quot;</span></span><br><span class="line"><span class="comment"># 主机可读可写</span></span><br><span class="line"><span class="attr">read-only</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># 设置不需要复制的数据库</span></span><br><span class="line"><span class="attr">binlog-ignore-db</span>=<span class="string">mysql</span></span><br><span class="line"><span class="comment"># 设置需要复制的数据库</span></span><br><span class="line"><span class="attr">binlog-do-db</span>=<span class="string">xxx</span></span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="主机-centos-修改my-cnf配置文件-当centos作为主机"><a href="#主机-centos-修改my-cnf配置文件-当centos作为主机" class="headerlink" title="主机(centos)修改my.cnf配置文件(当centos作为主机)"></a>主机(centos)修改my.cnf配置文件(当centos作为主机)</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">vim</span> <span class="string">/etc/my.cnf</span></span><br><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="comment"># 开启二进制日志</span></span><br><span class="line"><span class="attr">log-bin</span>=<span class="string">master-bin</span></span><br><span class="line"><span class="comment"># 设置server-id</span></span><br><span class="line"><span class="attr">server-id</span>=<span class="string">1 </span></span><br></pre></td></tr></table></figure><h2 id="从机-centos-修改my-cnf配置文件"><a href="#从机-centos-修改my-cnf配置文件" class="headerlink" title="从机(centos)修改my.cnf配置文件"></a>从机(centos)修改my.cnf配置文件</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">vim</span> <span class="string">/etc/my.cnf</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Linux默认开启二进制日志文件 /var/lib/mysql/binlog</span></span><br><span class="line"><span class="attr">Binary</span> <span class="string">logging captures changes between backups and is enabled by</span></span><br><span class="line"><span class="attr">default.</span> <span class="string">It&#x27;s default setting is log_bin=binlog</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="comment"># 启用从服务器唯一ID</span></span><br><span class="line"><span class="attr">server-id</span>=<span class="string">2</span></span><br><span class="line"><span class="comment"># 开启中继日志</span></span><br><span class="line"><span class="attr">relay-log</span>=<span class="string">mysql-relay</span></span><br><span class="line"><span class="comment"># 开启二进制日志</span></span><br><span class="line"><span class="attr">log-bin</span>=<span class="string">slave-bi</span></span><br></pre></td></tr></table></figure><h2 id="基于docker搭建从机"><a href="#基于docker搭建从机" class="headerlink" title="基于docker搭建从机"></a>基于docker搭建从机</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --name MYSQL   </span><br><span class="line">    -v <span class="variable">$PWD</span>/conf:/etc/mysql/my.cnf   <span class="comment"># $PWD代表当前路径</span></span><br><span class="line">    -v <span class="variable">$PWD</span>/logs:/logs      <span class="comment"># -v 挂载</span></span><br><span class="line">    -v <span class="variable">$PWD</span>/data:/var/lib/mysql </span><br><span class="line">    -e MYSQL_ROOT_PASSWORD=123456    <span class="comment"># 初始化msql密码</span></span><br><span class="line">    -d -i -p 3307:3306 mysql         <span class="comment"># 后台启动 linux下3307端口映射docker容器中mysql默认的3306端口</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入mysql容器中</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql容器ID或名称 /bin/bash   </span><br><span class="line"><span class="comment"># 在docker容器内部安装vim</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install vim</span><br><span class="line"><span class="comment"># 或者可以直接在容器外部挂载文件中修改</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 容器内部修改配置文件</span></span><br><span class="line">vim /etc/mysql/my.cof</span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 开启二进制日志</span></span><br><span class="line">log-bin=slave-bin</span><br><span class="line"><span class="comment"># 设置server-id</span></span><br><span class="line">server-id=2</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重启docker容器</span></span><br><span class="line">docker restart 容器ID</span><br></pre></td></tr></table></figure><h2 id="主机和从机重启后台mysql服务"><a href="#主机和从机重启后台mysql服务" class="headerlink" title="主机和从机重启后台mysql服务"></a>主机和从机重启后台mysql服务</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">net</span> <span class="string">stop mysql80;</span></span><br><span class="line"><span class="attr">net</span> <span class="string">start mysql80;</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">systemctl</span> <span class="string">restart mysqld;</span></span><br></pre></td></tr></table></figure><h2 id="主机和从机都关闭防火墙"><a href="#主机和从机都关闭防火墙" class="headerlink" title="主机和从机都关闭防火墙"></a>主机和从机都关闭防火墙</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">systemctl</span> <span class="string">stop firewalld;</span></span><br></pre></td></tr></table></figure><h2 id="在Window主机上建立账户并授权slave"><a href="#在Window主机上建立账户并授权slave" class="headerlink" title="在Window主机上建立账户并授权slave"></a>在Window主机上建立账户并授权slave</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># mysql8之前的写法</span><br><span class="line">GRANT REPLICATION SLAVE ON *.*  TO &#x27;从库主机用户名&#x27;@&#x27;从库主机IP&#x27; IDENTIFIED BY &#x27;从库主机密码&#x27;;</span><br><span class="line"># mysql8之后的写法(必须先创建用户再s)</span><br><span class="line"># 创建用户(在master上创建只允许slave主机连接的账户)</span><br><span class="line">CREATE USER &#x27;slave&#x27;@&#x27;slave的ip地址&#x27; IDENTIFIED BY &#x27;slave的密码&#x27;;</span><br><span class="line"># 分配权限</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#x27;slave&#x27;@&#x27;slave的ip地址&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 刷新权限</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看主库状态</span><br><span class="line">show master status;</span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">+------------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line"><span class="attr">|</span> <span class="string">File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span></span><br><span class="line"><span class="attr">+------------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line"><span class="attr">|</span> <span class="string">mysql-bin.000001 |      155 |              | mysql            |                   |</span></span><br><span class="line"><span class="attr">+------------------+----------+--------------+------------------+-------------------+</span></span><br></pre></td></tr></table></figure><h2 id="在Linux从机上配置需要复制的主机"><a href="#在Linux从机上配置需要复制的主机" class="headerlink" title="在Linux从机上配置需要复制的主机"></a>在Linux从机上配置需要复制的主机</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># mysql命令行</span><br><span class="line">CHANGE MASTER TO MASTER_HOST = &#x27;主库主机IP&#x27;,</span><br><span class="line">MASTER_USER = &#x27;slave&#x27;,</span><br><span class="line"># master上slave用户的密码</span><br><span class="line">MASTER_PASSWORD = &#x27;slave的密码&#x27;,</span><br><span class="line"># File 加引号</span><br><span class="line">MASTER_LOG_FILE = &#x27;mysql-bin.000001&#x27;,</span><br><span class="line"># Position 不加引号</span><br><span class="line">MASTER_LOG_POS = 155;</span><br><span class="line">CHANGE MASTER TO MASTER_HOST = &#x27;120.27.195.153&#x27;, MASTER_USER = &#x27;slave&#x27;,MASTER_PASSWORD = &#x27;990712&#x27;, MASTER_LOG_FILE = &#x27;master-bin.000010&#x27;, MASTER_LOG_POS = 1067;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 启动从服务器复制功能</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看从库状态</span><br><span class="line">show slave status \G;</span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"> # 主从配置成功</span></span><br><span class="line"><span class="attr">Slave_IO_Running</span>: <span class="string">Yes</span></span><br><span class="line"><span class="attr">Slave_SQL_Running</span>: <span class="string">Yes</span></span><br><span class="line"><span class="comment"># 若出现以下错误: Authentication plugin &#x27;caching_sha2_password&#x27; reported error: Authentication requires secure connection.</span></span><br><span class="line"><span class="attr">ALTER</span> <span class="string">USER &#x27;slave&#x27;@&#x27;salve的ip&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;slave的密码&#x27;;</span></span><br><span class="line"><span class="attr">(新用户会默认使用新的</span> <span class="string">caching_sha2_password 加密方式, 客户端不支持新的加密方式, 修改用户的密码和加密方式)</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看中继日志是否开启</span><br><span class="line">show global variables like &#x27;%log%&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看节点的server id</span><br><span class="line">show global variables like &#x27;%server%&#x27;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;MySQL主从复制&quot;&gt;&lt;a href=&quot;#MySQL主从复制&quot; class=&quot;headerlink&quot; title=&quot;MySQL主从复制&quot;&gt;&lt;/a&gt;MySQL主从复制&lt;/h1&gt;&lt;h2 id=&quot;主机-window-修改my-ini配置文件-当window作为主机&quot;&gt;&lt;a href=&quot;#主机-window-修改my-ini配置文件-当window作为主机&quot; class=&quot;headerlink&quot; title=&quot;主机(window)修改my.ini配置文件 (当window作为主机)&quot;&gt;&lt;/a&gt;主机(window)修改my.ini配置文件 (当window作为主机)&lt;/h2&gt;&lt;figure class=&quot;highlight properties&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# The TCP/IP Port the MySQL Server will listen on&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;port&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;3306&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 主服务器唯一ID&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;server-id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 启用二进制日志&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;log-bin&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;E:\mysql\log\mysql-bin&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Error Logging.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;log-error&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;E:\mysql\error\mysql-err&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 主机可读可写&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;read-only&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 设置不需要复制的数据库&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;binlog-ignore-db&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;mysql&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 设置需要复制的数据库&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;binlog-do-db&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;xxx&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>心灵</title>
    <link href="http://example.com/2020/08/19/article/"/>
    <id>http://example.com/2020/08/19/article/</id>
    <published>2020-08-19T10:46:05.000Z</published>
    <updated>2022-02-17T10:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="种一棵树最好的时间是十年前-其次是现在"><a href="#种一棵树最好的时间是十年前-其次是现在" class="headerlink" title="种一棵树最好的时间是十年前,其次是现在"></a>种一棵树最好的时间是十年前,其次是现在</h3><p>非洲经济学家Dambisa Moyo的《dead aid》结束语</p><p>只要你兴趣还在,可以一直做,什么时候都不会晚;</p><span id="more"></span><p>种一棵树最好的时间是十年前,其次是现在。只要你心里有信念,没有时间的差距,什么时候开始都可以。</p><h3 id="哪里会有人喜欢孤独-不过是不喜欢失望罢了。——村上春树《挪威的森林》"><a href="#哪里会有人喜欢孤独-不过是不喜欢失望罢了。——村上春树《挪威的森林》" class="headerlink" title="哪里会有人喜欢孤独,不过是不喜欢失望罢了。——村上春树《挪威的森林》"></a>哪里会有人喜欢孤独,不过是不喜欢失望罢了。<strong>——</strong>村上春树《挪威的森林》</h3><h3 id="我们是一群没有终点-找不到归宿的鹰-我们只能够留下在捕猎中殷勤的身影-而无法着落-无法驻停-于是我们大多数的时间里-只能够默默地看着有些人的到来和离开-看着这个熟悉而陌生世界的悲欢离合-能够覆手为雨翻手作云的手掌却在这一刻柔弱无力-——文理双修"><a href="#我们是一群没有终点-找不到归宿的鹰-我们只能够留下在捕猎中殷勤的身影-而无法着落-无法驻停-于是我们大多数的时间里-只能够默默地看着有些人的到来和离开-看着这个熟悉而陌生世界的悲欢离合-能够覆手为雨翻手作云的手掌却在这一刻柔弱无力-——文理双修" class="headerlink" title="我们是一群没有终点,找不到归宿的鹰,我们只能够留下在捕猎中殷勤的身影,而无法着落,无法驻停,于是我们大多数的时间里,只能够默默地看着有些人的到来和离开,看着这个熟悉而陌生世界的悲欢离合,能够覆手为雨翻手作云的手掌却在这一刻柔弱无力     ——文理双修"></a>我们是一群没有终点,找不到归宿的鹰,我们只能够留下在捕猎中殷勤的身影,而无法着落,无法驻停,于是我们大多数的时间里,只能够默默地看着有些人的到来和离开,看着这个熟悉而陌生世界的悲欢离合,能够覆手为雨翻手作云的手掌却在这一刻柔弱无力     ——文理双修</h3><p>未完待续…</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;种一棵树最好的时间是十年前-其次是现在&quot;&gt;&lt;a href=&quot;#种一棵树最好的时间是十年前-其次是现在&quot; class=&quot;headerlink&quot; title=&quot;种一棵树最好的时间是十年前,其次是现在&quot;&gt;&lt;/a&gt;种一棵树最好的时间是十年前,其次是现在&lt;/h3&gt;&lt;p&gt;非洲经济学家Dambisa Moyo的《dead aid》结束语&lt;/p&gt;
&lt;p&gt;只要你兴趣还在,可以一直做,什么时候都不会晚;&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>redis持久化</title>
    <link href="http://example.com/2020/07/12/redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://example.com/2020/07/12/redis%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2020-07-12T01:21:23.000Z</published>
    <updated>2022-02-14T02:06:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>[TOC]</p><h2 id="redis-persistence"><a href="#redis-persistence" class="headerlink" title="redis persistence"></a>redis persistence</h2><p>Redis 的持久化主要有两大机制, 即 AOF (Append Only File) 日志和 RDB 快照</p><h3 id="RDB-Redis-Database"><a href="#RDB-Redis-Database" class="headerlink" title="RDB(Redis Database)"></a>RDB(Redis Database)</h3><p>内存快照, 就是指内存中的数据在某一个时刻的状态记录</p><p>在指定的时间间隔内将内存中的数据集快照写入磁盘, 即快照; 数据恢复时直接将快照文件读入内存中</p><span id="more"></span><p>给哪些内存数据做快照?</p><p>为了提供所有数据的可靠性保证, 它执行的是全量快照</p><p>Redis 提供了两个命令来生成 RDB 文件, 分别是 save 和 bgsave</p><ul><li>save: 在主线程中执行, 会导致阻塞</li><li>bgsave: 创建一个子进程, 专门用于写入 RDB 文件, 避免了主线程的阻塞, 这也是 Redis RDB 文件生成的默认配置</li></ul><p>快照时数据能修改吗?</p><p>为了保证快照完整性, 主线程只能处理读操作, 因为不能修改正在执行快照的数据, 为了保证Redis 的性能 Redis 就会借助操作系统提供的写时复制技术(Copy-On-Write, COW), 在执行快照的同时, 正常处理写操作 bgsave 子进程是由主线程 fork 生成的, 可以共享主线程的所有内存数据; bgsave 子进程运行后, 开始读取主线程的内存数据, 并把它们写入 RDB 文件</p><p>虽然 bgsave 执行时不阻塞主线程, 但是, 如果频繁地执行全量快照, 也会带来两方面的开销</p><ul><li>频繁将全量数据写入磁盘, 会给磁盘带来很大压力, 多个快照竞争有限的磁盘带宽, 前一个快照还没有做完, 后一个又开始做了, 容易造成恶性循环</li><li>bgsave 子进程需要通过 fork 操作从主线程创建出来; 虽然, 子进程在创建后不会再阻塞主线程, 但是, fork 这个创建过程本身会阻塞主线程, 而且主线程的内存越大, 阻塞时间越长; 如果频繁 fork 出 bgsave 子进程, 这就会频繁阻塞主线程了(所以, 在 Redis 中如果有一个 bgsave 在运行, 就不会再启动第二个 bgsave 子进程)</li></ul><p>解决: 增量快照, 就是指, 做了一次全量快照后, 后续的快照只对修改的数据进行快照记录, 这样可以避免每次全量快照的开销</p><p>比较AOF: 虽然跟 AOF 相比, 快照的恢复速度快(只需要把 RDB 文件直接读入内存, 这就避免了 AOF 需要顺序、逐一重新执行操作命令带来的低效性能问题), 但是, 快照的频率不好把握, 如果频率太低, 两次快照间一旦宕机, 就可能有比较多的数据丢失, 如果频率太高, 又会产生额外开销</p><p>混合使用 AOF 日志和内存快照: 内存快照以一定的频率执行, 在两次快照之间, 使用 AOF 日志记录这期间的所有命令操作</p><p>在两次快照之间进行的数据修改操作, 用 AOF 日志记录, 等到第二次做全量快照时, 就可以清空 AOF 日志, 因为此时的修改都已经记录到快照中了, 恢复时就不再用日志了</p><h4 id="SNAPSHOTTING快照"><a href="#SNAPSHOTTING快照" class="headerlink" title="SNAPSHOTTING快照"></a>SNAPSHOTTING快照</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dbfilename dump.rdb   # 默认持久化到dump.rdb文件中 </span><br><span class="line">save 900 1            # 15分钟内保存一次即修改一次</span><br><span class="line">save 300 10           # 5分钟内保存十次即修改十次</span><br><span class="line">save 60 10000         # 1分钟内保存一万次即修改一万次</span><br><span class="line">stop-writes-on-bgsave-error yes  # 保存出错停止写入</span><br><span class="line">rdbcompression yes    # 数据压缩</span><br><span class="line">rdbchecksum yes       # 数据校验</span><br><span class="line">dir ./                </span><br><span class="line">config get dir        # 获取redis启动路径</span><br><span class="line">save                  # 手动备份</span><br></pre></td></tr></table></figure><p>RDB适合大规模的数据恢复, 而且对数据的完整性和一致性要求不高</p><h3 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a>AOF(Append Only File)</h3><p>数据库的写前日志(Write Ahead Log, WAL), 也就是说, 在实际写数据前, 先把修改的数据记到日志文件中(redo log和binlog是在commit之前写的日志),<br>以便故障时进行恢复; 不过, AOF 日志正好相反, 它是写后日志, “写后”的意思是 Redis 是先执行命令, 把数据写入内存, 然后才记录日志</p><p>传统数据库的日志, 例如 redo log(重做日志), 记录的是修改后的数据, 而 AOF 里记录的是 Redis 收到的每一条命令, 这些命令是以文本形式保存</p><p>AOF 为什么要先执行命令再记日志?</p><p>为了避免额外的检查开销, Redis 在向 AOF 里面记录日志的时候, 并不会先去对这些命令进行语法检查; 所以, 如果先记日志再执行命令的话, 日志中就有可能记录了错误的命令, Redis 在使用日志恢复数据时, 就可能会出错</p><p>Redis 使用写后日志这一方式的一大好处是, 可以避免出现记录错误命令的情况; 除此之外, AOF 还有一个好处: 它是在命令执行后才记录日志, 所以不会阻塞当前的写操作</p><p>AOF 两个潜在的风险:</p><p>如果刚执行完一个命令, 还没有来得及记日志就宕机了, 那么这个命令和相应的数据就有丢失的风险</p><p>AOF 虽然避免了对当前命令的阻塞, 但可能会给下一个操作带来阻塞风险; 这是因为, AOF 日志也是在主线程中执行的, 如果在把日志文件写入磁盘时, 磁盘写压力大, 就会导致写盘很慢, 进而导致后续的操作也无法执行了</p><p>以日志的形式记录每个写操作, 将Redis所有的写指令记录下来(不记录读操作), 只许追加文件不许修改文件, 相当于MySQL的脚本文件, 当Redis启动时就会加载appendonly.aof文件将写指令重新执行一遍来恢复数据</p><p>AOF 三种写回策略</p><ul><li><p>always, 同步写回: 每个写命令执行完, 立马同步地将日志写回磁盘</p></li><li><p>everysec, 每秒写回: 每个写命令执行完, 只是先把日志写到 AOF 文件的内存缓冲区, 每隔一秒把缓冲区中的内容写入磁盘</p></li><li><p>no, 操作系统控制的写回: 每个写命令执行完, 只是先把日志写到 AOF 文件的内存缓冲区, 由操作系统决定何时将缓冲区内容写回磁盘</p></li></ul><p><img src="https://cdn.qingweico.cn/blog/72f547f18dbac788c7d11yy167d7ebf8.jpg" alt="img"></p><p>AOF 重写机制</p><p>产生原因:</p><p>AOF 是以文件的形式在记录接收到的所有写命令, 随着接收的写命令越来越多, AOF 文件会越来越大, AOF 文件过大会带来性能问题</p><ul><li>文件系统本身对文件大小有限制, 无法保存过大的文件</li><li>如果文件太大, 之后再往里面追加命令记录的话, 效率也会变低</li><li>如果日志文件太大, 整个恢复过程就会非常缓慢</li></ul><p>AOF 重写机制就是在重写时, Redis 根据数据库的现状创建一个新的 AOF 文件, 也就是说, 读取数据库中的所有键值对, 然后对每一个键值对用一条命令记录它的写入</p><p>旧日志文件中的多条命令, 在重写后的新日志中变成了一条命令(AOF 文件是以追加的方式, 逐一记录接收到的写命令的; 当一个键值对被多条写命令反复修改时, AOF 文件会记录相应的多条命令; 但是, 在重写的时候, 是根据这个键值对当前的最新状态, 为它生成对应的写入命令)</p><p>注意, AOF的重写不是根据原有的AOF去做, 而是根据当前内存数据库的数据, 去生成一条条命令进行保存</p><p>和 AOF 日志由主线程写回不同, 重写过程是由后台子进程 bgrewriteaof 来完成的, 这也是为了避免阻塞主线程, 导致数据库性能下降</p><h4 id="APPEND-ONLY-MODE"><a href="#APPEND-ONLY-MODE" class="headerlink" title="APPEND ONLY MODE"></a>APPEND ONLY MODE</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendonly no  # 默认关闭 yes即代表打开aof的持久化</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-check-aof --fix appendonly.aof <span class="comment"># 修复appendonly.aof文件</span></span><br></pre></td></tr></table></figure><p>dump.rdb文件和appendonly.aof文件可以同时存在,当二者同时存在时优先加载appendonly.aof文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">appendfsync always <span class="comment"># 同步持久化 每当有数据发生变化时就会记录到磁盘 数据完整性好但是性能差</span></span></span><br><span class="line">appendfsync everysec # 出厂默认 异步操作 每秒记录数据 1s内宕机 数据丢失</span><br><span class="line"><span class="meta"># </span><span class="language-bash">appendfsync no</span></span><br></pre></td></tr></table></figure><p>关于 AOF 和 RDB 的选择问题</p><ul><li>数据不能丢失时, 内存快照和 AOF 的混合使用是一个很好的选择;</li><li>如果允许分钟级别的数据丢失, 可以只使用 RDB;</li><li>如果只用 AOF, 优先使用 everysec 的配置选项, 因为它在可靠性和性能之间取了一个平衡</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;redis-persistence&quot;&gt;&lt;a href=&quot;#redis-persistence&quot; class=&quot;headerlink&quot; title=&quot;redis persistence&quot;&gt;&lt;/a&gt;redis persistence&lt;/h2&gt;&lt;p&gt;Redis 的持久化主要有两大机制, 即 AOF (Append Only File) 日志和 RDB 快照&lt;/p&gt;
&lt;h3 id=&quot;RDB-Redis-Database&quot;&gt;&lt;a href=&quot;#RDB-Redis-Database&quot; class=&quot;headerlink&quot; title=&quot;RDB(Redis Database)&quot;&gt;&lt;/a&gt;RDB(Redis Database)&lt;/h3&gt;&lt;p&gt;内存快照, 就是指内存中的数据在某一个时刻的状态记录&lt;/p&gt;
&lt;p&gt;在指定的时间间隔内将内存中的数据集快照写入磁盘, 即快照; 数据恢复时直接将快照文件读入内存中&lt;/p&gt;</summary>
    
    
    
    <category term="NOSQL" scheme="http://example.com/categories/NOSQL/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="NOSQL" scheme="http://example.com/tags/NOSQL/"/>
    
  </entry>
  
  <entry>
    <title>redis数据类型</title>
    <link href="http://example.com/2020/07/12/redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/2020/07/12/redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-07-12T01:21:23.000Z</published>
    <updated>2020-07-12T01:21:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><p>[TOC]</p><h2 id="redis基本知识"><a href="#redis基本知识" class="headerlink" title="redis基本知识"></a>redis基本知识</h2><p>redis:  一种分布式的内存数据库缓存</p><p>NoSQL:  Not Only SQL “不仅仅是SQL” 泛指非关系型数据库</p><p>单进程</p><p>redis默认16个库,下表从开始,初始化使用0号库</p><p>大数据时代的三V :  Volume(海量) Variety(多样) Velocity(实时)</p><p>互联网三高: 高性能 高可用 高扩展 </p><p>高性能: 响应(低延迟) 吞吐(高吞吐量 高并发)</p><p>TPS QPS</p><p>amdahl定律</p><span id="more"></span><h3 id="RDBMS和NoSQL的区别"><a href="#RDBMS和NoSQL的区别" class="headerlink" title="RDBMS和NoSQL的区别"></a>RDBMS和NoSQL的区别</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">RDBMS</span>: <span class="string">高度组织化结构化的数据</span></span><br><span class="line">      <span class="attr">结构化查询语言(SQL)</span></span><br><span class="line">      <span class="attr">数据操纵语言,数据定义语言</span></span><br><span class="line">      <span class="attr">严格的一致性</span></span><br><span class="line">      <span class="attr">基础事务</span></span><br><span class="line"><span class="attr">NoSQL</span>: <span class="string">代表的不仅仅是SQL</span></span><br><span class="line">      <span class="attr">没有声明性查询语言</span></span><br><span class="line">      <span class="attr">没有预定义的模式</span></span><br><span class="line">      <span class="attr">键值存储</span> <span class="string">文档存储 列存储 图形存储</span></span><br><span class="line">      <span class="attr">最终一致性而非ACID属性</span></span><br><span class="line">      <span class="attr">非结构化和不可预知的数据</span></span><br><span class="line">      <span class="attr">CAP属性</span></span><br><span class="line">      <span class="attr">高性能</span> <span class="string">高可用 可伸缩性  </span></span><br></pre></td></tr></table></figure><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>不同的多台服务器上面部署不同的服务模块(工程),他们之间通过RPC(Remote Procedure Call  远程过程调用)&#x2F;RMI之间通信和调用,对外提供服和组内协作</p><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>不同的多台服务器上面部署相同的服务模块,通过分布式调度软件进行统一的调度,对外提供访问和服务</p><h3 id="分布式数据库中的CAP和BASE"><a href="#分布式数据库中的CAP和BASE" class="headerlink" title="分布式数据库中的CAP和BASE"></a>分布式数据库中的CAP和BASE</h3><h4 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h4><ul><li>C: Consistency（强一致性）</li><li>A: Availability（可用性）</li><li>P: Partition tolerance（分区容错性）</li></ul><h4 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h4><ul><li>基本可用（Basically Available）</li><li>软状态（Soft State）</li><li>最终一致（Eventually Consistent）</li></ul><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> k1 v1</span><br><span class="line"><span class="built_in">set</span> k2 v2       <span class="comment"># 设置键值</span></span><br><span class="line">get k1</span><br><span class="line">get k2          <span class="comment"># 获取键值</span></span><br><span class="line"><span class="built_in">set</span> k1 value1   <span class="comment"># 会覆盖当前的值</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move k1 2;      <span class="comment"># 将键k1的值移动到2号库</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists k1       <span class="comment"># 判断某个键是否存在</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expire k1 10    <span class="comment"># 设定键k1过期时间(s)</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ttl k1          <span class="comment"># 查看键k1剩余过期时间  -1代表永不过期 -2代表已过期 过期即从当前库中移出该键值对</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> k          <span class="comment"># 查看k的数据类型</span></span><br></pre></td></tr></table></figure><p><code>dbsize</code> 查看当前数据库的key数量</p><p><code>flushdb</code> 清空当前库</p><p><code>flushall</code> 清空所有的库</p><p><code>keys *</code> 查看当前库的所有的键</p><p><code>keys k?</code> 查看当前库中以<code>k</code> 开头的键</p><p><code>select index(0~15)</code> 选择库</p><h2 id="Redis5种数据类型"><a href="#Redis5种数据类型" class="headerlink" title="Redis5种数据类型"></a>Redis5种数据类型</h2><h3 id="String-字符串-（一key单value）"><a href="#String-字符串-（一key单value）" class="headerlink" title="String(字符串)（一key单value）"></a>String(字符串)（一key单value）</h3><p>string是redis最基本的类型,一个key对应一个value string是二进制安全的,redis的string可以包含任何数据,一个redis的string的value最多可以是512M</p><p>string类型的内部编码有三种</p><ul><li>int 储存八个字节的长整型</li><li>embstr 代表embstr格式的SDS(Simple Dynamic String) 简单动态字符串, 用来储存小于44个字节的字符串, 只分配一次内存空间(因为Redis和SDS是连续的)</li><li>raw:  储存大于44个字节的字符串, 需要分配两次内存空间</li></ul><p>redis中浮点数和大整数怎么存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del k1           <span class="comment"># 删除k1</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">append k1 value  <span class="comment"># 向k1后面追加value</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strlen k1        <span class="comment"># 查看k1的长度</span></span><br></pre></td></tr></table></figure><hr><p>k的值一定要为数字类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incr k1          <span class="comment"># 单步增加k1的值</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decr k1          <span class="comment"># 单步递减k1的值</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incrby k1 2      <span class="comment"># 自定义步长增加k1的值</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decrby k1 2      <span class="comment"># 自定义步长递减k1的值</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> k abcdefg;</span><br><span class="line">GETRANGE k 0 3;  <span class="comment"># &quot;abcd&quot;  不会改变原来的值</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SETRANGE k 0 ABCD;</span><br><span class="line">get k;            <span class="comment"># &quot;ABCDefg&quot; 从索引0开始重新设置 会覆盖原来的值</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setex k 10 v;</span><br><span class="line">=&gt;</span><br><span class="line"><span class="built_in">set</span> k v;</span><br><span class="line">expire k 10;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx k 10 v;             <span class="comment"># 设置不存在的键的过期时间,若存在则设置失败</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset k1 v1 k2 v2 k3 v3    <span class="comment"># 一次性设置多个键值对</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget k1 k2 k3             <span class="comment"># 一次性获取多个值</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msetnx k1 v1 k5 v5        <span class="comment"># 若存在已有的键,则设置失败,一个都不会生效</span></span><br></pre></td></tr></table></figure><h3 id="set（集合-（无序且唯一-一key多value）"><a href="#set（集合-（无序且唯一-一key多value）" class="headerlink" title="set（集合) （无序且唯一  一key多value）"></a>set（集合) （无序且唯一  一key多value）</h3><p>实现:  字典</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">smembers <span class="built_in">set</span>              <span class="comment"># 查看集合中所有的元素</span></span><br><span class="line">sadd <span class="built_in">set</span> 1 2 1 2 3 3      <span class="comment"># 会去重,保证元素的唯一性</span></span><br><span class="line">smember <span class="built_in">set</span></span><br><span class="line">    =&gt;</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">sismember <span class="built_in">set</span> 9      <span class="comment"># 判断set是否存在该元素</span></span><br><span class="line">scard <span class="built_in">set</span>            <span class="comment"># 获取set中元素的个数</span></span><br><span class="line">SREM <span class="built_in">set</span> 1           <span class="comment"># 删除set中值为&quot;1&quot;的元素   </span></span><br><span class="line">SRANDMEMBER <span class="built_in">set</span> 5    <span class="comment"># 随机出现5个元素</span></span><br><span class="line">spop <span class="built_in">set</span>             <span class="comment"># 随机出栈一个元素</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smove set1 set2 value //将set1中的value移动到set2中</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sdiff <span class="built_in">set</span> set1  <span class="comment"># 差集</span></span><br><span class="line">sinter <span class="built_in">set</span> set1 <span class="comment"># 交集</span></span><br><span class="line">sunion <span class="built_in">set</span> set1 <span class="comment"># 并集</span></span><br></pre></td></tr></table></figure><h3 id="hash（哈希）（一key多value）"><a href="#hash（哈希）（一key多value）" class="headerlink" title="hash（哈希）（一key多value）"></a>hash（哈希）（一key多value）</h3><p>实现:  哈希表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hset student name <span class="string">&quot;jack&quot;</span>        <span class="comment"># student为键  name 和 &quot;jack&quot; 键值对为值</span></span><br><span class="line">hget student name               <span class="comment"># 获取student中name的值</span></span><br><span class="line">hmset student name <span class="string">&quot;jack age 21&quot;</span><span class="comment"># 一次性插入多个值</span></span><br><span class="line">hmget student name age          <span class="comment"># 一次性获取多个值</span></span><br><span class="line">hgetall student                 <span class="comment"># 获取键中所有的值</span></span><br><span class="line">HDEL student age                <span class="comment"># 删除单个值</span></span><br><span class="line">hlen student                    <span class="comment"># 获取student的value的长度</span></span><br><span class="line">HEXISTS student age             <span class="comment"># 判断student是否存在某一个值</span></span><br><span class="line">HKEYS student                   <span class="comment"># 查询student中所有的键</span></span><br><span class="line">HVALS student                   <span class="comment"># 查询student中所有的键对应的值</span></span><br><span class="line">HINCRBY student age 2           <span class="comment"># 自定义步长增加age的值</span></span><br><span class="line">HINCRBYFLOAT student age 3.0    <span class="comment"># 自定义步长以浮点类型增加</span></span><br><span class="line">HSETNX student number 1         <span class="comment"># 设置student中不存在的键值 若存在则失败</span></span><br></pre></td></tr></table></figure><h3 id="list-列表-字符串链表-一key多value"><a href="#list-列表-字符串链表-一key多value" class="headerlink" title="list (列表) (字符串链表) (一key多value)"></a>list (列表) (字符串链表) (一key多value)</h3><p>结构:  LinkedList</p><p>lrange</p><p>lindex</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Lpush list 1 2 3 4 5 <span class="comment"># 相当于从左边入栈</span></span><br><span class="line">Lrange list 0 -1 </span><br><span class="line">=&gt;</span><br><span class="line">1) <span class="string">&quot;5&quot;</span></span><br><span class="line">2) <span class="string">&quot;4&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;2&quot;</span></span><br><span class="line">5) <span class="string">&quot;1&quot;</span></span><br><span class="line">Lpop list <span class="comment">#  &quot;5&quot;</span></span><br><span class="line">Rpop list <span class="comment">#  &quot;1&quot;    </span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Rpush list 1 2 3 4 5  <span class="comment"># 相当于从右边入栈</span></span><br><span class="line">Lrange list 0 -1</span><br><span class="line">=&gt;</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">5) <span class="string">&quot;5&quot;</span></span><br><span class="line">Lpop list       <span class="comment"># &quot;1&quot;</span></span><br><span class="line">Rpop list       <span class="comment"># &quot;5&quot;</span></span><br><span class="line">Lindex list 2   <span class="comment"># &quot;4&quot; 按照索引从上往下获取元素</span></span><br><span class="line">llen list //3 长度</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LREM list 3 4   <span class="comment"># 删除list中3个4</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lpush list 1 2 3 4 5 6 7 8</span><br><span class="line">LTRIM list 0 5  <span class="comment"># 将索引从0到5(包括5)的元素截取并重新赋值给list</span></span><br><span class="line">LRANGE list 0 -1   </span><br><span class="line">   = &gt;</span><br><span class="line">    1) <span class="string">&quot;8&quot;</span></span><br><span class="line">    2) <span class="string">&quot;7&quot;</span></span><br><span class="line">    3) <span class="string">&quot;6&quot;</span></span><br><span class="line">    4) <span class="string">&quot;5&quot;</span></span><br><span class="line">    5) <span class="string">&quot;4&quot;</span></span><br><span class="line">    6) <span class="string">&quot;3</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">rpush list1 4 5 6 7</span><br><span class="line">rpush list2 1 2 3</span><br><span class="line">rpoplpush list1 list2 <span class="comment"># &quot;7&quot; 将list1的栈底元素弹出压入到list2栈顶上</span></span><br><span class="line">lrange list2 0 -1</span><br><span class="line">    = &gt;</span><br><span class="line">1) <span class="string">&quot;7&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line">3) <span class="string">&quot;2&quot;</span></span><br><span class="line">4) <span class="string">&quot;3&quot;</span></span><br><span class="line">LSET list2 0 9        <span class="comment"># 将索引为0的元素替换为9</span></span><br><span class="line">1) <span class="string">&quot;9&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line">3) <span class="string">&quot;2&quot;</span></span><br><span class="line">4) <span class="string">&quot;3&quot;</span></span><br><span class="line">LINSERT list2  before/after 9 10  <span class="comment"># 在元素&quot;9&quot;的前面（后面）插入元素&quot;10&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Zset（有序集合）-sorted-set"><a href="#Zset（有序集合）-sorted-set" class="headerlink" title="Zset（有序集合）(sorted set)"></a>Zset（有序集合）(sorted set)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">zadd zset 1 v1 2 v2 3 v3</span><br><span class="line">zrange zset 0 -1  <span class="comment"># 正向获取元素</span></span><br><span class="line">    =&gt;</span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;v3&quot;</span></span><br><span class="line">ZREVRANGE zset 0 -1 <span class="comment"># 逆序获取元素</span></span><br><span class="line">    =&gt;</span><br><span class="line">1) <span class="string">&quot;v2&quot;</span></span><br><span class="line">2) <span class="string">&quot;v1&quot;</span></span><br><span class="line">zrange zset 0 -1 withscores <span class="comment"># 正向获取元素带有score</span></span><br><span class="line">    =&gt;</span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line">3) <span class="string">&quot;v2&quot;</span></span><br><span class="line">4) <span class="string">&quot;2&quot;</span></span><br><span class="line">5) <span class="string">&quot;v3&quot;</span></span><br><span class="line">6) <span class="string">&quot;3&quot;</span></span><br><span class="line">ZRANGEBYSCORE zset  2 3 <span class="comment"># 获取元素按指定的score范围</span></span><br><span class="line">    =&gt;</span><br><span class="line">1) <span class="string">&quot;v2&quot;</span></span><br><span class="line">2) <span class="string">&quot;v3&quot;</span></span><br><span class="line">ZRANGEBYSCORE zset  2 (3    <span class="comment"># &quot;(&quot; 不包括</span></span><br><span class="line">    =&gt;</span><br><span class="line">1) <span class="string">&quot;v2&quot;</span></span><br><span class="line">ZRANGEBYSCORE zset  2 3 <span class="built_in">limit</span> 0 1 <span class="comment"># 从结果集的下标0开始,选择一个元素</span></span><br><span class="line">    =&gt;</span><br><span class="line">1) <span class="string">&quot;v2&quot;</span></span><br><span class="line">ZREM zset v3                      <span class="comment"># 删除元素</span></span><br><span class="line">    =&gt;</span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">ZCARD zset       <span class="comment"># 统计zset中元素的个数</span></span><br><span class="line">    =&gt; </span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">ZCOUNT zset 1 2  <span class="comment"># 统计指定范围内的元素的个数</span></span><br><span class="line">    =&gt;</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">ZRANK zset v2    <span class="comment"># 拿到指定值的下标</span></span><br><span class="line">    =&gt;</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">ZSCORE zset v1   <span class="comment"># 获取v1对应的score</span></span><br><span class="line">    =&gt;</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">ZREVRANK zset v2 <span class="comment"># 逆序获得元素的下标</span></span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line">ZREVRANGEBYSCORE zset 2 1 <span class="comment"># 逆序获取元素按照指定的score范围    </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;redis&quot;&gt;&lt;a href=&quot;#redis&quot; class=&quot;headerlink&quot; title=&quot;redis&quot;&gt;&lt;/a&gt;redis&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;redis基本知识&quot;&gt;&lt;a href=&quot;#redis基本知识&quot; class=&quot;headerlink&quot; title=&quot;redis基本知识&quot;&gt;&lt;/a&gt;redis基本知识&lt;/h2&gt;&lt;p&gt;redis:  一种分布式的内存数据库缓存&lt;/p&gt;
&lt;p&gt;NoSQL:  Not Only SQL “不仅仅是SQL” 泛指非关系型数据库&lt;/p&gt;
&lt;p&gt;单进程&lt;/p&gt;
&lt;p&gt;redis默认16个库,下表从开始,初始化使用0号库&lt;/p&gt;
&lt;p&gt;大数据时代的三V :  Volume(海量) Variety(多样) Velocity(实时)&lt;/p&gt;
&lt;p&gt;互联网三高: 高性能 高可用 高扩展 &lt;/p&gt;
&lt;p&gt;高性能: 响应(低延迟) 吞吐(高吞吐量 高并发)&lt;/p&gt;
&lt;p&gt;TPS QPS&lt;/p&gt;
&lt;p&gt;amdahl定律&lt;/p&gt;</summary>
    
    
    
    <category term="NOSQL" scheme="http://example.com/categories/NOSQL/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="NOSQL" scheme="http://example.com/tags/NOSQL/"/>
    
  </entry>
  
  <entry>
    <title>Deep understanding of the Java Virtual Machine(third edition)</title>
    <link href="http://example.com/2020/06/09/Deep-understanding-of-the-Java-Virtual-Machine-third-edition/"/>
    <id>http://example.com/2020/06/09/Deep-understanding-of-the-Java-Virtual-Machine-third-edition/</id>
    <published>2020-06-09T08:21:44.000Z</published>
    <updated>2022-02-17T10:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Deep-understanding-of-the-Java-Virtual-Machine"><a href="#Deep-understanding-of-the-Java-Virtual-Machine" class="headerlink" title="Deep understanding of the Java Virtual Machine"></a>Deep understanding of the Java Virtual Machine</h1><p>[TOC]</p><p><em><img src="https://cdn.qingweico.cn/blog/601773e53ffa7d37b3a530f6.png"></em></p><h2 id="1-类加载器"><a href="#1-类加载器" class="headerlink" title="1 类加载器"></a>1 类加载器</h2><h3 id="1-1-类的加载过程"><a href="#1-1-类的加载过程" class="headerlink" title="1.1 类的加载过程"></a>1.1 类的加载过程</h3><ul><li>加载</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1</span>: <span class="string">通过一个类的全限定名称获取此类的二进制字节流</span></span><br><span class="line"><span class="attr">2</span>: <span class="string">将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</span></span><br><span class="line"><span class="attr">3</span>: <span class="string">在内存中生成一个代表这个类的java.lang.Class对象, 作为方法区这个类的各种数据的访问入口</span></span><br></pre></td></tr></table></figure><ul><li>链接<ul><li>验证<ul><li>文件格式的验证(openjdk&#x2F;hotspot&#x2F;src&#x2F;share&#x2F;vm&#x2F;classfile&#x2F;classFileParser.cpp)</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ul></li><li>准备</li><li>解析</li></ul></li><li>初始化</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">执行类构造器方法&lt;clinit&gt;()</span></span><br><span class="line"><span class="attr">此方法不需要定义,</span> <span class="string">是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来</span></span><br><span class="line"><span class="attr">构造器方法中指令按语句在源文件中出现的顺序执行</span></span><br><span class="line"><span class="attr">&lt;clinit&gt;不同于类的构造器(关联</span>: <span class="string">构造器是虚拟机视角下的&lt;init&gt;())</span></span><br><span class="line"><span class="attr">若该类具有父类,</span> <span class="string">JVM会保证子类的&lt;clinit&gt;()执行前, 父类的&lt;clinit&gt;()已经执行完毕</span></span><br><span class="line"><span class="attr">虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁</span></span><br></pre></td></tr></table></figure><p>对于初始化阶段 《Java虚拟机规划》 严格定义了有且只有六种情况必须对类进行初始化</p><ul><li>遇到 new 、getstatic、putstatic或者invokestatic 这四条字节码指令时</li><li>使用java.lang.reflect包的方法对类型进行反射调用的时候</li><li>当类初始化的时候 如果发现其父类还没有进行初始化的时候 则需要先触发其父类的初始化</li><li>当虚拟机启动时用户需要指定一个要执行的主类 虚拟机首先会初始化这个类(即包含main方法的那个类)</li><li>当使用JDK 7新加入的动态语言支持时 如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic REF_putStatic REF_invokeStatic REF_newInvokeSpecial 四种类型的方法句柄 并且这个方法句柄对应的类没有进行过初始化</li><li>当接口中定义JDK 8中新加入的默认方法时 如果这个接口的实现类发生了初始化 那该接口要在其之前被初始化</li></ul><h3 id="1-2-类加载器的分类"><a href="#1-2-类加载器的分类" class="headerlink" title="1.2 类加载器的分类"></a>1.2 类加载器的分类</h3><ul><li>引导类加载器(Bootstrap Class Loader) : <ul><li>系统类加载器(System(Application) Class Loader)         classpath</li><li>扩展类加载器(Extension Class Loader)                           jre目录下 lib&#x2F;ext</li></ul></li><li>自定义类加载器(User-Defined Class Loader)</li></ul><p><strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器(不包括引导类加载器)</strong></p><p>引导类加载器：使用C&#x2F;C++代码实现, 嵌套在JVM内部</p><p>系统类加载器(AppClassLoader)：程序中通过默认的类加载器</p><p>OSGi模型</p><h3 id="1-3-双亲委派机制"><a href="#1-3-双亲委派机制" class="headerlink" title="1.3 双亲委派机制"></a>1.3 双亲委派机制</h3><p>工作原理:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1&gt;</span>: <span class="string">如果一个类加载器收到了类加载请求, 它并不会自己先去加载, 而是把这个请求委托给父类的加载器去执行</span></span><br><span class="line"><span class="attr">2&gt;</span>: <span class="string">如果父类加载器还存在其父类加载器, 则近一步向上委托, 依次递归, 请求最终到达顶层的启动类加载器</span></span><br><span class="line"><span class="attr">3&gt;</span>: <span class="string">如果父类加载器可以完成类加载任务, 就成功返回, 倘若父类加载器无法完成此加载任务, 子加载器才会尝试自己去加载, 这就是双亲委派机制</span></span><br></pre></td></tr></table></figure><p>在JVM中表示两个class对象是否为同一个类存在的两个必要条件</p><ul><li>类的完整类名必须一致, 包括包名</li><li>加载这个类的ClassLoader(指ClassLoader实例对象)必须相同</li></ul><p>对类加载器的引用：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">JVM必须知道一个类型是由引导类加载器加载的还是由用户类加载器加载的.</span></span><br><span class="line"><span class="attr">如果一个类型是由用户类加载器加载的,</span> <span class="string">那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法去中.</span></span><br><span class="line"><span class="attr">当解析一个类型到另外一个类型的引用的时候,</span> <span class="string">JVM需要保证这两个类型的类加载器是相同的.</span></span><br></pre></td></tr></table></figure><h2 id="2-运行时数据区"><a href="#2-运行时数据区" class="headerlink" title="2 运行时数据区"></a>2 运行时数据区</h2><p>方法区和堆有GC, 虚拟机栈和本地方法区以及程序计数器则没有GC</p><p>方法区和堆为所有线程所共享, 而虚拟机栈和本地方法区以及程序计数器则每个线程各有一份</p><h3 id="2-1-PC寄存器"><a href="#2-1-PC寄存器" class="headerlink" title="2.1 PC寄存器"></a>2.1 PC寄存器</h3><p>程序计数器也叫PC寄存器(Program Counter Register)</p><p>JVM中PC寄存器是对物理寄存器的一种抽象模拟</p><p>程序计数器是唯一一个在JVM中没有规定任何OutOfMemoryError情况的的区域</p><p>PC寄存器的作用：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PC寄存器用来存储指向下一条指令的地址(偏移地址),</span> <span class="string">即将要执行的指令代码, 由执行引擎读取下一条指令.</span></span><br></pre></td></tr></table></figure><p>PC寄存器被设定为线程私有的原因:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">在多线程环境中,</span> <span class="string">一个特定的时间段只会执行其中某一个线程的方法, CPU会不停地做任务切换, 这样必然会导致线程中断和恢复, 为了能够准确地记录各个线程正在执行地当前字节码指令地址, 最好的办法自然是为每一个线程都分配一个PC寄存器, 这样一来各个线程之间便可以进行独立计算, 从而不会出现相互干扰的情况.</span></span><br></pre></td></tr></table></figure><p>CPU时间片即CPU分配给各个程序的时间, 每个线程被分配一个时间段,  称作它的时间片</p><p>如果线程正在执行的是一个Java方法 pc记录的是正在执行的虚拟机字节码指令的地址 如果正在执行的是本地方法 pc的值应该为空</p><h3 id="2-2-虚拟机栈"><a href="#2-2-虚拟机栈" class="headerlink" title="2.2 虚拟机栈"></a>2.2 虚拟机栈</h3><p>由于跨平台的设计, Java的指令都是根据栈来设计的, 因为不同平台CPU架构不同, 所以不能设计为基于寄存器的</p><p>虚拟机栈的 <strong>优点</strong>是: 指令集小, 编译器容易实现 <strong>缺点</strong>是性能下降, 实现同样的功能需要更多的指令</p><p>作用: 主管Java程序的运行, 它保存方法的局部变量、部分结果, 并参与方法的调用和返回</p><p>生命周期: 生命周期和线程一致</p><p>每个线程在创建时都会创建一个虚拟机栈, 其内部保存一个个的栈帧(Stack Frame), 对应着一次次Java方法调用</p><p>栈的特点：</p><ul><li>栈是一种快速有效的分配存储方式, 访问速度仅次于PC寄存器</li><li>JVM直接对虚拟机栈的操作只有两个<ul><li>每个方法执行, 伴随着进栈(入栈、压栈)</li><li>执行结束后的出栈工作</li></ul></li><li>对于栈来说不存在垃圾回收问题(但是存在OOM和SOF问题)</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-Xss1k/1m/1g</span> <span class="string">设置虚拟机栈内存的大小</span></span><br><span class="line"><span class="attr">-Xss1024</span> <span class="string">不加单位默认为字节</span></span><br></pre></td></tr></table></figure><p>栈运行原理:</p><ul><li>不同线程中所包含的栈帧是不允许存在相互引用的, 即不可能在一个栈帧之中引用另外一个线程的帧.</li><li>如果当前方法调用了其他方法, 方法返回之际, 当前栈帧回传会此方法的执行结果给前一个栈帧, 接着, 虚拟机会丢弃当前栈帧, 使得前一个栈帧重新成为当前栈帧.</li><li>Java方法有两种返回函数的方式, 一种是正常的函数返回, 使用return指令; 另一种是抛出异常. 不管使用哪种方式, 都会导致栈帧被弹出.</li></ul><h4 id="2-2-1-栈帧的内部结构"><a href="#2-2-1-栈帧的内部结构" class="headerlink" title="2.2.1 栈帧的内部结构"></a>2.2.1 栈帧的内部结构</h4><p>每个栈帧中储存着：</p><ul><li>局部变量表(Local Variables)</li><li>操作数栈(Operand Stack)(或表达式栈)</li><li>动态链接(Dynamic Linking)(或指向运行时常量池的方法引用)</li><li>方法返回地址(Return Address)(或方法正常退出或者异常退出的定义)</li><li>一些附加信息</li></ul><h4 id="2-2-2-局部变量表"><a href="#2-2-2-局部变量表" class="headerlink" title="2.2.2 局部变量表"></a>2.2.2 局部变量表</h4><ul><li>局部变量表也称之为局部变量数组或本地变量表</li><li>定义为一个数字数组, 主要用来储存方法参数和定义在方法体内的的局部变量, 这些数据类型包括各类基本数据类型、对象引用(reference类型 它并不等同于对象本身 可能是指向一个对象起始地址的引用指针 也可能指向一个代表对象的句柄或者其他与此对象相关的位置),  以及returnAddress(指向了一条字节码指令地址)类型</li><li>由于局部变量表是建立在线程的栈上, 是线程的私有数据, 因此不存在数据安全问题</li><li>局部变量表所需的容量大小是在编译期确定下来的, 并保存在方法的Code属性的maximun local variables数据项中。在方法运行期间是不会改变局部变量表的大小的</li><li>方法嵌套的次数由栈的大小决定。一般来说,栈越大, 方法嵌套调用次数越多。对一个函数而言,它的参数和局部变量越多, 使得局部变量表膨胀, 它的帧就越大, 以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间, 导致其嵌套调用次数就会减少</li><li>局部变量表只在当前方法调用中有效。在方法执行时, 虚拟机通过使用局部变量表完成参数值到参数列表的传递过程。当方法调用结束后, 随着方法栈的销毁,局部变量表也会销毁</li><li>局部变量表, 最基本的储存单是Slot(变量槽)</li><li>在《Java虚拟机规范》中对这个内存区域规定了两类异常状况: 如果线程请求的栈深度大于虚拟机所允许的深度 将抛出StackOverflowError异常; 如果Java 虚拟机栈容量可以动态扩展 当栈扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常</li><li>HotSpot虚拟机的栈是不支持动态扩展的</li></ul><h5 id="2-2-2-1关于Slot的理解"><a href="#2-2-2-1关于Slot的理解" class="headerlink" title="2.2.2.1关于Slot的理解"></a>2.2.2.1关于Slot的理解</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1&gt;</span> <span class="string">JVM会为局部变量表中的每一个Slot都分配一个访问索引, 通过这个索引1即可成功访问到局部变量表中指定的局部变量值</span></span><br><span class="line"><span class="attr">2&gt;</span> <span class="string">当一个实例方法调用的时候, 它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上</span></span><br><span class="line"><span class="attr">3&gt;</span> <span class="string">如果需要访问局部变量表中的一个64bit的局部变量值时, 只需要使用前一个索引即可(注:32位以内的类型只占一个和slot(包括returnAddress), 64位的类型(long和double占用两个slot))</span></span><br><span class="line"><span class="attr">4&gt;</span> <span class="string">如果当前帧是由构造方法或者实列方法创建的, 那么该对象引用this将会存放在index为0的slot处, 其余的参数按照参数顺序表顺序继续排列</span></span><br></pre></td></tr></table></figure><p>栈帧中局部变量表中的槽位是可以重用的, 如果一个局部变量过了其作用域, 那么在其作用域之后申明的新的局部变量可能会复用过期局部变量的槽位, 从而达到节省资源的目的</p><h5 id="2-2-2-2-总结"><a href="#2-2-2-2-总结" class="headerlink" title="2.2.2.2 总结"></a>2.2.2.2 总结</h5><ul><li>在栈帧中, 与性能调优最为密切的部分就是局部变量表, 在方法执行时, 虚拟机使用局部变量表完成方法的传递</li><li>局部变量中的变量也是重要的垃圾回收根节点, 只要被局部变量表中直接或者间接引用的对象都不会被回收</li></ul><h4 id="2-2-3-操作数栈"><a href="#2-2-3-操作数栈" class="headerlink" title="2.2.3 操作数栈"></a>2.2.3 操作数栈</h4><ul><li>操作数栈, 主要用于保存计算的中间结果, 同时作为计算过程中变量临时的储存空间</li><li>操作数栈就是JVM执行引擎的一个工作区, 当一个方法开始执行的时候, 一个新的栈帧也会随之被创建出来, 这个方法的操作数栈是空的</li><li>每一个操作数栈都会拥有一个明确的栈深度用于储存数值, 其所需的最大深度在编译器就定义好了, 保存在方法的Code属性中, 为max_stack的值</li><li>栈中的任何一个元素都可以是任意的Java数据类型<ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul></li><li>操作数栈并非采用访问索引的方式来进行数据访问的,  而是只能通过标准的入栈和出栈操作来完成一次数据访问</li><li>如果被调用的方法带有返回值的话, 其返回值将会被压入当前栈帧的操作数栈中, 并更新PC寄存器中下一条需要执行的字节码指令</li><li>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配, 这由编译器在编译期间进行验证, 同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证</li><li>另外, 我们说Java虚拟机的解析引擎是基于栈的执行引擎, 其中的栈指的就是操作数栈</li></ul><h4 id="2-2-4-动态链接"><a href="#2-2-4-动态链接" class="headerlink" title="2.2.4 动态链接"></a>2.2.4 动态链接</h4><ul><li>每个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接</li><li>在Java源文件被编译到字节码文件中, 所有的变量和方法引用都作为符号引用(symbolic Reference) 保存在class文件的常量池里。比如描述一个方法调用了另外的其他方法时, 就是通过常量池中指向方法的符号引用来表示的, 那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</li></ul><h5 id="2-2-4-1-为什么需要常量池"><a href="#2-2-4-1-为什么需要常量池" class="headerlink" title="2.2.4.1 为什么需要常量池"></a>2.2.4.1 为什么需要常量池</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">常量池的作用就是提供一些符号和常量,</span> <span class="string">便于指令的识别以及资源的共享和复用</span></span><br></pre></td></tr></table></figure><h5 id="2-2-4-2-方法的调用"><a href="#2-2-4-2-方法的调用" class="headerlink" title="2.2.4.2 方法的调用"></a>2.2.4.2 方法的调用</h5><p>在JVM中, 将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><ul><li>静态链接(静态绑定): 当一个字节码文件被装进JVM内部时, 如果被调用的目标方法在编译期可知, 且运行期保持不变, 这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</li><li>动态链接(动态绑定): 如果被调用的·1方法在编译期无法被确定下来, 也就是说, 只能够在程序运行期将调用方法的符号引用转换为直接引用, 由于这种引用转换过程具有动态性, 因此被称为动态链接</li></ul><h5 id="2-2-4-3-虚方法和非虚方法"><a href="#2-2-4-3-虚方法和非虚方法" class="headerlink" title="2.2.4.3 虚方法和非虚方法"></a>2.2.4.3 虚方法和非虚方法</h5><ul><li>普通调用指令<ul><li>invokestatic: 调用静态方法, 解阶段确定唯一方法版本</li><li>invokespecial: 调用<init>方法、私有方法以及父类方法, 解析阶段确定唯一方法版本</li><li>invokevirtual: 调用所有的虚方法</li><li>invokeinterface: 调用接口方法</li></ul></li><li>动态调用指令<ul><li>invokedunamic: 动态解析出需要调用的方法, 然后执行</li></ul></li></ul><p>前四条指令固化在虚拟机内部, 方法的调用执行不可人为干预, 而invokedynamic指令则支持由用户确定方法的版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法, 其余的(final修饰的除外)称为虚方法</p><h5 id="2-2-4-4-关于invokedynamic指令"><a href="#2-2-4-4-关于invokedynamic指令" class="headerlink" title="2.2.4.4 关于invokedynamic指令"></a>2.2.4.4 关于invokedynamic指令</h5><p>invokedynamic指令于Java7添加, 是为了能够让Java支持动态类型语言而做的一种改进(使用Lamabda表达式可以直接生成)</p><p>Java7中增加的动态类型语言支持的本质是对Java虚拟机规范的修改, 而不是对Java语言规则的修改</p><p>动态类型语言和静态类型语言</p><p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期, 满足前者就是静态类型语言, 反之是动态类型语言</p><p>静态类型语言是判断变量自身的类型信息; 动态类型语言是判断变量值的类型信息, 变量没有类型信息, 变量值才有类型信息</p><p>Java是静态类型的语言    </p><h4 id="2-2-5-方法返回地址"><a href="#2-2-5-方法返回地址" class="headerlink" title="2.2.5 方法返回地址"></a>2.2.5 方法返回地址</h4><p>存放调用该方法的pc寄存器的值</p><ul><li>无论方法正常退出还是异常退出都会回到该方法被调用的位置。方法正常退出时, 调用者的pc计数器的值作为返回地址, 即调用该方法的指令的下一条指令的地址, 而异常退出的, 返回地址是要通过异常表来确定, 栈帧中一般不会保存这部分信息</li><li>本质上, 方法的退出就是当前栈帧出栈的过程。此时, 需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等, 让调用者方法继续执行下去</li><li>正常完成出口和异常完成出口的区别在于: 通过异常完成出口退出的不会给它的上层调用者产生任何的返回值</li><li>执行引擎遇到任意一个方法返回的字节码指令(return),会有返回值传递给上层的方法调用者, 简称正常完成出口<ul><li>一个正常方法调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定</li><li>在字节码指令中, 返回指令包含ireturn(当前返回值是boolean、byte、char、short、int类型时使用)、lreturn、freturn、dreturn以及areturn(引用类型)。另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用</li></ul></li><li>在方法执行过程中遇到了异常, 并且这个异常没有在方法内处理, 也就是没有在本地的异常表中没有搜索到匹配的异常处理器, 就会导致方法退出, 简称异常完成出口(方法执行过程中抛出异常时的异常处理, 储存在一个处理表中)</li></ul><h4 id="2-2-6-一附加信息"><a href="#2-2-6-一附加信息" class="headerlink" title="2.2.6 一附加信息"></a>2.2.6 一附加信息</h4><p>栈帧中还允许携带与ava虚拟机实现相关的一些附加信息, 比如对程序调试提供支持的信息</p><h3 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h3><ul><li>Java虚拟机栈用于管理Java方法的调用, 而本地方法栈用于管理本地方法的调用</li><li>本地方法栈, 也是线程私有的</li><li>允许被实现成固定或者是可扩展的内存大小<ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量, Java虚拟机将会抛出一个StackOverflowError异常</li><li>如果本地方法栈可以动态扩展, 并且在尝试扩展的时候无法申请到足够的内存, 或者在创建线程时没有足够的内存去创建对应的本地方法栈, 那么Java虚拟机将会抛出一个OutofMemoryError异常</li></ul></li><li>本地方法是使用C&#x2F;C++语言实现的</li><li>加载本地方法的具体做法是Native Method Stack中登记native方法, 在Execution Engine执行时加载本地方法库</li><li>当某个线程调用一个本地方法时, 它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限<ul><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区</li><li>它甚至可以本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存</li></ul></li><li>并不是所有的JVM都支持本地方法栈 因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构。如果JVM产品不打算支持native方法, 也可以无需实现本地方法栈</li><li>在HotSpot中, 直接将本地方法栈和虚拟机栈合二为一</li></ul><h3 id="2-4-堆"><a href="#2-4-堆" class="headerlink" title="2.4 堆"></a>2.4 堆</h3><ul><li>一个JVNM实例只存在一个堆内存, 堆也是Java内存管理的核心区域</li><li>Java堆内存的JVM启动的时候即被创建, 其空间大小也就确定了。堆区是JVM管理的最大一块内存空间(堆内存的大小是可以调节的)</li><li>《JVM虚拟机规范》规定, 堆可以处于物理上不连续的内存空间, 但是在逻辑上它应该被视为连续的</li><li>所有的的线程共享Java堆, 在这里还可以划分为线程私有的缓冲区(Thread Local Allocation Buffer TLAB)</li><li>堆, 是GC(Garbage Collection 垃圾回收器) 执行垃圾回收的重点区域</li><li>在方法结束后, 堆中的对象不会马上被移除, 仅仅在垃圾收集的时候才会移出(GC的启动也需要消耗系统资源, 所以GC并不会频繁的启动)</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印虚拟机参数(加号表示启用 减号表示不启用)</span></span><br><span class="line"><span class="attr">java</span> <span class="string">-XX:+PrintFlagsFinal | wc -l </span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-Xms20m</span> <span class="string">-Xmx20m(默认单位字节) -XX:+PrintGCDetails</span></span><br></pre></td></tr></table></figure><p>现代垃圾收集器都基于分代收集理论设计, 堆内存<strong>逻辑</strong>上细分为新生代(New)、老年代(Tenured, Old )以及元空间(Metaspace)(Java8之前叫作永久代)</p><h4 id="2-4-1-堆空间大小的设置"><a href="#2-4-1-堆空间大小的设置" class="headerlink" title="2.4.1  堆空间大小的设置"></a>2.4.1  堆空间大小的设置</h4><ul><li><p>-Xms 用于设置堆区的起始内存(年轻代 +老年代), 等价于-XX:InitialHeapSize</p></li><li><p>-Xmx 则用于设置堆区的最大内存(年轻代 +老年代), 等价于-XX:MaxHeapSize</p></li><li><p>一旦堆区中的内存大小超过了-Xmx所指定的最大内存时, 将会抛出OutofMemoryError异常</p></li><li><p>通常会将-Xms和-Xmx两个参数配置相同的值, 其目的在于为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小, 从而提高性能</p></li><li><p>默认堆空间的大小</p><ul><li>初始内存大小:物理电脑内存 &#x2F; 64</li><li>最大内存大小: 物理内存大小 &#x2F; 4</li></ul></li><li><p>查看设置堆空间的参数的详细信息</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式一</span></span><br><span class="line"><span class="attr">1&gt;</span> <span class="string">jps</span></span><br><span class="line"><span class="attr">2&gt;</span> <span class="string">jstat -gc pid</span></span><br><span class="line"><span class="comment">#方式二</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">PrintGCDetails</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-4-2-年轻代和老年代"><a href="#2-4-2-年轻代和老年代" class="headerlink" title="2.4.2  年轻代和老年代"></a>2.4.2  年轻代和老年代</h4><ul><li><p>储存在JVM中Java对象可以被划分为两类</p><ul><li>一类是生命周期较短的瞬时对象, 这类对象的创建和消亡都非常迅速</li><li>另外一类对象的生命周期却非常长, 在某些极端情况下还能够与JVM的生命周期保持一致</li></ul></li><li><p>Java堆区进一步细分的话, 可以划分为年轻代(YoungGen)和老年代(OldGen)</p></li><li><p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间(有时也叫from区、to区 s0&#x2F;s1 空的为to区)</p></li><li><p>配置年轻代和老年代在堆结构的占比</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-XX</span>:<span class="string">NewRatio=2 表示新生代占1 老年代占2, 新生代占整个堆的1/3</span></span><br></pre></td></tr></table></figure></li><li><p>查看默认年轻代和老年代在堆结构的占比</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前所有java进程pid</span></span><br><span class="line"><span class="attr">jps</span></span><br><span class="line"><span class="comment"># 查看默认年轻代和老年代在堆结构的占比为2(新生代占1.老年代占2)</span></span><br><span class="line"><span class="attr">jinfo</span> <span class="string">-flag NewRatio pid</span></span><br><span class="line"><span class="attr">&gt;&gt;&gt;</span> <span class="string">-XX:NewRatio=2</span></span><br><span class="line"><span class="comment"># 查看Eden空间和另外两个Survivor空间缺省所占的比例(默认Eden空间占8份)</span></span><br><span class="line"><span class="attr">jinfo</span> <span class="string">-flag SurvivorRatio 进程pid</span></span><br><span class="line"><span class="attr">&gt;&gt;&gt;</span> <span class="string">-XX:SurvivorRatio=8</span></span><br></pre></td></tr></table></figure></li><li><p>在HotSpot中, Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1</p></li><li><p>可以使用选项-XX:SurvivorRatio调整这个空间比例</p></li><li><p>几乎所有的Java对象都是在Eden区被new出来的</p></li><li><p>绝大部分的Java对象的销毁都是在年轻代进行的</p></li><li><p>可以使用选项-Xmn设置新生代最大内存大小</p></li><li><p>关于垃圾回收: 频繁的新生区收集, 很少在养老区收集, 几乎不在元空间收集</p></li><li><p>YGC:年轻代中的垃圾回收器</p></li><li><p>FGC:老年代中的垃圾回收器</p></li></ul><h4 id="2-4-3-MinorGC-YGC-、MajorGC、-FullGC"><a href="#2-4-3-MinorGC-YGC-、MajorGC、-FullGC" class="headerlink" title="2.4.3  MinorGC(YGC)、MajorGC、 FullGC"></a>2.4.3  MinorGC(YGC)、MajorGC、 FullGC</h4><p>JVM在进行GC时, 并非每次都对上面三个内存(新生代、老年代、方法区)区域一起回收, 大部分回收的都是指新生代</p><p>针对HotSpot VM的实现, 它里面的GC按照回收区域又分为两大种类型: 一种是部分收集(Partial GC), 一种是整堆收集(Full GC)</p><ul><li>部分收集: 指目标不是完整收集整个Java堆的垃圾收集<ul><li>新生代收集(Minor GC &#x2F; Young GC) : 只是新生代(Eden&#x2F;S0, S1)的垃圾收集</li><li>老年代收集(Major GC &#x2F; Old GC) : 只是老年代的垃圾收集<ul><li>目前 , 只有CMS GC会有单独收集老年代的行为</li><li>注意, 很多时候Major GC会和 Full GC混淆使用, 需要具体分辨是老年代回收还是整堆回收</li></ul></li><li>混合收集(Mixed GC) : 收集整个新生代以及部分老年代的垃圾回收<ul><li>目前只有G1 GC会有这种行为</li></ul></li></ul></li><li>整堆收集(Full GC):  收集整个Java堆和方法区的垃圾收集</li></ul><h4 id="2-4-3-分代式GC策略的触发条件"><a href="#2-4-3-分代式GC策略的触发条件" class="headerlink" title="2.4.3 分代式GC策略的触发条件"></a>2.4.3 分代式GC策略的触发条件</h4><ul><li><p>年轻代GC(Minor GC)触发机制:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1&gt;</span> <span class="string">当年轻代空间不足时, 就会触发Minor GC, 这里的年轻代满指的是Eden满, Survivor满不会引起GC(每次Minor GC会清理年轻代的内存)</span></span><br><span class="line"><span class="attr">2&gt;</span> <span class="string">因为Java对象大多都具备朝生夕灭的特性, 所以Minor GC非常频繁, 一般回收速度也比较快</span></span><br><span class="line"><span class="attr">3&gt;</span> <span class="string">Minor GC会引发STW(Stop The World), 暂停其他用户的线程, 等待垃圾回收结束, 用户线程才恢复运行</span></span><br></pre></td></tr></table></figure></li><li><p>老年代(Major GC &#x2F; Full GC)触发机制:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1&gt;</span> <span class="string">指发生在老年代的GC, 对象从老年代消失, 即Major GC或者Full GC发生了</span></span><br><span class="line"><span class="attr">2&gt;</span> <span class="string">出现了Major GC, 经常会伴随至少一次的Minor GC(但非绝对的, 在Parallel Scavenge收集器的收集策略中) 注: 也就是在老年代空间不足时, 会先尝试进行Major GC的策略选择过程触发Minor GC。如果之后空间还不足, 则触发Major GC</span></span><br><span class="line"><span class="attr">3&gt;</span> <span class="string">Major GC的速度一般会比Minor GC慢10倍以上, STW的时间更长</span></span><br><span class="line"><span class="attr">4&gt;</span> <span class="string">如果Major GC后, 内存还不足, 就报OOM</span></span><br></pre></td></tr></table></figure></li><li><p>Full GC触发机制</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1&gt;</span> <span class="string">调用System.gc()时, 系统建议执行Full GC, 但是不必然执行</span></span><br><span class="line"><span class="attr">2&gt;</span> <span class="string">老年代空间不足</span></span><br><span class="line"><span class="attr">3&gt;</span> <span class="string">方法区空间不足</span></span><br><span class="line"><span class="attr">4&gt;</span> <span class="string">通过Minor GC后进入老年代的平均大小大于老年代的可用内存</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-4-5-堆空间分代思想"><a href="#2-4-5-堆空间分代思想" class="headerlink" title="2.4.5 堆空间分代思想"></a>2.4.5 堆空间分代思想</h4><p>堆分代的唯一理由就是<strong>优化GC性能</strong>   </p><p>经研究, 不同的对象的生命周期不同, 70%-90%的对象是临时对象</p><ul><li>新生代: 有Eden、两块大小相同的Survivor构成,  to总为空</li><li>老年代: 存放新生代中经历多次GC仍然存活的对象</li></ul><h4 id="2-4-6-内存分配策略"><a href="#2-4-6-内存分配策略" class="headerlink" title="2.4.6 内存分配策略"></a>2.4.6 内存分配策略</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">如果对象在Eden出生并经过第一次Minor</span> <span class="string">GC后仍然存活, 并且能被Survivor容纳的话, 将被移动到Survivor空间中, 并将对象年龄设为1。对象在Survivor区中没每经过一次Minor GC, 年龄就增加一岁, 当它的年龄增加到一定程度(默认为15岁, 每个JVM, 每个GC都有所不同)时, 就会被晋升到老年代中。</span></span><br><span class="line"><span class="attr">对象晋升老年代的年龄阈值可以通过选项</span> <span class="string">-XX:MaxTenuringThreshold来设置</span></span><br></pre></td></tr></table></figure><ul><li><p>优先分配到Eden</p></li><li><p>大对象直接分配到老年代(尽量避免程序中出现过多的大对象)</p></li><li><p>长期存活的对象分配到老年代</p></li><li><p>动态对象年龄判断</p><ul><li>如果Survivor区中相同年龄的的所有对象大小的总和大于survivor空间的一半, 年龄大于或者等于该年龄的对象可以直接进入老年代, 无须等到MaxTenuringThreshold种要求的年龄</li></ul></li><li><p>空间分配担保</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-XX</span>:<span class="string">HandlePromotionFailure(JDK7以后失效了)</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-4-7-TLAB-Thread-Local-Allocation-Buffer"><a href="#2-4-7-TLAB-Thread-Local-Allocation-Buffer" class="headerlink" title="2.4.7 TLAB(Thread Local Allocation Buffer)"></a>2.4.7 TLAB(Thread Local Allocation Buffer)</h4><p>什么是TLAB?</p><ul><li><p>线程本地分配缓存区</p></li><li><p>从内存模型而不是垃圾回收的角度, 对Eden区继续进行划分, JVM为每个线程分配了一个私有的缓存区域, 它包含在Eden空间内</p></li><li><p>多线程同时分配内存时, 使用TLAB可以避免一系列的非线程安全问题, 同时还能够提升内存分配的吞吐量, 因此我们将这种内存的分配方式称之为快速分配策略</p></li></ul><p>为什么需要TLAB</p><ul><li>堆区是线程共享的区域, 任何线程都可以访问到堆区中的共享数据 由于对象实例的创建在JVM中非常频繁, 因此在并发环境中从堆区化分内存空间是线程不安全的</li><li>为避免多个线程操作同一地址, 需要使用加锁等机制, 进而影响分配速度</li></ul><p>tips:</p><ul><li>尽管不是所有的对象实例都能够在TLAB中成功分配内存, 但JVM确实是将TLAB作为内存分配的首选</li><li>在程序中, 可以通过选项<code>-XX:UseTLAB</code>设置是否开启TLAB空间(JDK8及其之后默认开启)</li><li>默认情况下, TLAB空间的内存非常小, 仅占有整个Eden空间的1%, 可以通过选项<code>-XX:TLABWasteTargetPercent</code>设置TLAB</li><li>一旦对象在TLAB空间分配内存失败, JVM就会尝试通过使用加锁机制来确保数据操作的原子性, 从而直接在Eden空间中分配内存</li></ul><h4 id="2-4-8-堆空间常用参数设置"><a href="#2-4-8-堆空间常用参数设置" class="headerlink" title="2.4.8 堆空间常用参数设置"></a>2.4.8 堆空间常用参数设置</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-XX</span>:<span class="string">+PrintFalgsFinal   查看所有参数的最终值</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">+PrintFlagsInitial 查看所有参数的默认初始值</span></span><br><span class="line"><span class="attr">-Xmn</span>=<span class="string">xxx               设置新生代的大小</span></span><br></pre></td></tr></table></figure><h4 id="2-4-9-逃逸分析"><a href="#2-4-9-逃逸分析" class="headerlink" title="2.4.9 逃逸分析"></a>2.4.9 逃逸分析</h4><p>堆是分配对象存储的唯一选择吗?</p><p>随着JIT编译器的发展与逃逸分析技术逐渐成熟, 栈上分配、标量替换优化技术将会导致一些微秒的变化, 所有的对象不一定都分配到堆上</p><p>在Java虚拟机中, 对象是在Java堆中分配内存的, 这是一个普遍的常识。但是有一种特殊的情况, 那就是如果经过逃逸分析后发现, 一个对象并没有逃逸出方法的话, 那么就可能会优化成栈上分配, 这样就无需在堆上分配内存, 也无需进行垃圾回收了, 即堆外存储技术</p><p>如何将堆上地对象分配到栈上, 需要使用逃逸分析手段</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">逃逸分析是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#逃逸分析的基本行为就是分析对象动态作用域:</span></span><br><span class="line"><span class="attr">当一个对象在方法中被定义后,</span> <span class="string">对象只在方法内部使用, 则认为没有发生逃逸</span></span><br><span class="line"><span class="attr">当一个对象在方法中被定义后,</span> <span class="string">它被外部方法所引用, 则认为发生逃逸, 比如作为调用参数传递到其他地方中</span></span><br></pre></td></tr></table></figure><p>tip: <strong>开发中能使用局部变量的, 就不要使用在方法外定义的变量</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启逃逸分析</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">+DoEscapeAnalysis</span></span><br><span class="line"><span class="comment">#关闭逃逸分析</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">-DoEscapeAnalysis</span></span><br><span class="line"><span class="comment">#JDK7之后默认开启</span></span><br></pre></td></tr></table></figure><h5 id="2-4-9-1-标量替换"><a href="#2-4-9-1-标量替换" class="headerlink" title="2.4.9 .1 标量替换"></a>2.4.9 .1 标量替换</h5><p>标量(Scalar) 是指一个无法再分解成更小的数据的数据</p><p>Java中原始数据类型就是标量</p><p>相对的, 那些还可以分解的数据叫做聚合量</p><p>Java中对象就是聚合量</p><p>在JIT阶段, 如果经过逃逸分析, 发现一个对象不会被外界访问的话, 那么经过JIT优化, 就会把这个对象拆解成若干个其他成员变量来代替, 这个过程就是标量替换</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#标量参数替换设置</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">EliminateAllocations(默认打开, 允许将对象打散分配在栈上)</span></span><br></pre></td></tr></table></figure><h3 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h3><p>《Java虚拟机规范》说明方法区在逻辑上是属于堆的一部分, 但是对于Java虚拟机的实现之一的HotSpot而言, 方法区还有一个别名叫做Non-Heap(非堆), 目的就是要和堆分开, 所以, 方法区看作是一块独立于Java堆的内存空间</p><p> 目前, 元空间(Metaspace)是方法区的具体落地实现</p><ul><li>方法区(Method Area)与堆一样, 是各个先线程共享的区域</li><li>方法区在JVM启动的时候被创建, 并且它的实际物理内存空间中和Java堆区一样都可以是不连续的</li><li>方法区的大小和堆空间一样, 可以选择固定大小或者可扩展</li><li>方法区的大小决定了系统可以保存多少个类, 如果系统定义了太多的类, 导致方法区溢出, 虚拟机同样会抛出内存溢出错误</li><li>关闭JVM就会释放这个区域的内存</li></ul><h4 id="2-5-1-HotSpot中方法区的演进"><a href="#2-5-1-HotSpot中方法区的演进" class="headerlink" title="2.5.1 HotSpot中方法区的演进"></a>2.5.1 HotSpot中方法区的演进</h4><ul><li>在JDK7及以前, 习惯上把方法区称为永久代。JDK8开始, 使用元空间取代了永久代</li><li>本质上, 方法区和永久代并不等价。仅是对于HotSpot而言的(HotSpot中永久代就是方法区的实现) ,《Java虚拟机规范》中对于如何实现方法区, 不做统一要求, 例如 BEA  JRocket &#x2F; IBM J9中不存在永久代的概念</li><li>在JDK8完全废弃了永久代的概念, 改用与JRocket、J9一样在本地内存中实现的元空间(Metaspace)来代替</li><li>元空间的本质和永久代类似, 都是JVM规范中方法区的实现, 不过元空间与永久代最大的区别在于: <strong>元空间不在虚拟机设置的内存中, 而是使用本地内存</strong></li><li>永久代、元空间二者并不只是名字变化了, 内部的结构也调整了</li><li>根据《Java虚拟机规范》的规定, 如果方法区无法满足新的内存分配需求, 将抛出OOM异常</li></ul><h4 id="2-5-2-设置方法区大小的参数"><a href="#2-5-2-设置方法区大小的参数" class="headerlink" title="2.5.2 设置方法区大小的参数"></a>2.5.2 设置方法区大小的参数</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置永久代空间的大小</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">PermSize</span></span><br><span class="line"><span class="comment"># 设置永久代空间的最大值</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">MaxPermSize</span></span><br><span class="line"><span class="comment"># 默认元空间的初始值大小</span></span><br><span class="line"><span class="attr">jps</span></span><br><span class="line"><span class="attr">jinfo</span> <span class="string">-flag MetaspaceSize pid</span></span><br><span class="line"><span class="attr">&gt;&gt;&gt;</span> <span class="string">-XX:MetaspaceSize=21807104</span></span><br><span class="line"><span class="comment"># 默认元空间的最大值</span></span><br><span class="line"><span class="attr">jinfo</span> <span class="string">-flag MaxMetaspaceSize pid</span></span><br><span class="line"><span class="attr">&gt;&gt;&gt;</span> <span class="string">-XX:MaxMetaspaceSize=18446744073709486080</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置元空间的初始值大小</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">MetaspaceSize=10m</span></span><br><span class="line"><span class="comment"># 设置元空间的最大值</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">MaxMetaspaceSize=100m</span></span><br></pre></td></tr></table></figure><h4 id="2-5-3-方法区的作用"><a href="#2-5-3-方法区的作用" class="headerlink" title="2.5.3 方法区的作用"></a>2.5.3 方法区的作用</h4><p>它用于储存已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等</p><h5 id="2-5-3-1-类型信息"><a href="#2-5-3-1-类型信息" class="headerlink" title="2.5.3.1 类型信息"></a>2.5.3.1 类型信息</h5><p>对每个加载的类型(类class、接口interface、枚举enum、注解annotation), JVM必须在方法区中存储以下类型信息</p><ul><li>这个类型的完整有效名称(包名.类名)</li><li>这个类型直接父类的完整有效名(对于interface和java.lang.Object都没有父类)</li><li>这个类型的修饰符(public, abstract, final的某个子集)</li><li>这个类型直接接口的一个有序列表</li></ul><h5 id="2-5-3-2-域-Field-信息"><a href="#2-5-3-2-域-Field-信息" class="headerlink" title="2.5.3.2 域(Field)信息"></a>2.5.3.2 域(Field)信息</h5><ul><li>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序</li><li>域的相关信息包括: 域名称、域类型、域修饰符(public, private, protected, static, volatile, transient的某个子集)</li></ul><h5 id="2-5-3-3-方法-Method-信息"><a href="#2-5-3-3-方法-Method-信息" class="headerlink" title="2.5.3.3 方法(Method)信息"></a>2.5.3.3 方法(Method)信息</h5><ul><li><p>方法名称</p></li><li><p>方法的返回类型</p></li><li><p>方法参数的数量和类型</p></li><li><p>方法的修饰符(public, private, protected, static, final, synchronized, native, abstract的一个子集)</p></li><li><p>方法的字节码文件、操作数栈、局部变量表及大小(abstract和native方法除外)</p></li><li><p>异常表(abstract和native方法除外)</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="2-5-3-4-class文件中常量池"><a href="#2-5-3-4-class文件中常量池" class="headerlink" title="2.5.3.4 class文件中常量池"></a>2.5.3.4 class文件中常量池</h5><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口描述信息外, 还包含一项信息那就是常量池表(Constant Pool Table),  包含各种字面量和对类型、域和方法的符号引用</p><p>一个Java源文件中的类、接口, 编译后产生一个字节码文件, 而Java中的字节码需要数据支持, 通常这种数据会很大以至于不能直接存到字节码里, 换另一种方式, 可以存到常量支持池中, 这个字节码包含了指向常量池的引用, 并在动态链接的时候使用运行时常量池(相当于Maven仓库一样)</p><p>常量池可以看做是一张表, 虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型</p><h5 id="2-5-3-5-运行时常量池"><a href="#2-5-3-5-运行时常量池" class="headerlink" title="2.5.3.5 运行时常量池"></a>2.5.3.5 运行时常量池</h5><ul><li><strong>class文件中的常量池经过类加载器放到方法区以后就叫做运行时常量池</strong></li><li>运行时常量池(Runtime Constant Pool) 是方法区的一部分</li><li>常量池表(Constant Pool Table) 是Class文件的一部分, 用于存放编译期生成的各种字面量与符号引用, <strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong></li><li>运行时常量池, 在加载类和接口到虚拟机后, 就会创建对应的运行时常量池</li><li>JVM为每个已加载的类型(类或者接口)都维护一个常量池。池中的数据项像数组项一样, 是通过索引访问的</li><li>运行时常量池中包含多种不同的常量, 包括编译期就已经明确的数值常量, 也包括到运行期解析后才能够获得的方法或者字段引用, 此时不再是常量池中的符号地址了, 这里换为真实地址</li><li>运行时常量池具有动态性</li><li>当创建类或者接口的运行时常量池时, 如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值, JVM将会抛出OOM</li></ul><h5 id="2-5-3-6-方法区的演进细节"><a href="#2-5-3-6-方法区的演进细节" class="headerlink" title="2.5.3.6 方法区的演进细节"></a>2.5.3.6 方法区的演进细节</h5><p>只有在HotSpot中才有永久代, BEA的JRocket和IBM的J9都是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现的细节,不受《Java虚拟机规范》管束, 并不要求同一</p><table><thead><tr><th>JDK6及之前</th><th>有永久代(permanent generation) , 字符串常量池、 静态变量存放在永久代上</th></tr></thead><tbody><tr><td>JDK7</td><td>有永久代, 但是已经逐步”去永久代”, 字符串常量池、静态变量移出, 保存在堆中(永久代仍然使用Java虚拟机内存)</td></tr><tr><td>JDK8及之后</td><td>无永久代, 类型信息、方法、字段、常量保存在本地内存的元空间(方法区), 但是字符串常量池、静态变量仍在堆中</td></tr></tbody></table><p>随着Java8的到来, HotSpot VM中再也见不到了永久代了。但是这并不意味着类的元数据信息也消失了, 这些数据被移到了一个与堆不相连的本地内存区域, 这个区域叫做元空间(Metaspace)</p><p>由于类的元数据分配在本地内存中。元空间的最大分配内存空间就是系统可用的内存空间</p><p>永久代为什么要被元空间替换?</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1&gt;</span> <span class="string">为元空间设置空间大小是很难确定的, 在某些场景中, 如果动态加载类过多, 容易产生Perm区的OOM, 而元空间与永久代之间的最大区别在于: 元空间并不在虚拟机中, 而是使用本地内存, 因此, 默认情况下, 元空间的大小仅受本地内内存限制</span></span><br><span class="line"><span class="attr">2&gt;</span> <span class="string">对永久代进行调优是很困难的</span></span><br></pre></td></tr></table></figure><h5 id="2-5-3-7-方法区的垃圾回收"><a href="#2-5-3-7-方法区的垃圾回收" class="headerlink" title="2.5.3.7 方法区的垃圾回收"></a>2.5.3.7 方法区的垃圾回收</h5><p>方法区的垃圾收集主要回收两部分内容: 常量池中废弃的常量和不再使用的类型</p><p>方法区内的常量池之中主要存放的两大类常量: 字面量和符号引用。字面量比较接近Java语言层次的常量概念, 如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念, 包括下面三类常量:</p><ul><li>类和接口的全限定类名</li><li>字段的名称和描述符</li><li>方法的名称的描述符</li></ul><p>HotSpot VM对常量池的回收策略是很明确的, 只要常量池中的常量没有被任何地方引用, 就可以被回收</p><p>回收废弃常量与回收Java堆中的对象非常类似</p><p>判断一个常量是否”废弃”还是相对简单, 而要判定一个类型是否”不再被使用的类”的条件就比较苛刻了:</p><ul><li>该类的所有实例都已经被回收, 也就是Java堆中不存在该类及其任何派生类的实例</li><li>加载该类的类加载已经被回收, 这个条件除非是经过精心设计的可替换类加载器的场景, 如OSGI、JSP的重加载等, 否者是很难达成的</li><li>该类对应的java.lang.Class对象没有在任何地方被引用, 无法在任何地方通过反射方法访问该类的方法</li></ul><p>Java虚拟机被允许对满足以上三个条件的无用类进行回收, 这里说的仅仅是”被允许”而并不是和对象一样, 没有了引用就必然会回收</p><p>在大量使用反射、动态代理、CGLib等字节码框架, 动态生成JSP以及OSGI这类频繁自定义类加载器的场景中, 通常都需要Java虚拟机具备类型卸载的能力, 以保证不会对方法区造成大的内存压力</p><h5 id="2-5-3-8-字符串常量池的位置为什么要调整"><a href="#2-5-3-8-字符串常量池的位置为什么要调整" class="headerlink" title="2.5.3.8 字符串常量池的位置为什么要调整?"></a>2.5.3.8 字符串常量池的位置为什么要调整?</h5><p>JDK7中将StringTable放到了堆空间中。因为永久代的回收效率很低, 在full gc时才会触发。而full gc是老年代的空间不足、永久代不足时才会触发, 这就导致StringTable回收效率不高, 而我们开发中会有大量的字符串被创建, 回收效率低, 导致永久代内存不足。放到堆里, 能够及时回收内存。</p><p><img src="https://cdn.qingweico.cn/blog/604e1e0d5aedab222c229f9b.png" alt="JVM"></p><h3 id="2-6-对象的创建"><a href="#2-6-对象的创建" class="headerlink" title="2.6 对象的创建"></a>2.6 对象的创建</h3><h4 id="2-6-1-判断对象对应的类是否加载、链接、初始化"><a href="#2-6-1-判断对象对应的类是否加载、链接、初始化" class="headerlink" title="2.6.1 判断对象对应的类是否加载、链接、初始化"></a>2.6.1 判断对象对应的类是否加载、链接、初始化</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">虚拟机遇到一条new指令。首先去检查这个指令的参数是否在Metaspace的常量池中定位到一个类的符号引用,</span> <span class="string">并且检查这个符号引用代表的类是否已经被加载、解析和初始化(即判断类元信息是否存在)。如果没有, 那么在双亲委派模式下, 使用当前类加载器ClassLoader+包名+类名为key进行查找对应的.class文件。如果没有文件,则抛出ClassNotFoundException异常, 如果找到, 则进行类加载, 并生成对应的Class类对象</span></span><br></pre></td></tr></table></figure><h4 id="2-6-2-为对象分配内"><a href="#2-6-2-为对象分配内" class="headerlink" title="2.6.2 为对象分配内"></a>2.6.2 为对象分配内</h4><p>首先计算对象占用空间大小,接着在堆中划分一块内存给新对象,如果实例成员变量是引用变量,仅分配引用变量空间即可, 即4个字节大小</p><ul><li>如果内存是规整的, 那么虚拟机将采用的是指针碰撞法(Bump The Pointer)来分配内存</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">指针碰撞法</span>: <span class="string">所有用过的内存在一边, 空闲的内存在另外一边, 中间放着一个指针作为分界点的指示器, 分配内存仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了.如果垃圾收集器选择的是Serial, ParNew这种基于压缩算法的, 虚拟机采用这分配方式, 一般使用带有compact(整理)过程的收集器时, 使用指针碰撞.</span></span><br></pre></td></tr></table></figure><ul><li>如果内存是不规整的, 虚拟机需要维护一个列表</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">如果内存不是规整的,</span> <span class="string">已使用的内存和未使用的内存相互交错, 那么虚拟机将采用的是空闲列表法来为对象分配内存</span></span><br><span class="line"><span class="attr">虚拟机维护了一个列表,</span> <span class="string">记录哪些内存块是可用的, 再分配的时候从列表中找到一块足够大的空间划分给对象实例, 并更新列表上的内容, 这种分配方式成为(Free List).</span></span><br></pre></td></tr></table></figure><h4 id="2-6-3-处理并发安全问题"><a href="#2-6-3-处理并发安全问题" class="headerlink" title="2.6.3 处理并发安全问题"></a>2.6.3 处理并发安全问题</h4><ul><li>采用CAS失败重试, 区域加锁保证更新的原子性</li><li>每个线程预先分配一块TLAB</li></ul><h4 id="2-6-4-初始化分配到的空间"><a href="#2-6-4-初始化分配到的空间" class="headerlink" title="2.6.4 初始化分配到的空间"></a>2.6.4 初始化分配到的空间</h4><p>所有属性设置默认值, 保证对象实例字段在不赋值时可以直接使用</p><ul><li>属性的默认初始化</li></ul><h4 id="2-6-5-设置对象的对象头"><a href="#2-6-5-设置对象的对象头" class="headerlink" title="2.6.5 设置对象的对象头"></a>2.6.5 设置对象的对象头</h4><p>将对象的所属类(即类的元数据信息), 对象hashCode和对象的GC信息, 锁信息等数据存储在对象的对象头中, 这个过程的具体设置方式取决于JVM实现</p><h4 id="2-6-6-执行init方法进行初始化"><a href="#2-6-6-执行init方法进行初始化" class="headerlink" title="2.6.6 执行init方法进行初始化"></a>2.6.6 执行init方法进行初始化</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">在Java程序的视角看,</span> <span class="string">初始化才正式开始,初始化成员变量, 执行实例化代码块, 调用类的构造方法, 并把堆内对象的首地址赋值给引用变量. 因此一般来说(由字节码中是否跟随有invokespecial指令所决定), new指令之后会接着执行方法, 把对象按照程序员的意愿进行初始化, 这样一个真正可用的对象才算完全创建出来</span></span><br></pre></td></tr></table></figure><ul><li>显示初始化</li><li>代码块中的初始化</li><li>构造器中初始化</li></ul><h3 id="2-7-对象的内存布局"><a href="#2-7-对象的内存布局" class="headerlink" title="2.7 对象的内存布局"></a>2.7 对象的内存布局</h3><h4 id="2-7-1对象头-Header"><a href="#2-7-1对象头-Header" class="headerlink" title="2.7.1对象头(Header)"></a>2.7.1对象头(Header)</h4><ul><li>运行时元数据(Mark Word)<ul><li>哈希值</li><li>GC分代年龄</li><li>锁状态标志(3位)<ul><li>是否上锁</li><li>轻量级锁</li><li>重量级锁</li><li>是否被GC标记</li><li>是否偏向</li></ul></li><li>Lock Record Address<ul><li>轻量级锁(指向栈中的锁记录)</li><li>检查Mark Word是否指向当前线程的栈</li></ul></li><li>Monitor Address</li><li>Forwarding Address</li><li>线程持有的锁</li><li>偏向线程ID</li><li>偏向时间戳</li></ul></li><li>类型指针: 指向类元数据InstanceClass, 确定该对象所属的类型(指向方法区对象数据类型的指针)</li><li>如果是数组, 还需记录数组的长度</li></ul><h4 id="2-7-2-实例数据-Instance-Data"><a href="#2-7-2-实例数据-Instance-Data" class="headerlink" title="2.7. 2 实例数据 (Instance Data)"></a>2.7. 2 实例数据 (Instance Data)</h4><p>它是对象真正存储的有效信息, 包括程序代码中定义的各种类型的字段(包括从父类继承下来的本身拥有的字段)</p><p>规则:</p><ul><li>相同宽度的字段总是被分配在一起</li><li>父类中定义的变量会出现在子类之前</li><li>如果CompactFields参数为true(默认为true): 子类的窄变量可能插入到父类变量的空隙</li></ul><h4 id="2-7-3-对齐填充-Padding"><a href="#2-7-3-对齐填充-Padding" class="headerlink" title="2.7.3 对齐填充(Padding)"></a>2.7.3 对齐填充(Padding)</h4><p>不是必须的, 也没有特别的含义, 仅仅起到占位符的作用</p><p>由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍, 即任何对象的大小都必须是8字节的整数倍, 如果对象实例数据部分没有对其的话, 就要通过字节填齐来补全</p><p><img src="https://cdn.qingweico.cn/blog/603658cc5f4313ce25534991.png"></p><h4 id="2-7-4-工具-JOL-x3D-Java-Object-Layout"><a href="#2-7-4-工具-JOL-x3D-Java-Object-Layout" class="headerlink" title="2.7.4 工具: JOL &#x3D; Java Object Layout"></a>2.7.4 工具: JOL &#x3D; Java Object Layout</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&lt;dependencies&gt;</span></span><br><span class="line">    <span class="attr">&lt;!--</span> <span class="string">https://mvnrepository.com/artifact/org.openjdk.jol/jol-core --&gt;</span></span><br><span class="line">    <span class="attr">&lt;dependency&gt;</span></span><br><span class="line">        <span class="attr">&lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</span></span><br><span class="line">        <span class="attr">&lt;artifactId&gt;jol-core&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="attr">&lt;version&gt;0.9&lt;/version&gt;</span></span><br><span class="line">    <span class="attr">&lt;/dependency&gt;</span></span><br><span class="line"><span class="attr">&lt;/dependencies&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectLayout</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前两个object header 为markword占用8个字节, 第三个object header 为类型指针(class pointer) 占用4个字节</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">java.lang.Object</span> <span class="string">object internals:</span></span><br><span class="line"> <span class="attr">OFFSET</span>  <span class="string">SIZE   TYPE DESCRIPTION                               VALUE</span></span><br><span class="line">      <span class="attr">0</span>     <span class="string">4        (object header)                           05 00 00 00 (00000101 00000000 00000000 00000000) (5)</span></span><br><span class="line">      <span class="attr">4</span>     <span class="string">4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span></span><br><span class="line">      <span class="attr">8</span>     <span class="string">4        (object header)                           94 20 00 00 (10010100 00100000 00000000 00000000) (8340)</span></span><br><span class="line">     <span class="attr">12</span>     <span class="string">4        (loss due to the next object alignment)</span></span><br><span class="line"><span class="attr">Instance</span> <span class="string">size: 16 bytes</span></span><br><span class="line"><span class="attr">Space</span> <span class="string">losses: 0 bytes internal + 4 bytes external = 4 bytes total</span></span><br><span class="line"></span><br><span class="line"><span class="attr">java.lang.Object</span> <span class="string">object internals:</span></span><br><span class="line"> <span class="attr">OFFSET</span>  <span class="string">SIZE   TYPE DESCRIPTION                               VALUE</span></span><br><span class="line">      <span class="attr">0</span>     <span class="string">4        (object header)                           05 88 d2 25 (00000101 10001000 11010010 00100101) (634554373)</span></span><br><span class="line">      <span class="attr">4</span>     <span class="string">4        (object header)                           0d 02 00 00 (00001101 00000010 00000000 00000000) (525)</span></span><br><span class="line">      <span class="attr">8</span>     <span class="string">4        (object header)                           94 20 00 00 (10010100 00100000 00000000 00000000) (8340)</span></span><br><span class="line">     <span class="attr">12</span>     <span class="string">4        (loss due to the next object alignment)</span></span><br><span class="line"><span class="attr">Instance</span> <span class="string">size: 16 bytes</span></span><br><span class="line"><span class="attr">Space</span> <span class="string">losses: 0 bytes internal + 4 bytes external = 4 bytes total</span></span><br></pre></td></tr></table></figure><h4 id="2-7-5-关闭指针压缩"><a href="#2-7-5-关闭指针压缩" class="headerlink" title="2.7.5 关闭指针压缩"></a>2.7.5 关闭指针压缩</h4><ul><li><p>-XX:+PrintCommandLineFlags -version: 打印HotSpotVM 采用的自动优化参数</p></li><li><p>-XX:+UseCompressedClassPointers: 开启类指针压缩</p></li><li><p>-XX:+UseCompressedOops: 开启普通对象指针压缩</p></li></ul><p>Java中默认开启指针压缩, 使用虚拟机参数<code>-XX:-UseCompressedClassPointers</code>来关闭此选项。 关闭后类型指针(class pointer)占用8个字节, 即第三个和第四个object header</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">java.lang.Object</span> <span class="string">object internals:</span></span><br><span class="line"> <span class="attr">OFFSET</span>  <span class="string">SIZE   TYPE DESCRIPTION                               VALUE</span></span><br><span class="line">      <span class="attr">0</span>     <span class="string">4        (object header)                           05 00 00 00 (00000101 00000000 00000000 00000000) (5)</span></span><br><span class="line">      <span class="attr">4</span>     <span class="string">4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span></span><br><span class="line">      <span class="attr">8</span>     <span class="string">4        (object header)                           d8 1f a5 f0 (11011000 00011111 10100101 11110000) (-257613864)</span></span><br><span class="line">     <span class="attr">12</span>     <span class="string">4        (object header)                           c8 01 00 00 (11001000 00000001 00000000 00000000) (456)</span></span><br><span class="line"><span class="attr">Instance</span> <span class="string">size: 16 bytes</span></span><br><span class="line"><span class="attr">Space</span> <span class="string">losses: 0 bytes internal + 0 bytes external = 0 bytes total</span></span><br><span class="line"></span><br><span class="line"><span class="attr">java.lang.Object</span> <span class="string">object internals:</span></span><br><span class="line"> <span class="attr">OFFSET</span>  <span class="string">SIZE   TYPE DESCRIPTION                               VALUE</span></span><br><span class="line">      <span class="attr">0</span>     <span class="string">4        (object header)                           05 98 59 d1 (00000101 10011000 01011001 11010001) (-782657531)</span></span><br><span class="line">      <span class="attr">4</span>     <span class="string">4        (object header)                           c8 01 00 00 (11001000 00000001 00000000 00000000) (456)</span></span><br><span class="line">      <span class="attr">8</span>     <span class="string">4        (object header)                           d8 1f a5 f0 (11011000 00011111 10100101 11110000) (-257613864)</span></span><br><span class="line">     <span class="attr">12</span>     <span class="string">4        (object header)                           c8 01 00 00 (11001000 00000001 00000000 00000000) (456)</span></span><br><span class="line"><span class="attr">Instance</span> <span class="string">size: 16 bytes</span></span><br><span class="line"><span class="attr">Space</span> <span class="string">losses: 0 bytes internal + 0 bytes external = 0 bytes total</span></span><br></pre></td></tr></table></figure><h3 id="2-8-对象访问定位"><a href="#2-8-对象访问定位" class="headerlink" title="2.8 对象访问定位"></a>2.8 对象访问定位</h3><p>访问对象的方式主要有两种:</p><ul><li>句柄访问</li></ul><p><img src="https://cdn.qingweico.cn/blog/60379b175f4313ce25471152.png"></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">句柄访问的缺点</span>: <span class="string">1&gt; 需要在内存中开辟额外的空间供句柄池存储数据 2&gt; 访问对象需要经过多次地址寻址</span></span><br><span class="line"><span class="attr">优点</span>: <span class="string">当对象被移动(垃圾回收时移动对象很普遍)时, 只会改变句柄中的实例数据指针, 而reference本身不需要修改 </span></span><br></pre></td></tr></table></figure><ul><li>直接指针(HotSpot采用)</li></ul><p>使用直接指针来访问最大的好处就是速度更快,它节省了一次指针定位的时间开销</p><p><img src="https://cdn.qingweico.cn/blog/60379b0f5f4313ce25470a05.png"></p><h3 id="2-9-直接内存-堆外内存"><a href="#2-9-直接内存-堆外内存" class="headerlink" title="2.9 直接内存(堆外内存)"></a>2.9 直接内存(堆外内存)</h3><ul><li>直接内存不是虚拟机运行时数据区的一部分, 也不是《Java虚拟机规范》中定义的内存区域</li><li>直接内存是Java堆外的、直接向系统申请的内存空间</li><li>来源于NIO, 通过存在堆中的DirectByteBuffer操作Native内存</li><li>通常访问直接内存的速度会优先于Java堆, 即读写性能高<ul><li>出于性能考虑, 读写频繁的场所可能会考虑使用直接内存</li><li>Java的NIO库允许Java程序使用直接内存, 用于数据缓冲</li></ul></li><li>直接内存也会出现OOM</li><li>Java中使用DirectByteBuffer类来操作直接内存</li><li>由于直接内存在Java堆外, 因此它的大小不会直接受限于<code>-Xmx</code>指定的最大堆大小, 但是系统内存是有限的, Java堆和直接内存的总和依然受限于操作系统能给出的最大内存</li><li>直接内存的缺点:<ul><li>分配回收成本较高</li><li>不受JVM内存回收管理</li></ul></li><li>直接内存大小可以通过<code>-XX:MaxDirectMemorySize</code>设置</li><li>如果不指定, 默认与堆的最大值<code>-Xmx</code>参数值保持一致</li></ul><h3 id="2-10-Java内存状况分析"><a href="#2-10-Java内存状况分析" class="headerlink" title="2.10 Java内存状况分析"></a>2.10 Java内存状况分析</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jconsole</span></span><br><span class="line"><span class="attr">jvisualvm</span></span><br><span class="line"><span class="attr">jstat</span></span><br><span class="line"><span class="attr">jmap</span></span><br><span class="line"><span class="attr">jProfiler</span></span><br></pre></td></tr></table></figure><h2 id="3-执行引擎"><a href="#3-执行引擎" class="headerlink" title="3 执行引擎"></a>3 执行引擎</h2><p>执行引擎是Java虚拟机核心的组成部分之一</p><p>“虚拟机”是一个相对于”物理机”的概念, 这两种机器都有代码执行的能力, 其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面的, 而虚拟机的执行引擎则是由软件自行实现的, 因此可以不受物理条件制约地定制指令集与执行引擎的结构体系, 能够执行那些不被硬件直接支持的指令集格式</p><p>JVM的主要任务是负责装载字节码到其内部, 但是字节码并不能够直接运行在操作系统上, 因为字节码指令并非等价于本地机器指令, 它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表以及其他辅助信息,而执行引擎(Execution Engine)的主要任务就是<strong>将字节码指令解释&#x2F;编译为对应平台上的本地机器指令才可以</strong>, JVM中的执行引擎充当了将高级语言翻译为机器语言的译者</p><h3 id="3-1-执行引擎的工作过程"><a href="#3-1-执行引擎的工作过程" class="headerlink" title="3.1 执行引擎的工作过程"></a>3.1 执行引擎的工作过程</h3><ul><li>执行引擎在执行过程中执行的字节码指令完全依赖于PC寄存器</li><li>每当执行完一项指令操作后, PC寄存器就会更新下一条需要被执行的指令地址</li><li>当然方法在执行的过程中, 执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到储存在Java堆中的对象实例信息, 以及通过对象头中的元数据指针定位到目标对象的类型信息</li><li>所有的Java虚拟机的执行引擎输入、输出都是一致的: 输入的是字节码二进制流, 处理过程是字节码解析执行的等效过程, 输出的是执行结果</li></ul><h3 id="3-2-Java代码编译和执行过程"><a href="#3-2-Java代码编译和执行过程" class="headerlink" title="3.2 Java代码编译和执行过程"></a>3.2 Java代码编译和执行过程</h3><ul><li>解释器(Interpreter): 当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方法执行, 将每条字节码文件中的内容”翻译”为对应平台的本地机器指令执行</li><li>JIT(Just In Time Compile) 编译器: 就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言</li><li>Java是半编译半解释型的语言。之前Java仅有解释执行, 后来Java也发展出可以直接生成本地代码的编译器。现在JVM在执行Java代码的时候, 通常都会将解释执行和编译执行二者结合起来进行</li></ul><h3 id="3-3-指令-amp-汇编"><a href="#3-3-指令-amp-汇编" class="headerlink" title="3.3 指令&amp;汇编"></a>3.3 指令&amp;汇编</h3><h4 id="3-3-1-指令"><a href="#3-3-1-指令" class="headerlink" title="3.3.1 指令"></a>3.3.1 指令</h4><p>指令就是把机器码特定的0和1序列, 简化成对应的指令, 由于不同的硬件平台, 执行同一个操作, 对应的机器码可能不同, 所以不同的硬件平台的同一种指令(比如mov), 对应的机器码也可能不同</p><h4 id="3-3-2-指令集"><a href="#3-3-2-指令集" class="headerlink" title="3.3.2 指令集"></a>3.3.2 指令集</h4><p>不同的硬件平台,各自支持的指令是有差别的,因此每个平台所支持的指令称之为对应平台的指令集</p><h4 id="3-3-3-汇编语言"><a href="#3-3-3-汇编语言" class="headerlink" title="3.3.3 汇编语言"></a>3.3.3 汇编语言</h4><ul><li>由于指令的可读性还是太差,于是产了汇编语言</li><li>在汇编语言中,使用助记符(Mnemonics)代替机器指令的操作码,用地址符号(Symbol)或者标号(Label)代替指令或者操作数的地址</li><li>在不同的硬件平台,汇编语言对应着不同的机器语言指令集,通过汇编过程转换成机器指令(由于计算机只认识指令码,所以用汇编语言编写的程序还必须翻译成机器指令码,计算机才能识别和识别)</li></ul><h3 id="3-4-JIT编译器"><a href="#3-4-JIT编译器" class="headerlink" title="3.4 JIT编译器"></a>3.4 JIT编译器</h3><p>HotSpot VM是目前市面上高性能虚拟机的代表作之一,它采用解释器与即时编译器并存的架构。在Java VM运行的时候,解释器和即时编译器能够相互协作,各自取长补短,尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间</p><p>JRocket VM内部就不含解释器, 字节码全部都依靠即时编译器编译后执行(这就是为什么JRocket VM速度很快的原因)</p><p>为什么JIT编译这么快,HotSpot VM仍然使用解释器呢?</p><ul><li><p>当程序启动后,解释器可以马上发挥作用,省去了编译的时间,立即执行。而编译器要想发挥作用,把代码编译成本地代码,需要一定的执行时间,但编译为本地代码,执行效率高</p></li><li><p>所以尽管JRocket VM中程序的执行性能会非常高效,但是在程序启动时必然需要花费更长的时间来进行编译。对于服务端应用来说,启动并非是关注点,但是对于那些看重启动时间的应用场景而言,或许就需要采用解释器与即时编译并存的架构来换取一个平衡点。在此模式下,<strong>当Java虚拟机启动时,解释器可以首先发挥作用,而不必等待即时编译器全部编译完成后再执行,这样可以省去许多不必要的编译时间。随着时间的推移,编译器发挥作用,把越来越多的代码编译成本地代码,获得更高的执行效率</strong></p></li></ul><p>Java语言的”编译期”其实是一段”不确定”的操作过程,因为它可能是指一个<strong>前端编译器</strong>——把.java文件转变为.class文件的过程,也可能指虚拟机的<strong>后端运行期编译器</strong>(JIT编译器, Just In Time Compiler)把字节码转变为机器码的过程,还可能是指使用<strong>静态提前编译器</strong>(AOT编译器  Ahead of Time Compiler)直接把.java文件编译为本地机器代码的过程</p><p>JIT编译器: HotSpot VM的 C1、 C2编译器</p><p>AOT编译器: GNU Compiler for Java(GCJ)、 Excelsior JET</p><h4 id="3-4-1-热点代码及探测方式"><a href="#3-4-1-热点代码及探测方式" class="headerlink" title="3.4.1 热点代码及探测方式"></a>3.4.1 热点代码及探测方式</h4><p>是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令,则需要根据代码被调用执行频率而定。那些需要被编译为本地代码的字节码,也被称之为”热点代码”,JIT编译器在运行时会针对那些频繁被调用的”热点代码”, JIT编译器在运行时会针对那些频繁被调用的”热点代码”做出深度优化,将其直接编译为对应平台德玩本地机器指令,以此提升Java程序执行性能</p><ul><li>一个被多次调用的方法,或者是一个方法体内部循环次数较多的循环体都可以被称之为”热点代码”,因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中,因此也被称为栈上替换,简称为OSR(On Stack Replacement)编译</li><li>HotSpot VM采用的热点探测方式是基于计数器的热点探测</li><li>采用基于计数器的热点探测,HotSpot VM将会为每一个方法都建立2个不同类型的计数器,分别为方法调用计数器(Invocation Counter)和回边计数器(Back Edge)<ul><li>方法调用计数器用于统计方法的调用次数</li><li>回边计数器则用于统计循环体执行的循环次数</li></ul></li><li>方法调用计数器</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 热度衰减</span></span><br><span class="line"><span class="attr">-</span> <span class="string">这个计数器就用于统计方法被调用的次数, 它的默认阈值在Client模式下是1500次, 在Server模式下是10000次。超过这个阈值就会触发JIT编译</span></span><br><span class="line"><span class="attr">-</span> <span class="string">这个阈值可以通过虚拟机参数 -XX:CompileThreshold来设置</span></span><br><span class="line"><span class="attr">-</span> <span class="string">当一个方法被调用时,会检查该方法是否存在被JIT编译过的版本,如果存在,则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本,则将此方法的调用计数器值加1,然后判断方法调用计数器与回边计数器之和是否超过方法调用计数器的阈值。如果已超过阈值,那么将会向即时编译器提交一个该方法的代码编译请求</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-</span> <span class="string">如果不做任何设置,方法调用计数器统计的并不是方法被调用的绝对次数,而是一个相对的执行频率,即一段时间之内方法被调用的次数,当超过一定的时间限度,如果方法的调用次数仍然不足以让它提交给即时编译器编译,那么这个方法的调用计数器就会被减少一半,这个过程称之为方法调用计数器热度的衰减(Counter Decay),而这段时间就称为此方法统计的半衰周期(Counter Half Life Time)</span></span><br><span class="line"><span class="attr">-</span> <span class="string">进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的,可以使用虚拟机参数-XX:-UseCounterDecay来关闭热度衰减, 让方法统计器统计方法调用的绝对次数,这样,只要系统运行时间足够长,绝大部分方法都会被编译成本地代码</span></span><br><span class="line"><span class="attr">-</span> <span class="string">可以使用 -XX:CounterHalfLifeTime参数设置半衰周期的时间(s)</span></span><br></pre></td></tr></table></figure><ul><li>回边计数器: 它的作用是统计一个方法中循环体代码执行的次数,在字节码中遇到控制流向跳转的指令称为”回边”(Back Edge)。建立回边计数器的目的就是为了触发OSR编译</li></ul><h3 id="3-5-执行模式-amp-C1、C2编译器"><a href="#3-5-执行模式-amp-C1、C2编译器" class="headerlink" title="3.5 执行模式 &amp; C1、C2编译器"></a>3.5 执行模式 &amp; C1、C2编译器</h3><h4 id="3-5-1-设置HotSpot的执行模式"><a href="#3-5-1-设置HotSpot的执行模式" class="headerlink" title="3.5.1 设置HotSpot的执行模式"></a>3.5.1 设置HotSpot的执行模式</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启解释执行模式</span></span><br><span class="line"><span class="attr">java</span> <span class="string">-Xint -version</span></span><br><span class="line"><span class="comment"># 开启编译执行模式</span></span><br><span class="line"><span class="attr">java</span> <span class="string">-Xcomp -version</span></span><br></pre></td></tr></table></figure><h4 id="3-5-2-HotSpot-VM中JIT分类"><a href="#3-5-2-HotSpot-VM中JIT分类" class="headerlink" title="3.5.2 HotSpot VM中JIT分类"></a>3.5.2 HotSpot VM中JIT分类</h4><p>在HotSpot VM中内嵌有两个JIT编译器, 分别为Client Compile和Server Compile, 但大多数情况下简称为C1编译器和C2编译器</p><ul><li>-client: 指定Java虚拟机运行在Client模式下, 并使用C1编译器(#C1编译器对字节码进行简单和可靠的优化, 耗时短, 以达到更快的编译速度)</li><li>-server: 指定Java虚拟机运行在Server模式下, 并使用C2编译器(#C2进行耗时较长的优化, 以及激进优化, 但优化的代码执行效率更高)</li></ul><h4 id="3-5-3-C1和C2编译器不同的优化策略"><a href="#3-5-3-C1和C2编译器不同的优化策略" class="headerlink" title="3.5.3 C1和C2编译器不同的优化策略"></a>3.5.3 C1和C2编译器不同的优化策略</h4><ul><li>C1编译器上主要有方法内联、去虚拟化、冗余消除</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-</span> <span class="string">方法内联: 将引用的函数代码编译到引用点处, 这样可以减少栈帧的生成, 减少参数传递以及跳转的过程</span></span><br><span class="line"><span class="attr">-</span> <span class="string">去虚拟化: 对唯一的实现类进行内联</span></span><br><span class="line"><span class="attr">-</span> <span class="string">冗余消除: 在运行期间把一些不会执行的代码折叠</span></span><br></pre></td></tr></table></figure><ul><li>C2的优化主要是在全局层面, 逃逸分析是优化的基础</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-</span> <span class="string">标量替换: 用标量值代替聚合对象的属性值</span></span><br><span class="line"><span class="attr">-</span> <span class="string">栈上分配: 对于未逃逸的对象分配空间在栈上而不是堆上</span></span><br><span class="line"><span class="attr">-</span> <span class="string">同步消除: 消除同步操作, 通常指synchronized</span></span><br></pre></td></tr></table></figure><p>一般来说,JIT编译出的机器码性能比解释器高,C2编译器启动时长比C1编译器慢,系统稳定执行后,C2编译器执行速度远远快于C1编译器</p><h3 id="3-6-Graal-amp-AOT编译器"><a href="#3-6-Graal-amp-AOT编译器" class="headerlink" title="3.6 Graal &amp; AOT编译器"></a>3.6 Graal &amp; AOT编译器</h3><p>自JDK10起, HotSpot加入了一个全新的即时编译器: Graal编译器</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 激活Graal的虚拟机参数</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler</span></span><br></pre></td></tr></table></figure><p>JDK9引入了AOT编译器(静态提前编译器, Ahead Of Compiler)</p><p>JDK9引入了实验性AOT编译工具jaotc 它借助了Graal编译器, 将所输入的Java类文件转换为机器码, 并存放至生成的动态共享库之中</p><p>所谓的AOT编译, 是与即使编译相对立的一个概念 即时编译是指在程序运行过程中将字节码转换为可在硬件上直接运行的机器码, 并部署至托管环境中的过程。 而AOT编译指的是在程序运行之前, 便将字节码转换为机器码的过程</p><p>优点: </p><ul><li>Java虚拟机加载已经预编译成二进制库,  可以直接运行,  不必等待即使编译器的预热</li></ul><p>缺点: </p><ul><li>破坏了Java一次编译, 到处运行的特点,必须为每个不同硬件、OS编译对应的发行包</li><li>降低了Java链接过程中的动态性, 加载的代码在编译期就必须全部已知</li><li>还需要持续优化中,最初只支持Linux x64 java base</li></ul><h2 id="4-String的基本特性"><a href="#4-String的基本特性" class="headerlink" title="4 String的基本特性"></a>4 String的基本特性</h2><ul><li>字符串常量池中是不会储存相同内容的字符串</li><li>字符串常量池存储在堆中(jdk8及其之后), 而jdk7及其之前是存储在永久代中</li><li>String 的String Pool是一个固定大小的Hashtable,如果放进String Pool的String非常多,就会造成Hash冲突严重,从而导致链表会很长,而链表很长会直接造成的影响就是当调用String.intern()时性能下降</li><li>可以使用<code>-XX:StingTableSize</code>设置StringTable的长度</li><li>uintx StringTableSize&#x3D;10 is outside the allowed range [ 128 … 16777216 ]</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认字符串常池的大小(JDK12)</span></span><br><span class="line"><span class="attr">jps</span></span><br><span class="line"><span class="attr">jinfo</span> <span class="string">-flag StringTableSize java进程id</span></span><br><span class="line"><span class="attr">&gt;&gt;&gt;</span> <span class="string">-XX:StringTableSize=65536</span></span><br></pre></td></tr></table></figure><p>Java语言规范里要求完全相同的字符串常量, 应该包含同样的Unicode字符序列(包含同一份码点序列的常量), 并且必须是指向同一个String类实例</p><h3 id="4-1-intern-的总结"><a href="#4-1-intern-的总结" class="headerlink" title="4.1 intern() 的总结"></a>4.1 intern() 的总结</h3><ul><li>JDK6中, 将这个字符串对象尝试放入到串池中。如果串池中没有,则并不会放入,返回已有的串池中对象的地址。如果没有会把此对象复制一份放入串池,并返回串池中的对象地址</li><li>JDK7起,将这个字符串对象尝试放入到串池。如果串池中有,则并不会放入。返回已有的串池中的对象地址。如果没有则会把对象的引用地址复制一份,放入串池,并返回串池中的引用地址</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -Xlog:gc* 代替 -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"># XX:+PrintStringTableStatistics打印字符串常量池中的统计信息</span></span><br><span class="line"><span class="attr">-Xms10m</span> <span class="string">-Xmx10m -XX:+PrintStringTableStatistics -Xlog:gc*</span></span><br></pre></td></tr></table></figure><h2 id="5-垃圾回收"><a href="#5-垃圾回收" class="headerlink" title="5 垃圾回收"></a>5 垃圾回收</h2><p>什么是垃圾?</p><p>垃圾是指在运行程序中没有任何指针指向的对象</p><h3 id="5-1-垃圾标记阶段"><a href="#5-1-垃圾标记阶段" class="headerlink" title="5.1 垃圾标记阶段"></a>5.1 垃圾标记阶段</h3><ul><li>在堆中存放着几乎所有的Java对象实例,在GC执行垃圾回收之前,首先需要区分出内存中哪些是存活对象,哪些是已经死亡的对象,只有被标记为已经死亡的对象,GC才会在执行垃圾回收时,释放掉其所占有的内存空间,因此这个过程可以成为垃圾回收阶段</li><li>当一个对象已经不再被任何的存活对象继续引用时,就可以宣告为已经死亡</li><li>判断对象存活一般有两种方式: 引用计数算法和可达性分析算法</li></ul><h4 id="5-1-1-引用计数算法-标记阶段"><a href="#5-1-1-引用计数算法-标记阶段" class="headerlink" title="5.1.1 引用计数算法(标记阶段)"></a>5.1.1 引用计数算法(标记阶段)</h4><ul><li>引用计数算法(Reference Counting)对每个对象保存一个整型的引用计数器属性,用于记录对象被引用的情况</li><li>优点: 实现简单,垃圾对象便于辨识; 判定效率高, 回收没有延迟性</li><li>缺点:<ul><li>它需要单独的字段储存计数器,这样的做法增加了储存开销</li><li>每次赋值都需要更新计数器,伴随着加法和减法操作,这增加了时间开销</li><li>引用计数器有一个严重的问题,即无法处理循环引用的情况,导致在Java的垃圾回收器中没有使用这类算法</li></ul></li></ul><h4 id="5-1-2-标记-清除算法-清除阶段"><a href="#5-1-2-标记-清除算法-清除阶段" class="headerlink" title="5.1.2 标记-清除算法(清除阶段)"></a>5.1.2 标记-清除算法(清除阶段)</h4><p>最早出现也是最基础的算法(Mark - Sweep) 于1960年由Lisp之父John McCarthy提出</p><p>分为两个阶段: 首先标记出需要回收的对象,在标记完成后,统一回收掉所有被标记的对象,也可以反过来,标记存活的对象,统一回收所有未被标记的对象 标记过程就是对象是否属于垃圾的判定过程</p><h4 id="5-1-3-可达性分析算法-根搜索算法、追踪性垃圾收集-标记阶段"><a href="#5-1-3-可达性分析算法-根搜索算法、追踪性垃圾收集-标记阶段" class="headerlink" title="5.1.3 可达性分析算法(根搜索算法、追踪性垃圾收集)(标记阶段)"></a>5.1.3 可达性分析算法(根搜索算法、追踪性垃圾收集)(标记阶段)</h4><ul><li>相对于引用计数算法而言,可达性分析算法不仅同样具备实现简单和执行高效等特点, 更重要的是该算法可以有效解决在引用计数算法中循环引用的问题,防止内存泄漏的发生</li></ul><h3 id="5-2-GC-Roots"><a href="#5-2-GC-Roots" class="headerlink" title="5.2 GC Roots"></a>5.2 GC Roots</h3><p>在Java语言中, GC Roots包括以下几类元素</p><ul><li>虚拟机栈中引用的对象: 各个线程被调用的方法中使用到的参数、局部变量、临时变量等</li><li>本地方法栈内JNI引用的对象</li><li>方法区中类静态属性引用的对象 比如Java类的引用类型静态变量</li><li>方法区中常量引用的对象 比如字符串常量池里的引用</li><li>所有被同步锁synchronized持有的对象</li><li>Java虚拟机内部的引用: 基本数据类型对应的Class对象,一些常驻的异常对象(NullPointerException、OutOfMemoryError), 系统类加载器</li><li>反映java虚拟机内部的JMXBean、JVM中注册的回调、本地代码缓存等</li><li>如果要使用可达性分析算法来判断内存是否可以回收, 那么分析工必须在一个能保障一致性的快照中进行 这点不满足的话分析结果的准确性就无法保证</li></ul><p>除了固定的GC Roots集合以外 还可以有其他对象临时性地加入 比如 分代收集和局部回收(Partial GC)</p><h3 id="5-3-对象的finalization机制"><a href="#5-3-对象的finalization机制" class="headerlink" title="5.3 对象的finalization机制"></a>5.3 对象的finalization机制</h3><p>Java语言提供了对象终止机制来允许开发人员提供对象被销毁之前的自定义处理逻辑</p><ul><li>当垃圾回收器发现没有引用指向一个对象 即垃圾回收此对象之前 总会先调用这个对象的finalize()方法</li><li>finalize()方法允许在子类中被重写 用于在对象被回收时进行资源释放</li></ul><p>永远不要主动调用某个对象的finalize()方法 应该交给垃圾回收机制调用</p><ul><li>在finalize()时可能会导致对象复活</li><li>finalize() 方法的执行时间是没有保障的 他完全由GC线程决定 极端情况下 若不发生GC 则finalize()方法将没有执行机会</li><li>一个糟糕的finalize()会严重影响GC的性能</li></ul><p>Java虚拟机中的对象可能的三种状态</p><ul><li>可触及的: 从根节点开始 可以到达这个对象</li><li>可复活的: 对象的所有引用都被释放 但是对象有可能在finalize()中复活</li><li>不可触及的: 对象的finalize()被调用 并且没有复活 那么就会进入不可触及状态 不可触及的对象不可能被复活 因为finalize()方法只会被调用一次</li></ul><p>一个无法触及的对象有可能在某一个条件下复活自己</p><p>判断一个对象是否可回收 至少要经历两次标记过程</p><ul><li>如果对象到GC Roots没有引用链 则进行第一次标记</li><li>进行筛选 判断此对象是否有必要执行finalize() 方法<ul><li>如果对象没有重写finalize方法 或者finalize方法已经被虚拟机调用过了 则虚拟机认为该对象没有必要执行finalize方法 此对象被判定为不可触及的</li><li>如果对象重写了finalize方法且还未执行过 那么 对象都被插入到F-Queue队列中: 由虚拟机自动创建的、低优先级的Finalizer线程触发其finalize方法执行</li><li>finalize方法是对象逃脱死亡的最后机会, 稍后GC会对F-Queue队列中的对象进行第二次标记 如果对象在finalize方法中与引用链上的任何一个对象建立了联系 那么在第二次标记时 对象会被移除”即将回收”集合 之后 若对象再次出现没有引用存在的情况 在这个情况下 finalize方法不会被再次调用 对象会直接变成不可触及的状态 也就是说 一个对象的finalize方法只会被调用一次</li></ul></li></ul><p>目前在JVM中比较常见的三种垃圾回收算法是标记清除算法(Mark-Sweep)、复制算法(Copying)、标记压缩算法(Mark-Compact)</p><h3 id="5-4-垃圾清除阶段"><a href="#5-4-垃圾清除阶段" class="headerlink" title="5.4 垃圾清除阶段"></a>5.4 垃圾清除阶段</h3><h4 id="5-4-1-标记清除算法-Mark-Sweep"><a href="#5-4-1-标记清除算法-Mark-Sweep" class="headerlink" title="5.4.1 标记清除算法(Mark-Sweep)"></a>5.4.1 标记清除算法(Mark-Sweep)</h4><p>执行过程: 当堆中的有效内存空间被耗尽时 就会停止整个程序(STW) 然后进行两项工作 第一项是标记 第二项则是清除</p><ul><li>标记: Collector从引用根节点开始遍历 标记所有被引用的对象 一般是在对象的Header中记录为可达对象 </li><li>清除: Collector对堆内存从头到尾进行线性的遍历 如果发现某个对象在其Header中没有标记为可达对象 则将其回收</li></ul><p>缺点: </p><ul><li>效率不算高</li><li>在进行GC的时候 需要停止整个应用程序</li><li>这种方式清理出来的空闲内存是不连续的, 产生内存碎片 需要维护一个空闲列表</li></ul><p>何为清除:</p><ul><li>所谓的清除并不是真的置空 而是把需要清除的对象地址保存在空闲的地址列表里 下次有新对象需要加载时 判断垃圾的位置空间是否够用 如果够用直接覆盖</li></ul><h4 id="5-4-2-复制算法-Copying"><a href="#5-4-2-复制算法-Copying" class="headerlink" title="5.4.2 复制算法(Copying)"></a>5.4.2 复制算法(Copying)</h4><p>核心思想</p><p>将活着的内存空间分为两块 每次只使用其中一块 在垃圾回收时将正在使用的内存中存活的对象赋值到未被使用的内存中 之后清除正在使用的内存块的所有对象 交换两个内存的角色 最后完成垃圾回收</p><p>优点</p><ul><li>没有标记和清除过程 实现简单 运行高效</li><li>可以保证空间的连续性 不会出现碎片问题</li></ul><p>缺点</p><ul><li>需要两倍的内存空间</li><li>对于G1这种拆分成大量region的GC 复制而不是移动 意味着GC需要维护region之间对象引用的关系 不管是内存占用或者是时间开销也不小</li></ul><p>如果系统中的非垃圾对象很多 那么复制算法会复制很多存活的对象 代价很大</p><p>应用场景</p><p>在新生代 对常规应用的垃圾回收 一次通常可以回收70%-99%的内存空间 回收性价比很高</p><h4 id="5-4-3-标记-压缩-标记-整理-Mark-Compact-算法"><a href="#5-4-3-标记-压缩-标记-整理-Mark-Compact-算法" class="headerlink" title="5.4.3 标记-压缩(标记-整理 Mark-Compact) 算法"></a>5.4.3 标记-压缩(标记-整理 Mark-Compact) 算法</h4><p>背景</p><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下 这种情况下新生代经常发生 但是在老年代中 更常见的情况是大部分对象都是存活对象 如果依然使用复制算法 由于存活对象较多 复制的成本也将很高 因此 基于老年代垃圾回收的特性 需要使用其他的算法</p><p>执行过程</p><p>第一阶段和标记清除-算法一样 从根节点开始标记所有被引用对象</p><p>第二阶段将所有的存活对象压缩到内存的一端 按顺序排放 之后清除边界外所有的空间</p><p>优点</p><ul><li>消除了标记-清除算法当中 内存区域分散的缺点  再给新对象分配内存时 JVM只需持有一个内存的起始地址即可</li><li>消除了复制算法中 内存减半的高额代价</li></ul><p>缺点</p><ul><li>从效率上来说 标记-整理算法要低于复制算法</li><li>移动对象的同时 如果对象被其他对象引用 则还需调整引用的地址</li><li>移动过程中 需要全程暂停用户应用程序(STW)</li></ul><table><thead><tr><th>&#x2F;</th><th>Mark-Sweep</th><th>Mark-Compact</th><th>Copying</th></tr></thead><tbody><tr><td>速度</td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td>空间开销</td><td>少(但会堆积碎片)</td><td>少(不堆积碎片)</td><td>通常需要存活对象的2倍大小(不堆积碎片)</td></tr><tr><td>移动对象</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><h3 id="5-5-分代收集算法"><a href="#5-5-分代收集算法" class="headerlink" title="5.5 分代收集算法"></a>5.5 分代收集算法</h3><h3 id="5-6-增量收集算法"><a href="#5-6-增量收集算法" class="headerlink" title="5.6 增量收集算法"></a>5.6 增量收集算法</h3><p>基本思想</p><p>如果一次将所有的垃圾进行处理 需要造成系统长时间的停顿 那么就可以让垃圾回收线程和应用程序交替执行 每次 垃圾回收只会收集一小片区域的内存空间 接着切换到应用程序线程 来回切换 直到垃圾回收完成</p><p>增量收集算法的基础仍然是传统的标记-清除和复制算法 增量收集算法通过对线程间冲突的妥善处理 允许垃圾收集线程以分阶段的方式完成标记、清理和复制工作</p><p>缺点</p><p>使用这种方式 由于在垃圾回收过程中 间断性地还执行了应用程序代码 所以能够减少系统的停顿时间 但是 因为线程切换和上下文转换的消耗 会使得垃圾回收的总体成本上升 造成系统的吞吐量的下降</p><h3 id="5-7-分区算法"><a href="#5-7-分区算法" class="headerlink" title="5.7 分区算法"></a>5.7 分区算法</h3><p>一般来说 在相同条件下 对空间越大 一次GC时需要的时间就越长 有关GC产生的停顿也越长 为了更好地控制GC产生的停顿时间 将一块大的内存区域分割成多个小块 根据目标的停顿时间 每次合理地回收若干个小区间 而不是整个堆空间 从而减少一次GC所产生地停顿</p><p>分代算法将按照对象的生命周期长短划分为两个部分 分区算法将整个堆空间划分成连续的不同小区间region</p><p>每一个小区间都独立使用、独立回收 这种算法的好处是可以控制一次回收多少个小区间</p><h3 id="5-8-System-gc"><a href="#5-8-System-gc" class="headerlink" title="5.8 System.gc()"></a>5.8 System.gc()</h3><p>在默认情况下 通过System.gc() 或者Runtime.getRuntime().gc()的调用 会显示触发Full GC 同时对老年代和新生代进行回收 尝试释放被丢弃对象占用的内存</p><p>然而System.gc() 无法保证对垃圾收集器的调用</p><h3 id="5-9-内存溢出"><a href="#5-9-内存溢出" class="headerlink" title="5.9 内存溢出"></a>5.9 内存溢出</h3><p>内存溢出(OOM): 没有内存空间 并且垃圾收集器也无法提供更过内存</p><p>在抛出OutOfMemoryError之前 通常垃圾回收器会被触发 当然也不是在任何情况下垃圾回收器都会被触发 当分配一个超大数组且超过堆的最大值时 JVM可以判断出垃圾回收器并不能解决这个问题 所以直接抛出OOM</p><h3 id="5-10-内存泄漏"><a href="#5-10-内存泄漏" class="headerlink" title="5.10 内存泄漏"></a>5.10 内存泄漏</h3><p>举例</p><ul><li>单例模式 单例的生命周期和应用程序是一样的 如果持有对外部对象的引用的话 那么这个对象是不能被回收的 会导致内存泄漏的产生</li><li>一些提供close的资源未关闭导致的内存泄漏 比如数据库连接 网络连接 或者io连接必须手动close</li></ul><h3 id="5-11-垃圾收集器"><a href="#5-11-垃圾收集器" class="headerlink" title="5.11 垃圾收集器"></a>5.11 垃圾收集器</h3><img src="https://cdn.qingweico.cn/blog/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg" alt="垃圾收集器" /><h4 id="5-11-1-Serial-收集器"><a href="#5-11-1-Serial-收集器" class="headerlink" title="5.11.1 Serial 收集器"></a>5.11.1 Serial 收集器</h4><p>一个单线程工作的收集器 </p><p>单线程的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作 更重要的是强调在它进行垃圾收集时 必须暂停其他所有工作的线程 直到它收集结束</p><h4 id="5-11-2-ParNew-收集器"><a href="#5-11-2-ParNew-收集器" class="headerlink" title="5.11.2 ParNew 收集器"></a>5.11.2 ParNew 收集器</h4><p>实质上是Serial 收集器的多线程并行版本 </p><h4 id="5-11-3-Parallel-Scavenge-收集器"><a href="#5-11-3-Parallel-Scavenge-收集器" class="headerlink" title="5.11.3 Parallel Scavenge 收集器"></a>5.11.3 Parallel Scavenge 收集器</h4><p>Parallel Scavenge也是一款新生代收集器 同样是基于标记-复制算法实现的收集器 也是能够并行收集的多线程收集器</p><p>Parallel Scavenge的特点是它的关注点和其他收集器不同 CMS等收集器的关注点是尽可能地缩短垃圾回收时用户线程的停顿时间 而Parallel Scavenge 收集器的目标则是达到一个可控的吞吐量(Throughput) 所谓的吞吐量就是运行用户代码的时间与处理器总消耗时间(运行用户代码时间 + 运行垃圾收集时间)的比值</p><h4 id="5-11-4-Serial-Old-收集器"><a href="#5-11-4-Serial-Old-收集器" class="headerlink" title="5.11.4 Serial Old 收集器"></a>5.11.4 Serial Old 收集器</h4><p>Serial Old 是Serial收集器的老年代版本 同样是一个单线程收集器 使用标记整理算法</p><p>这个收集器的主要意义也是供客户端模式下的HotSpot 虚拟机使用</p><p>如果在服务端模式下 也可能有两种用途</p><ul><li>一种是在JDK 5 以及之前的版本中与Parallel Scavenge 收集器搭配使用</li><li>另外一种就是作为 CMS收集器发生失败时的后备预案 在并发收集时发生Concurrent Mode Failure时使用</li></ul><h4 id="5-11-5-Parallel-Old-收集器"><a href="#5-11-5-Parallel-Old-收集器" class="headerlink" title="5.11.5 Parallel Old 收集器"></a>5.11.5 Parallel Old 收集器</h4><p>Parallel Old 是Parallel Scavenge 收集器的老年代版本 支持多线程并行收集 基于标记-整理算法实现</p><p>JDK6 时提供</p><h4 id="5-11-6-CMS-收集器"><a href="#5-11-6-CMS-收集器" class="headerlink" title="5.11.6 CMS 收集器"></a>5.11.6 CMS 收集器</h4><p>CMS(Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器</p><p>CMS 收集器基于标记-清除算法实现的 整个过程分为四个步骤</p><ul><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发清除</li></ul><p>初始标记和重新标记需要STW</p><p>初始标记仅仅只是标记一下GC Roots能直接关联到的对象 速度很快</p><p>并发标记阶段就是从GC Roots直接关联的对象开始遍历整个对象图的过程</p><h4 id="5-11-7-Garbage-First-收集器"><a href="#5-11-7-Garbage-First-收集器" class="headerlink" title="5.11.7 Garbage First 收集器"></a>5.11.7 Garbage First 收集器</h4><p>简称G1 收集器是垃圾收集器技术发展历史上的里程碑式的成果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Deep-understanding-of-the-Java-Virtual-Machine&quot;&gt;&lt;a href=&quot;#Deep-understanding-of-the-Java-Virtual-Machine&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    <category term="JVM" scheme="http://example.com/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>nginx安装</title>
    <link href="http://example.com/2020/04/12/nginx%E5%AE%89%E8%A3%85/"/>
    <id>http://example.com/2020/04/12/nginx%E5%AE%89%E8%A3%85/</id>
    <published>2020-04-12T06:21:23.000Z</published>
    <updated>2020-04-12T06:21:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>[TOC]</p><h2 id="安装wget"><a href="#安装wget" class="headerlink" title="安装wget"></a>安装wget</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">centos 7.x</span></span><br><span class="line">yum -y install wget</span><br></pre></td></tr></table></figure><h2 id="安装PCRE库"><a href="#安装PCRE库" class="headerlink" title="安装PCRE库"></a>安装PCRE库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/</span><br><span class="line">wget https://ftp.pcre.org/pub/pcre/pcre-8.00.tar.gz</span><br><span class="line">tar -zxvf pcre-8.00.tar.gz</span><br><span class="line">cd pcre-8.00</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="安装openSSL库"><a href="#安装openSSL库" class="headerlink" title="安装openSSL库"></a>安装openSSL库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/</span><br><span class="line">wget http://www.openssl.org/source/openssl-1.0.1j.tar.gz</span><br><span class="line">tar -zxvf openssl-1.0.1j.tar.gz</span><br><span class="line">cd openssl-1.0.1j</span><br><span class="line">./config</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h2 id="安装zlib库"><a href="#安装zlib库" class="headerlink" title="安装zlib库"></a>安装zlib库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/</span><br><span class="line">wget http://zlib.net/zlib-1.2.11.tar.gz</span><br><span class="line">tar -zxvf zlib-1.2.11.tar.gz</span><br><span class="line">cd zlib-1.2.11</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 也可以直接yum安装以上内容</span></span><br><span class="line"><span class="comment"># yum -y install make zlib-devel gcc-c++ libtool openssl openssl-devel</span></span><br></pre></td></tr></table></figure><h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/</span><br><span class="line">wget http://nginx.org/download/nginx-1.18.0.tar.gz</span><br><span class="line">tar -zxvf nginx-1.18.0.tar.gz</span><br><span class="line">cd nginx-1.18.0</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">ln</span> -s /lib64/libpcre.so.1.2.0 /lib64/libpcre.so.0</span></span><br></pre></td></tr></table></figure><h2 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">./nginx</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;安装wget&quot;&gt;&lt;a href=&quot;#安装wget&quot; class=&quot;headerlink&quot; title=&quot;安装wget&quot;&gt;&lt;/a&gt;安装wget&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;language-bash&quot;&gt;centos 7.x&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum -y install wget&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;安装PCRE库&quot;&gt;&lt;a href=&quot;#安装PCRE库&quot; class=&quot;headerlink&quot; title=&quot;安装PCRE库&quot;&gt;&lt;/a&gt;安装PCRE库&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd /usr/local/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wget https://ftp.pcre.org/pub/pcre/pcre-8.00.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tar -zxvf pcre-8.00.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd pcre-8.00&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;./configure&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;make &amp;amp;&amp;amp; make install&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Nginx" scheme="http://example.com/categories/Nginx/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="http://example.com/2020/04/10/Linux/"/>
    <id>http://example.com/2020/04/10/Linux/</id>
    <published>2020-04-10T04:12:05.000Z</published>
    <updated>2021-07-06T10:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>[TOC]</p><h2 id="UNIX发展史"><a href="#UNIX发展史" class="headerlink" title="UNIX发展史"></a>UNIX发展史</h2><ul><li>1969年 美国贝尔实验室的肯.汤姆森(Ken Thompson)在PDP-机器上开发出了UNIX系统</li><li>1971年 Dennis M.Ritchie(丹尼斯.里奇)发明了C语言 与ken Thompson一起开发UNIX系统 </li><li>1973年 UNIX大部分的源码用C语言重写,因此提高了UNIX系统的可移植性</li></ul><h2 id="Linux发展史"><a href="#Linux发展史" class="headerlink" title="Linux发展史"></a>Linux发展史</h2><p>   Linux系统诞生于1993年,由芬兰大学生李纳斯(Linus Torvalds)和后来陆续加入的众多的爱好者共同开发完成。<br>   Linux是开源软件,源代码开放的UnIX</p><span id="more"></span><h2 id="支撑互联网的开源技术-LAMP"><a href="#支撑互联网的开源技术-LAMP" class="headerlink" title="支撑互联网的开源技术(LAMP)"></a>支撑互联网的开源技术(LAMP)</h2><ul><li>LINUX  操作系统</li><li>Apache Web操作系统 </li><li>MySQL  数据库     </li><li>PHP    编程语言</li></ul><hr><h2 id="nano编辑器"><a href="#nano编辑器" class="headerlink" title="nano编辑器"></a>nano编辑器</h2><h2 id="vi-和vim模式的切换"><a href="#vi-和vim模式的切换" class="headerlink" title="vi 和vim模式的切换"></a>vi 和vim模式的切换</h2><p>命令行下输入  <code>vim</code>  文件名     进入一般模式(正常模式) 可以创建新文件也可以修改已有文件</p><p>正常模式下输入i或者a或者o进入编辑模式 退出编辑模式使用<code>ESC</code></p><p>正常模式下输入<code>:</code>或<code>/</code>进入命令行模式 ,退出命令行模式使用<code>ESC</code></p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p><code>:set numer/nu</code>  设置行号</p><p><code>:set nonu</code> 取消行号</p><p><code>a</code> 在光标所在字符后插入</p><p><code>A</code> 在光标所在行尾插入</p><p><code>i</code> 在光标所在字符前插入</p><p><code>I</code> 在光标所在行首插入</p><p><code>o</code> 在光标下插入新行</p><p><code>O</code> 在光标上插入新行</p><p><code>gg</code>到文件的第一行</p><p><code>G</code>到文件的最后一行</p><p><code>nG</code> 到文件的第n行</p><p><code>:n</code> 到文件的第n行</p><p><code>0</code> 移动到行首</p><p><code>$</code>移动到行尾</p><hr><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><code>x</code> 删除光标所在处的字符</p><p><code>nx</code> 删除光标所在处后的n个字符</p><p><code>dd</code>删除光标所在行</p><p><code>ndd</code>删除n行</p><p><code>dG</code>删除光标到行尾的所有的内容</p><p><code>D</code>删除光标所在处到该行行尾所在行的所有内容</p><p><code>:n1,n2d</code>删除n1到n2的行所有内容</p><hr><h3 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h3><p><code>yy</code> 复制当前行的内容</p><p><code>nyy</code> 复制当前以下的n行</p><p><code>dd</code> 剪切当前行</p><p><code>ndd</code> 剪切当前以下的n行</p><p><code>p</code> 粘贴在当前光标的下一行</p><p><em><strong>P</strong></em>:粘贴在当前光标的上一行</p><hr><h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><p>在命令行模式下 <code>:wq</code>  保存当前内容并且退出      <code>:q!</code>     不保存当前内容且强制退出  <code>:q</code> 是不做任何修改时,退出。若做了修改,需要使用<code>:q!</code> 才可以强制退出</p><p><code>ZZ</code>相当于<code>:wq</code> 保存修改并退出</p><p><code>:w</code> 保存修改不退出</p><p><code>:w 指定的目录文件</code> 另存为指定文件</p><p><code>:wq!</code> 文件的所有者以及root可以使用</p><p>(带有:的是在命令行模式下,其他都在正常模式下进行,都需要退出插入模式)</p><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p><code>R </code> 从光标开始处开始进行字符替换,esc结束</p><p><code>u</code> 取消上一次操作</p><p><code>/string</code> 搜索指定的字符串   <code>:set ic</code>  搜索时忽略大小写  <code>n</code> 搜索结果向下翻</p><p><code>%s/替换的目标/替换的值/g</code>   全文替换指定的字符串   <code>g</code> 询问提示  <code>c</code> 不询问提示</p><p><code>8,16s/替换目标/替换的值/g</code>    在8到16行内替换指定的字符串</p><h3 id="为vim定义快捷键"><a href="#为vim定义快捷键" class="headerlink" title="为vim定义快捷键"></a>为vim定义快捷键</h3><p><code>:map Ctrl V Ctrl P I#&lt;ESC&gt; </code>      <em><strong>Ctrl P</strong></em> 为光标所在行加上注释并退出</p><p><code>:map Ctrl V Ctrl B  0x</code>           <em><strong>Ctrl B</strong></em>      去掉本行的注释 </p><h3 id="导入命令"><a href="#导入命令" class="headerlink" title="导入命令"></a>导入命令</h3><p><code>:r 文件目录</code>                将文件的内容导入此vim编辑器中  </p><p><code>:r !命令</code>                     将命令的结果导入vim编辑器中</p><hr><h2 id="关机重启"><a href="#关机重启" class="headerlink" title="关机重启"></a>关机重启</h2><p><code>shutdown -h now</code> 立即关机</p><p><code>halt</code> 立即关机</p><p><code>shutdown -h 1</code> 一分钟后关机</p><p><code>reboot</code>  立即重启</p><p><code>shutdown -r now</code> 立即重启</p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p> 创建用户:  <code>useradd 用户名</code>    (此时默认的分组名是用户名)</p><p> 设定密码  : <code>passwd 用户名 </code>  </p><p> 指定组名 : <code>useradd -d 组名 用户名</code> </p><p><code>who</code> : 查看用户登陆信息</p><p><img src="https://cdn.qingweico.cn/blog/5ef2e89f14195aa594bff21f.png" alt="1588911447007"></p><p>第一个root 代表服务器启动时root登陆</p><p>第二个root代表远程登陆(XShell)</p><p>第三个root代表服务器启用终端登陆</p><p>:0代表本地登陆</p><p>pts代表远程登陆 使用不同的数字区分不同的远程终端</p><p><code>w</code> :查看用户登陆的详细信息</p><p><img src="https://cdn.qingweico.cn/blog/5ef2e89f14195aa594bff221.png" alt="1588911970296"></p><p><code>uptime</code> 查看用户登陆一些基本信息</p><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p><code>userdel 用户名</code> </p><h3 id="查询用户信息"><a href="#查询用户信息" class="headerlink" title="查询用户信息"></a>查询用户信息</h3><p><code>id 用户名</code>  </p><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><p><code>su - 用户名</code> </p><p>高权限用户向普通用户切换时不需要密码 反之则需要</p><p><code>exit</code> 返回之前用户</p><h3 id="创建组"><a href="#创建组" class="headerlink" title="创建组"></a>创建组</h3><p><code>groupadd  组名</code></p><p><code>useradd - g 组名 用户名</code> :将用户分配到指定的组中</p><p><code>-d</code> 和<code>-g</code>给用户分配组名的区别: 前者给用户创建一个之前不存在的组名,后者给用户分配已经创建完成的组</p><h3 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h3><p><code>groupdel 组名 </code> </p><h3 id="更换用户所在组"><a href="#更换用户所在组" class="headerlink" title="更换用户所在组"></a>更换用户所在组</h3><p><code>usermod -g :新的组名 用户</code></p><h3 id="用户和组的相关的文件"><a href="#用户和组的相关的文件" class="headerlink" title="用户和组的相关的文件"></a>用户和组的相关的文件</h3><p><code>/etc/passwd</code> : 用户的配置文件 记录用户的各种信息</p><p><code>/etc/shadow</code> : 口令的配置文件</p><p><code>/etx/group</code> : 组的配置文件 记录linux包含组的信息</p><h2 id="Linux运行级别"><a href="#Linux运行级别" class="headerlink" title="Linux运行级别"></a>Linux运行级别</h2><ul><li>0 系统停机状态  系统默认运行级别不能设置为0,否则不能正常启动</li><li>1 单用户工作状态,root权限,同于系统维护,禁止远程登陆</li><li>2 多用户状态(没有NFS),不支持网络</li><li>3 完全的多用户状态(有NFS),登陆后进入控制台命令模式</li><li>4 系统未使用,保留</li><li>5 Xll控制台,登陆后进入图形GUI模式</li><li>6 系统正常关闭并重启。默认级别不能设为6,否则不能正常启动</li></ul><p><code>runlevel</code> :查看当前运行级别</p><h2 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h2><p><code>man [指令] /配置文件 </code>  查看命令或者配置文件的帮助信息,当查看配置文件时不用加配置文件的绝对路径 ,直接加配置文件名即可 </p><p><code>whatis 命令 </code>   查询命令的简单介绍</p><p><code>apropos 配置文件</code>  查询配置文件信息</p><p><code>命令 --help</code> 获取命令的主要的信息</p><p><code>info 命令</code> 和man差不多   </p><p><code>help 命令</code> 查看linux内置的命令  </p><h2 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h2><p><code>usr</code> : unix system resource</p><p><code>var</code> : Variable Data File 存储运行时数据</p><p><code>dev</code> : echo “…” &gt; &#x2F;dev&#x2F;null 可以向其中写入任何东西(好比垃圾桶)</p><h3 id="文件目录类"><a href="#文件目录类" class="headerlink" title="文件目录类"></a>文件目录类</h3><p><code>pwd</code>:  显示当前工作目录的绝对路径</p><p><code>ls [选项] 【文件或目录】</code></p><p>选项包括 <code>a</code>, <code>l</code></p><p><code>ls -l</code> : 表示以列表的形式显示当前目录下所有的文件</p><p><code>ls -a</code> 表示显示当前目录下所有的文件包括隐藏的文件或文件夹</p><p><code>ls -d</code> 显示当前目录的信息</p><p><code>ls -F</code> 查看文件的类型</p><h4 id="创建目录和删除"><a href="#创建目录和删除" class="headerlink" title="创建目录和删除"></a>创建目录和删除</h4><p><code>mkdir 目录名     </code>     创建一层目录</p><p><code>mkdir -p 目录名</code> 创建多级目录</p><p><code>rmdir 目录名</code>  删除空的目录</p><p><code>rm -rf 目录名 </code> 删除不为空的目录</p><h4 id="创建空的文件"><a href="#创建空的文件" class="headerlink" title="创建空的文件"></a>创建空的文件</h4><p>man touch:  touch - change file timestamps</p><p>确实tocuh的作用是改变文件的时间戳 如果没有则创建文件</p><p><code>touch 文件名</code> </p><h4 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h4><p><code>scp file_source file_target</code> 用于Linux之间复制文件和目录</p><p>eg: <code>scp local_file remote_username@remote_ip:remote_folder </code> 从本地复制到远程</p><p><code>cp resource target</code>   将resource复制到目标目录下</p><p><code>cp -r resouce taget</code> 使用递归将文件夹下所以的文件全部复制到目标目录下</p><p><code>\cp -r resouce taget</code> 强制覆盖以存在的文件</p><p><code>cp -p</code> 保存文件的原有属性</p><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p><code>rm 【选项】文件名或目录名</code></p><p>选项 :<code>-r</code> 删除整个目录   <code>-f</code> 强制删除没有提示信息 </p><p><code>mv</code> 重命名文件或者移动文件</p><p>当在同一个目录下移动文件就是重命名  <code>mv oldFileName newFileName</code></p><p>当前后目录不同时就是移动文件夹  <code>mv oldFileName /root/</code>;将oldFileName移动到root目录下  </p><h4 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h4><p>cat用于连接文件并打印到标准输出设备上</p><p>查看日志文件不要使用cat 如果日志文件过大会卡死 应该使用less命令</p><p><code>cat 【选项】文件名 | more </code>  :只读的方式 | 分页的形式查看文件  选项为 <code>-n</code>: 可以显示行号 </p><p>more指令</p><p><code>more 文件</code> :分页的形式查看文件</p><p><code>enter</code> :一行一行看</p><p><code>空格</code> 一页一页查看</p><p><code>ctrl+B</code> : 查看上一页</p><p><code>ctrl+f或f</code> 查看下一页</p><p><code>q或Q</code> 立即离开文件内容</p><p><code>=</code> 显示当前的行号</p><p><code>:f</code> 显示文件名和当前的行号</p><p>less指令</p><p><code>less 文件</code>  方便查看大型文件 ,一次只加载一页 </p><p><code>enter</code> 一次查看一行</p><p><code>空格</code> 一次查看一页</p><p><code>上箭头</code> :向上翻页</p><p><code>下箭头</code> 向下翻页</p><p><code>q</code> 退出该文件</p><p><code>/字符串</code> 向下查找字符串  <code>n </code> 向下查找 <code>N</code> 向上查找</p><p><code>?字符 </code>串 向上查找字符 <code>n</code> 向上查找 <code>N</code> 向下查找</p><h4 id="gt-和-gt-gt-指令"><a href="#gt-和-gt-gt-指令" class="headerlink" title=" &gt; 和 &gt;&gt; 指令"></a><code> &gt;</code> 和 <code>&gt;&gt;</code> 指令</h4><p><code>文件 &gt;</code> 文件  覆盖写     指令的意思是将左边的文件写入到右边的文件中 若右边的文件不存在则创建 存在则覆盖</p><p><code>文件 &gt;&gt; 文件</code> 追加写</p><p><code>ls -l &gt; 文件</code> 将当前目录下的文件列表写入到文件中</p><p><code>cat 文件1 &gt; 文件2</code> 将文件1的内容覆盖写到文件2  (  &gt;&gt; 追加写入)</p><p><code>echo &quot;内容&quot; &gt; 文件</code> 将内容覆盖写入文件中   ( &gt;&gt; 追加写入)</p><h4 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h4><p><code>echo  输入内容</code> : <code>echo $PATH</code> 输入环境变量</p><p><code>echo hello</code> 向控制台输入hello</p><h4 id="head-amp-tail"><a href="#head-amp-tail" class="headerlink" title="head&amp;tail"></a>head&amp;tail</h4><p><code>head 文件 </code>             查看文件的前(默认)10行</p><p><code>head -n N 文件</code>  查看文件的前N行</p><p><code>tail 文件</code>            查看文件的后(默认)10行</p><p><code>tail -n M 文件</code>  查看文件的后M行</p><p><code>tail -f  文件</code>    实时追踪该文档的所有更新, 工作中很常用   </p><h4 id="ln指令-软连接"><a href="#ln指令-软连接" class="headerlink" title="ln指令 (软连接)"></a>ln指令 (软连接)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /root linkToRoot  <span class="comment"># 将linkToRoot链接到root目录下</span></span><br><span class="line"><span class="built_in">ln</span>  /root/hard  /root/hard/linkHard   <span class="comment"># 硬连接  可以做到数据的同步更新且硬连接的inode和源文件相同,但是硬连接不能对目录使用且不可以跨分区</span></span><br></pre></td></tr></table></figure><p>当我们使用pwd查看绝对路径时仍然是当前路径</p><p><code>rm - rm linkToRoot</code> 删除软链接</p><h4 id="alias指令"><a href="#alias指令" class="headerlink" title="alias指令"></a>alias指令</h4><p><code>alias</code> : 列出目前所有的别名</p><p>给命令设置别名(服务器重启后该设置失效): alias croot&#x3D;cd &#x2F;root</p><p>通过修改配置文件的方式(永久生效)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">.bashrc</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">User specific aliases and <span class="built_in">functions</span></span></span><br><span class="line"></span><br><span class="line">alias rm=&#x27;rm -i&#x27;</span><br><span class="line">alias cp=&#x27;cp -i&#x27;</span><br><span class="line">alias mv=&#x27;mv -i&#x27;</span><br><span class="line">alias croot=&#x27;cd /root&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Source global definitions</span></span><br><span class="line">if [ -f /etc/bashrc ]; then</span><br><span class="line">        . /etc/bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 让配置生效</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h4 id="history指令"><a href="#history指令" class="headerlink" title="history指令"></a>history指令</h4><p><code>history</code> 显示所有的历史命令</p><p><code>history M</code> 显示前M个历史指令</p><p><code>!N</code> 执行第N个历史指令</p><h3 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h3><h4 id="date指令"><a href="#date指令" class="headerlink" title="date指令"></a>date指令</h4><p><code>date</code> 显示当前的时间</p><p><code>date&quot;+%Y-%m-%d %H:%M:%S&quot;</code> 格式化日期显示时间  (+号不可省略)</p><p><code>date -s &quot;时间&quot;</code> 修改时间  </p><p><code>cal</code> 显示当前月份的日历</p><p><code>cal 年份</code> 显示一年的日历</p><p><code>timedatectl set-time 2018-01-03 23:00:00</code> 设置当前系统时间</p><h3 id="搜寻查找类"><a href="#搜寻查找类" class="headerlink" title="搜寻查找类"></a>搜寻查找类</h3><p><code>find 【目录】 查找类型 文件名</code>   </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find /home -name hello.txt  <span class="comment"># 查找home目录下文件名为hello.txt的文件</span></span><br><span class="line">* 匹配任何字符</span><br><span class="line">？匹配任意字符</span><br><span class="line">-iname 不区分大小写</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home -user admin <span class="comment"># 查找用户名为admin的文件</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -size +20M  <span class="comment"># 查找当前系统下大于20M的文件  -20M(小于20M的文件)   20M(等于20M的文件)  (M大写 k可以小写 不可以大写)</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find /etc -cmin -5;<span class="comment"># 在etc目录下查找5分钟内被修改过文件属性的文件和目录</span></span><br><span class="line">-amin  访问时间  access</span><br><span class="line">-cmin 文件属性   change</span><br><span class="line">-mmin 文件内容   modify</span><br></pre></td></tr></table></figure><p><code>-a</code> and   同时满足两个条件</p><p><code>-o</code> or     两个条件满足其中一个即可</p><p><code>-type 【选项】</code> 【选项】:<code>-f</code> 普通文件  <code>-d</code> 目录  <code>-l</code> 软连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /etc -size +20M -a -size -50M -<span class="built_in">type</span> f          <span class="comment"># 查找etc目录下文件大小在20M~50M之间的文件</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /etc -name *init* -<span class="built_in">exec</span> 执行操作命令 &#123;&#125; \;      <span class="comment"># 对搜索结果进行操作(严格区分空格)</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /etc -name *init* -ok 执行操作命令 &#123;&#125; \;        <span class="comment"># 带有询问</span></span><br></pre></td></tr></table></figure><p><em><img src="https://cdn.qingweico.cn/blog/5ef2e89f14195aa594bff21d.png" alt="1588829333905"></em></p><p>找到test目录下java的文件且带有询问的删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -inum inod号 -<span class="built_in">exec</span> <span class="built_in">rm</span> -rf &#123;&#125; \; <span class="comment"># 根据inode号来删除当前目录下的文件</span></span><br></pre></td></tr></table></figure><h4 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h4><p><code>locate 文件</code> 用于快速定位文件 基于数据库查找    不用遍历整个文件系统</p><p>刚创建的文件,需要使用命令<code>updatedb</code>更新数据库,才可以查找到该文件</p><p>在&#x2F;tmp中创建的文件不可以被locate找到</p><h4 id="grep和管道符"><a href="#grep和管道符" class="headerlink" title="grep和管道符"></a>grep和管道符</h4><p>管道是进程中通信的手段 也是一个文件 </p><p><code>mkfifo filename </code>创建一个管道文件</p><p><code>ls / | tee file | wc -l</code></p><p><code>grep</code> 过滤查找</p><p><code>grep password filename</code> 在文件中过滤查找</p><p><code>|</code>  将前一个命令查找的结果输出传递给后一个命令输入</p><p><code>cat hello.txt| grep -n hello</code>  查找hello.txt文件 并且在该文件中查找hello并显示所在的行号</p><p><code>-n </code> 显示行号</p><p><code>-i</code> 忽略大小写</p><p><code>-v 字符串</code> 排除指定的字符串  <code>^N</code>   以N开头的字符串 </p><h4 id="whereis-which"><a href="#whereis-which" class="headerlink" title="whereis  which"></a>whereis  which</h4><p><code>which</code> 用来查看命令的文件路径以及是否有别名</p><p><code>whereis</code> 用来查看命令所在的目录以及帮组文档的路径</p><h4 id="高阶查找"><a href="#高阶查找" class="headerlink" title="高阶查找"></a>高阶查找</h4><p>xargs  配合管道符一块使用</p><p>find 文件目录 -name “*.java” | xargs -I {} cat {} | wc -l 查看目录中以java结尾的文件中所有的行数</p><h3 id="解压和压缩类"><a href="#解压和压缩类" class="headerlink" title="解压和压缩类"></a>解压和压缩类</h3><p><code>gzip 文件</code> : 压缩    </p><p><code>gunzip 文件.gz</code> 解压(不常用)  使用<code>gzip</code>命令压缩文件时不会保留源文件且不可以对目录压缩</p><hr><p><code>zip 【选项】文件 压缩目录</code>              压缩        选项可以为 <code>-r</code> 递归压缩整个目录 文件是压缩后的文件名</p><p><code>unzip【选项】解压目录 文件</code>            解压        选项可以为<code>-d&lt;目录&gt;</code> 指定解压后存放的目录  文件是解压前的文件名</p><hr><p><code>tar </code>   打包的文件以.tar.gz结尾</p><p><code>c</code> :产生.tar打包文件</p><p><code>v</code> 显示详细信息</p><p><code>f</code> 指定打包的文件名</p><p><code>z</code> 打包同时压缩</p><p><code>x</code> 解压.tar文件</p><p><code>tar -zcvf 压缩后的文件名 目标文件名/目录</code>                                         压缩文件</p><p><code>tar -zxvf 将要解压的文件 解压到的目录</code>                                               解压文件</p><hr><p><code>bzip2</code> zip的升级班 增加了可以保留源文件的选项</p><p><code>bzip2 -k  源文件</code>  压缩文件并保留源文件</p><p><code>bunzip2 -k 压缩文件</code>  解压文件且保留压缩包</p><hr><p><code>tar -cjf 压缩后的文件名 源文件</code>  生成.tar.bz2的压缩文件</p><p><code>tar -xjf</code> 解压以.tar.bz2结尾的压缩文件</p><p><code>tar -tvf backup.tar </code> 查看tar文件的内容而不提取</p><p><code>tar -zxvf backup.tar -C /usr/local</code> 解压到其他目录</p><h3 id="排序类"><a href="#排序类" class="headerlink" title="排序类"></a>排序类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ip.txt,每行一条ip记录,共若干行,已排好序,统计出现次数最多的前3个ip及其次数</span></span><br><span class="line"><span class="built_in">uniq</span> -c ip.txt | <span class="built_in">sort</span> -nr | <span class="built_in">head</span> -n 3</span><br></pre></td></tr></table></figure><h2 id="Linux组管理"><a href="#Linux组管理" class="headerlink" title="Linux组管理"></a>Linux组管理</h2><h3 id="查看文件的所有者"><a href="#查看文件的所有者" class="headerlink" title="查看文件的所有者"></a>查看文件的所有者</h3><p><code>ls -ahl</code></p><h3 id="修改文件的所有者"><a href="#修改文件的所有者" class="headerlink" title="修改文件的所有者"></a>修改文件的所有者</h3><p><code>chown 用户名  文件名  </code>             改变单个文件的所有者</p><p><code>chown -R 用户名 文件目录名</code>  改变目录下的所有文件或目录(递归) 的所有者</p><h3 id="修改文件所在组"><a href="#修改文件所在组" class="headerlink" title="修改文件所在组"></a>修改文件所在组</h3><p><code>chgrp 新组名 文件名 </code>                     改变单个文件的所在组</p><p><code>chgrp -R 新组名 文件目录名</code>       改变目录下所有文件索目录的所在组</p><h3 id="改变用户所有组"><a href="#改变用户所有组" class="headerlink" title="改变用户所有组"></a>改变用户所有组</h3><p><code>usermod -g  新组名 用户名</code></p><h3 id="查看缺省文件创建的权限"><a href="#查看缺省文件创建的权限" class="headerlink" title="查看缺省文件创建的权限"></a>查看缺省文件创建的权限</h3><p><code>umask -S</code></p><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p><em><img src="https://cdn.qingweico.cn/blog/5ef2e89114195aa594bfed34.png" alt="1588306848988"></em></p><p><em><img src="https://cdn.qingweico.cn/blog/5ef2e89114195aa594bfed37.png" alt="1588307060227"></em></p><p>从左到右:</p><ul><li><p><code>d</code>  代表文件类型是目录  <code>-</code> 代表普通的文件 <code>l</code>  代表软连接  <code>c</code>  字符设备【键盘,鼠标】  <code>b</code>  块文件 硬盘</p></li><li><p><code>rwx</code>  表示文件所有者的权限  <code>r </code> 代表写的权限  <code>w</code> 代表读的权限  <code>x(execute)</code> 代表可执行的权限</p></li><li><p><code>r-x</code> 代表与文件拥有者同一组的用户所拥有的权限  可以写和执行但不能读</p></li><li><p><code>r-x</code> 代表不与文件拥有者同组的其他用户所拥有的权限 (以上3个一组  <code>-</code> 代表不具有该权限    <code>rwx</code> 可以用数字表示 <code>r</code> 等于4   <code>w</code>  等于2    <code>x</code>等于1)</p></li><li><p>3或者1  如果是文件 数字代表硬连接数目 如果是目录则代表该目录下的子目录数(不包括文件 包括隐藏目录)</p></li><li><p>root 代表文件的所有者</p></li><li><p>root 代表文件所在的组名</p></li><li><p>19    如果是文件 表示文件的大小(字节)   如果是目录 </p></li><li><p>时间代表最后一次修改的时间</p></li></ul><h3 id="rwx权限详解"><a href="#rwx权限详解" class="headerlink" title="rwx权限详解"></a>rwx权限详解</h3><p>rwx作用文件:</p><ul><li>r代表read 可以读取,查看</li><li>w代表write 可以修改,但是不代表可以删除该文件,删除一个文件的前提是要有对该文件有写的权限,才可以删除该文件</li><li>x代表可执行,可以被执行</li></ul><p>rwx作用目录</p><ul><li>r代表可读  ls可以查看目录内容</li><li>write代表可写 代表可以修改  在目录内创建-删除-重命名目录</li><li>x代表可以执行 可以进入该目录</li></ul><p><em><strong>删除一个目录下文件的关键不是该文件是否具有w(写)权限,而是该文件所在的目录是否具有w权限即对文件的创建,删除权限</strong></em></p><h3 id="修改权限-通过-x3D-变更权限"><a href="#修改权限-通过-x3D-变更权限" class="headerlink" title="修改权限 (通过 +  -  &#x3D;  变更权限)"></a>修改权限 (通过 +  -  &#x3D;  变更权限)</h3><p><code>u </code> 代表所有者 <code>g</code> 代表所有组 <code>o</code>代表其他人  <code>a</code> 代表所有人(u+g+o)</p><p><code>chmod u=rwx,g=rx,o=x  文件目录名</code>  将该文件的权限修改为 rwxr-x–x</p><p><code>chmod o+w 文件目录名</code>  增加其他人对该文件读的权限</p><p><code>chmod a-x </code> 移出所有人对该文件的执行权限</p><p><code>chmod -R</code> 遍历修改目录下所有文件或者目录的权限</p><h3 id="修改权限-通过数字变更权限"><a href="#修改权限-通过数字变更权限" class="headerlink" title="修改权限 (通过数字变更权限)"></a>修改权限 (通过数字变更权限)</h3><p><code>chmod  751  文件目录名</code>    7 &#x3D; <code>r+w+x</code>  5  &#x3D; <code>w+x</code>  1 &#x3D; <code>x</code></p><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>任务调度是指系统在某个时间执行特定的命令或者程序</p><p><code>crontab -e</code> 编辑定时任务的</p><p><code>crontab -l</code> 查询crontab的任务</p><p><code>crontab -r</code> 删除当前用户下所有的crontab任务</p><p><code>tail -f /var/log/cron</code> 查看定时任务的执行日志</p><p><code>*/1 * * * * ls-l &gt;/tmp/to.txt</code>:    每小时的每分钟执行<code>ls-l &gt;/tmp/to.txt </code>命令</p><h3 id="5个占位符说明"><a href="#5个占位符说明" class="headerlink" title="5个占位符说明"></a>5个占位符说明</h3><table><thead><tr><th>项目</th><th>含义</th><th>范围</th></tr></thead><tbody><tr><td>第一个*</td><td>一小时中的第几分钟</td><td>0-59</td></tr><tr><td>第二个*</td><td>一天的第几小时</td><td>0-23</td></tr><tr><td>第三个*</td><td>一月的第几天</td><td>1-31</td></tr><tr><td>第四个*</td><td>一年的第几个月</td><td>1-12</td></tr><tr><td>第五个*</td><td>一周的星期几</td><td>0-7(0和7都代表周日)</td></tr></tbody></table><h2 id="磁盘查询指令"><a href="#磁盘查询指令" class="headerlink" title="磁盘查询指令"></a>磁盘查询指令</h2><p><code>df- lh</code> : 查询系统整体磁盘使用的情况    </p><p><code>du-h /目录</code> : 查询指定目录的磁盘占用情况  默认为当前目录</p><ul><li>-s 指定目录占用大小总汇</li><li>-h带计量单位</li><li>-a含文件<ul><li>–max-depth&#x3D;1 子目录深度</li></ul></li><li>-c 列出明细的同时,增加汇总值</li></ul><h3 id="统计目录下文件的个数"><a href="#统计目录下文件的个数" class="headerlink" title="统计目录下文件的个数"></a>统计目录下文件的个数</h3><p><code>man wc </code> 查看wc命令的用法</p><p><code>ls -l /home |grep &quot;^-&quot;| wc -l</code> 统计home目录下文件的个数</p><h3 id="统计目录下目录的个数"><a href="#统计目录下目录的个数" class="headerlink" title="统计目录下目录的个数"></a>统计目录下目录的个数</h3><p><code>ls -l /home |grep &quot;^d&quot;| wc -l</code> 统计home目录下目录的个数</p><h3 id="统计目录下所有的文件个数-包括子文件"><a href="#统计目录下所有的文件个数-包括子文件" class="headerlink" title="统计目录下所有的文件个数(包括子文件)"></a>统计目录下所有的文件个数(包括子文件)</h3><p><code>ls -lR /home |grep &quot;^-&quot;| wc -l</code> 统计home目录下所有的文件个数</p><h3 id="统计目录下所有的目录个数-包括子目录"><a href="#统计目录下所有的目录个数-包括子目录" class="headerlink" title="统计目录下所有的目录个数(包括子目录)"></a>统计目录下所有的目录个数(包括子目录)</h3><p><code>ls -lR /home |grep &quot;^d&quot;| wc -l</code> 统计home目录下所有的目录个数</p><h2 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h2><p><code>ip</code></p><p><code>last</code> 查看目前和过去所有登陆过系统的用户的信息</p><p><code>lastlog -u 用户id号</code> 查看具体用户登陆的详细信息</p><p><code>traceroute 主机</code> 查看数据包到路径之间的路径   </p><p><code>netstat</code> 显示网络有关的信息</p><ul><li><code>-a</code> 显示所有选项 默认不显示LISTEN相关</li><li><code>-t</code> TCP协议</li><li><code>-u</code> UDP协议 UDP 是User Datagram Protocol的简称, 中文名是用户数据报协议</li><li><code>-l</code>  监听</li><li><code>-r</code> 路由</li><li><code>-n</code> 显示IP和端口号</li><li><code>-p</code> 显示建立相关链接的程序名</li></ul><p><code>netstat -ntlp</code> 查看本机监听的端口及应用名称</p><p><code>netstat -tlun</code> 查看本机监听的端口</p><p><code>netstat -an</code> 查看本机所有的网路连接</p><p><code>netstat -rn</code> 查看本机路由表</p><p><code>setup</code> 配置网络</p><p><code>mount</code> 挂载命令</p><p><code>tcpdump -nn -i eth0 port 80  </code> 对网络上的数据包进行截获的包分析工具</p><p><code>route -n</code> 显示和查看路由表  <code>-n</code>表示不解析名字</p><p><code>arp -n</code> 显示和修改ARP</p><p><code>dig</code></p><p><code>curl www.baidu.com -I</code> 查看http的头部信息</p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>在linux中 服务命令中带有d(daemon)表示后台进程 &gt;&gt; mysqld</p><p>ps命令是用来查看目录中,有哪些正在执行,以及他们执行的状况,可以不加任何参数</p><p><code>ps -a</code> : 显示当前终端所有进程信息</p><p><code>ps -u</code>: 以用户的格式显示进程</p><p><code>ps -x</code>: 显示后台进程运行的参数</p><p><img src="https://cdn.qingweico.cn/blog/5ef2e89114195aa594bfed39.png" alt="1588383393872"></p><ul><li>user:用户名</li><li>PID:进程的id</li><li>%CPU:进程占用CPU的百分比</li><li>%MEN:进程占用物理内存的百分比</li><li>VSZ:进程占用虚拟内存的大小(KB)</li><li>RSS:进程占用的物理内存大小(KB)</li><li>TTY:终端名称缩写</li><li>STAT:进程状态。S表示休眠  s表示该进程是会话的先到程序  N表示进程拥有比普通进程优先级更低的优先级   R表示正在运行 D表示短期等待 Z 表示僵死进程 T表示被跟踪或被停止</li><li>START:进程的启动时间</li><li>TIME:进程使用CPU的总时间</li><li>COMMAND:启动进程所用的命令和参数,如果过长会被截断显示</li></ul><h3 id="查看单个进程"><a href="#查看单个进程" class="headerlink" title="查看单个进程"></a>查看单个进程</h3><p><code>ps -aux | grep 单个进程的名称</code></p><p><code>ps -aux | grep 单个进程的名称| grep -v grep</code>: 过滤掉grep操作</p><h3 id="查看父进程"><a href="#查看父进程" class="headerlink" title="查看父进程"></a>查看父进程</h3><p><code>ps -ef</code>: 以全格式显示当前所有的进程,查看进程的父进程 <code>-e</code>:显示所有进程 <code>-f</code> :全格式</p><p><img src="https://cdn.qingweico.cn/blog/5ef2e89114195aa594bfed3b.png" alt="1588384476648"></p><ul><li>UID: 用户ID</li><li>PID: 进程ID</li><li>PPID: 父进程ID</li><li>C: CPU用于计算执行优先级的因子。数值越大,表明进程是CPU密集型运算,执行优先级会降低,数值越小,表明进程是I&#x2F;O密集型运算,执行优先级会提高</li></ul><h3 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h3><p><code>kill 进程号</code>  </p><p>强制非法用户下线</p><p><img src="https://cdn.qingweico.cn/blog/5ef2e89114195aa594bfed3d.png" alt="1588386912261"></p><p><em><img src="https://cdn.qingweico.cn/blog/5ef2e89f14195aa594bff219.png" alt="1588387069698"></em></p><p><code>killall 进程名称</code> :            通过名称终止多个进程</p><p><code>kill -9 进程号</code>   :             强制终止某个进程</p><h3 id="查看进程树"><a href="#查看进程树" class="headerlink" title="查看进程树"></a>查看进程树</h3><p><code>pstree 【选项】</code></p><p>【选项】  <code>-p</code>   显示进程的PID    <code>-u  </code> 显示进程的所属用户名</p><h3 id="strace命令"><a href="#strace命令" class="headerlink" title="strace命令"></a>strace命令</h3><h2 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h2><p><code>systemctl status firewalld</code>  查看当前防火墙的状态(重启restart,终止stop,开始,start)</p><h3 id="查看服务名"><a href="#查看服务名" class="headerlink" title="查看服务名"></a>查看服务名</h3><p><code>setup</code>  或者  <code>systemctl  list-unit-files</code> </p><h3 id="动态监控服务"><a href="#动态监控服务" class="headerlink" title="动态监控服务"></a>动态监控服务</h3><p><code>top -u 用户名</code>: 监视特定用户</p><p><img src="https://cdn.qingweico.cn/blog/5ef2e89f14195aa594bff21b.png" alt="1588392949656"></p><p><code>top 回车 k 回车 进程号 </code>: 选择要终止的进程</p><p><strong>设定动态刷新的时间(默认是3秒)</strong></p><p><code>top -d 时间间隔(s)</code></p><p><strong>字母q可以退出动态监控界面</strong></p><h3 id="监控网络状态"><a href="#监控网络状态" class="headerlink" title="监控网络状态"></a>监控网络状态</h3><p><code>netstat -anp</code> 查看系统所有的网络服务 <code>-an</code>:按一定顺序排列输出 <code>-p</code> :显示哪个进程在调用  <code>-t </code> :显示TCP传输协议的连线状况</p><p><code>netstat -anp | grep 网络服务名称</code> 查看单个网络服务</p><h2 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h2><p>安装未安装的rpm包时,使用rpm包全名且后跟rpm包的路径,而查询或者卸载时直接使用包名,系统会从数据库中寻找该rpm包的信息,所以可以在任意位置查询或卸载该rpm包</p><p><em><img src="https://cdn.qingweico.cn/blog/5ef2e8a614195aa594bff3e6.png" alt="1589100480404"></em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep 包名;  <span class="comment"># 查询rpm安装包</span></span><br><span class="line">rpm -e --nodeps 包名 ;<span class="comment"># 强行卸载rpm安装包  erase</span></span><br><span class="line">rpm -ivh rmp包全名;   <span class="comment"># 安装rpm文件</span></span><br></pre></td></tr></table></figure><p><code>-i</code> 代表安装(install)</p><p><code>-v</code> 代表显示详细信息 verbose</p><p><code>-h </code> 显示详细信息 hash</p><p><code>--nodeps</code> 不检测依赖性</p><p><code>rpm -ql</code> 查询rpm包的安装位置   <code>l</code> list    <code>q</code>  query   <code>p</code>  package查询未安装包将要安装的信息(加全包名)</p><p><code>rpm -qf 系统文件</code> 查询系统文件属于那个rpm包</p><p><code>rpm -qR 包名</code> 查询已安装包的依赖</p><p><code>rpm -qRp 包全名</code> 查询未安装包的依赖 R requires</p><h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><p><em><strong>yum只是在线管理rpm包的命令,并不存在yum包,可以解决包和包之间的依赖</strong></em></p><p><code>yum list | grep 包名</code> 查看系统是否存在该rpm包</p><p><code>yum install 包名</code> 安装rpm文件</p><p><code>yum remove 包名 </code>    卸载rpm包 </p><p><code>yum update 包名</code>  升级rpm包 <em><strong>不加包名会升级所有的rpm包括linux内核,导致系统崩溃</strong></em></p><p><code>-y 选项</code>  自动回答yes</p><p><code>yum install -y man-pages</code> 安装函数使用手册</p><p><code>yum install -y lsof</code></p><p><code>yum install -y nc</code> </p><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><h3 id="脚本的执行方式"><a href="#脚本的执行方式" class="headerlink" title="脚本的执行方式"></a>脚本的执行方式</h3><ul><li>bash xx.sh</li><li>sh xx.sh</li><li>.&#x2F;sh</li><li>bash -x xxx.sh 查看脚本的执行过程</li></ul><h3 id="交互式定义变量-read"><a href="#交互式定义变量-read" class="headerlink" title="交互式定义变量(read)"></a>交互式定义变量(read)</h3><p>read [options] variables</p><ul><li>-p 定义提示用户的信息</li><li>-n 定于字符数</li><li>-s 不显示用户输入的内容</li><li>-t 定义超时时间</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从文件中读取一行数据复制给name</span></span><br><span class="line"><span class="built_in">read</span> name &lt; file</span><br></pre></td></tr></table></figure><p>定义有类型的变量(declare)</p><p>declare [options] variables&#x3D;value</p><p>unset variables: 取消赋值操作</p><ul><li>-i 将变量看成整数</li><li>-r 定义只读变量</li><li>-a 定义为普通数组</li><li>-A 定义关联数组</li><li>-x 将变量通过环境导出</li></ul><h3 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h3><h4 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a>本地变量</h4><p>当前用户自定义的变量。当前进程中进程有效(一个bash终端就是一个进程), 其他进程以及当前进程的子进程无效</p><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>当前进程有效, 并且能够被子进程调用</p><ul><li>env 查看当前用户的环境变量</li><li>set 查询当前用户的所有变量(临时变量和环境变量)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导出环境变量</span></span><br><span class="line"><span class="built_in">export</span> A=123 -&gt; <span class="built_in">declare</span> -x A=123</span><br><span class="line"><span class="comment"># 查看环境变量</span></span><br><span class="line"><span class="built_in">env</span> | grep A</span><br></pre></td></tr></table></figure><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前用户的bash信息 用户登陆时读取</span></span><br><span class="line"><span class="variable">$HOME</span>/.bashrc</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前用户的环境变量, 用户登陆时读取</span></span><br><span class="line"><span class="variable">$HOME</span>/.bash_profile</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前用户退出当前shell时读取</span></span><br><span class="line"><span class="variable">$HOME</span>/.bash_logout</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局的bash信息, 所有的用户都生效</span></span><br><span class="line">/etc/bashrc</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局环境变量信息</span></span><br><span class="line">/etc/profile</span><br></pre></td></tr></table></figure><p>用户登系统读取相关文件的顺序</p><ul><li><code>/etc/profile</code></li><li><code>$HOME/.bash_profile</code></li><li><code>$HOME/.bashrc</code></li><li><code>/etc/bashrc</code></li><li><code>$HOME/.bash_logout</code></li></ul><h4 id="系统变量-内置bash变量"><a href="#系统变量-内置bash变量" class="headerlink" title="系统变量(内置bash变量)"></a>系统变量(内置bash变量)</h4><table><thead><tr><th>内置变量</th><th>含义</th></tr></thead><tbody><tr><td>$?</td><td>上一条命令执行返回后的状态; 状态值为0表示正常执行, 非0表示执行异常或者错误</td></tr><tr><td>$0</td><td>当前执行的程序或脚本名</td></tr><tr><td>$#</td><td>脚本后面接的参数个数</td></tr><tr><td>$*</td><td>脚本后面所有参数, 参数当成一个整体输出, 每一个变量变量之间以空格隔开</td></tr><tr><td>$@</td><td>脚本后面所有的参数, 参数是独立的, 也是全部输出</td></tr><tr><td>$1-$9</td><td>脚本后面的参数位置 $1表示第一个位置参数</td></tr><tr><td>${10} - ${n}</td><td>扩展位置参数 {2个数字以上括起来}</td></tr><tr><td>$$</td><td>当前所在进程的进程号</td></tr><tr><td>$!</td><td>后台运行的最后一个进程号</td></tr><tr><td>!$</td><td>调用最后一条命令历史中的参数</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;\$0 = <span class="variable">$0</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;\$# = <span class="variable">$#</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;\$* = $*&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;\$@ = <span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;\$1 = <span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;\$2 = <span class="variable">$2</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;\$3 = <span class="variable">$3</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;\$10 = <span class="variable">$&#123;10&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test<span class="selector-class">.sh</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span> c d e f g h <span class="selector-tag">i</span> j</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$0</span> = ./test.sh</span><br><span class="line"><span class="variable">$#</span> = 10</span><br><span class="line">$* = a b c d e f g h i j</span><br><span class="line"><span class="variable">$@</span> = a b c d e f g h i j</span><br><span class="line"><span class="variable">$1</span> = a</span><br><span class="line"><span class="variable">$2</span> = b</span><br><span class="line"><span class="variable">$3</span> = c</span><br><span class="line"><span class="variable">$10</span> = j</span><br></pre></td></tr></table></figure><h3 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h3><ul><li>$(()) echo $((1+1))</li><li>$[]    echo $[3+2]</li><li>expr expr 10 * 5 (需要将*转义, 且操作数和*号之间一定要有空格)</li><li>let     n&#x3D;1; let n+&#x3D;1(不可以有空格)</li><li>2**2 次方运算 (expr不支持)</li><li>bc</li></ul><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><ul><li>test 条件表达式</li><li>[ 条件表达式 ]</li><li>[[ 条件表达式 ]] : 支持正则 (注:两边中括号和表达式之间都有空格</li></ul><h4 id="判断文件类型"><a href="#判断文件类型" class="headerlink" title="判断文件类型"></a>判断文件类型</h4><table><thead><tr><th align="left">判断参数</th><th align="center">含义</th></tr></thead><tbody><tr><td align="left">-e</td><td align="center">判断文件是否存在(任何类型文件)</td></tr><tr><td align="left">-f</td><td align="center">判段文件是否存在并且是一个普通文件</td></tr><tr><td align="left">-d</td><td align="center">判断文件是否存在并且是一个目录</td></tr><tr><td align="left">-L</td><td align="center">判断文件是否存在并且是一个软链接文件</td></tr><tr><td align="left">-b</td><td align="center">判断文件是否存在并且是一个块设备文件</td></tr><tr><td align="left">-S</td><td align="center">判断文件是否存在并且是一个套接字文件</td></tr><tr><td align="left">-c</td><td align="center">判断文件是否存在并且是一个字符文件</td></tr><tr><td align="left">-p</td><td align="center">判断文件是否存在并且是一个命名管道文件</td></tr><tr><td align="left">-s</td><td align="center">判断文件是否存在并且是一个非空文件</td></tr></tbody></table><h4 id="判断文件权限"><a href="#判断文件权限" class="headerlink" title="判断文件权限"></a>判断文件权限</h4><table><thead><tr><th align="left">判断参数</th><th align="center">含义</th></tr></thead><tbody><tr><td align="left">-r</td><td align="center">当前用户对其是否可读</td></tr><tr><td align="left">-w</td><td align="center">当前用户对其是否可写</td></tr><tr><td align="left">-x</td><td align="center">当前用户对其是否可读</td></tr><tr><td align="left">-u</td><td align="center">是否有suid 高级权限冒险位</td></tr><tr><td align="left">-g</td><td align="center">受否有sgid 高级权限强制位</td></tr><tr><td align="left">-k</td><td align="center">当是否育t位 高级权限强制位</td></tr></tbody></table><h4 id="判断整数"><a href="#判断整数" class="headerlink" title="判断整数"></a>判断整数</h4><table><thead><tr><th align="left">判断参数</th><th>含义</th></tr></thead><tbody><tr><td align="left">-eq</td><td>相等</td></tr><tr><td align="left">-ne</td><td>不等</td></tr><tr><td align="left">-gt</td><td>大于</td></tr><tr><td align="left">-lt</td><td>小于</td></tr><tr><td align="left">-ge</td><td>大于等于</td></tr><tr><td align="left">-le</td><td>小于等于</td></tr></tbody></table><h4 id="判断字符串"><a href="#判断字符串" class="headerlink" title="判断字符串"></a>判断字符串</h4><table><thead><tr><th align="left">判断参数</th><th>含义</th></tr></thead><tbody><tr><td align="left">-z</td><td>判断是否为空字符串(长度为0即为空)</td></tr><tr><td align="left">-n</td><td>判断是否为非空字符串</td></tr><tr><td align="left">&#x3D;</td><td>判断字符串是否相等</td></tr><tr><td align="left">!&#x3D;</td><td>判断字符串是否不相等</td></tr></tbody></table><h4 id="多重条件判断符"><a href="#多重条件判断符" class="headerlink" title="多重条件判断符"></a>多重条件判断符</h4><table><thead><tr><th>判断符号</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td>-a(all) 和 &amp;&amp;</td><td>逻辑与</td><td>[ $(id -u) -eq 0 ] &amp;&amp; echo “admin”          [ 0 -lt 1 -a 1 -lt 0 ]; echo $?</td></tr><tr><td>-o(or) 和 ||</td><td>逻辑或</td><td>[ 0 -lt 1 -o 1 -lt 0 ]; echo $?</td></tr></tbody></table><p>注: &amp;&amp; 前面的表达式为真时, 才会执行后面的代码</p><p>|| 前面的表达式为假, 才会执行后面的代码</p><p>; 用于分割命令或者表达式</p><h4 id="条件判断-C风格"><a href="#条件判断-C风格" class="headerlink" title="条件判断(C风格)"></a>条件判断(C风格)</h4><p><code> (( 1 == 3)); echo $?</code></p><p><code>[ &quot;hello&quot; = &quot;world&quot; ]; echo $? </code>  当使用[]时用加引号</p><p><code>a=&quot;hello&quot;;b=&quot;world&quot;;[ &quot;$a&quot; = &quot;$b&quot; ]; echo $?</code></p><p><code>[[ hello = hello ]]; echo $?</code> 使用[[]]时不用加引号</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Linux&quot;&gt;&lt;a href=&quot;#Linux&quot; class=&quot;headerlink&quot; title=&quot;Linux&quot;&gt;&lt;/a&gt;Linux&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;UNIX发展史&quot;&gt;&lt;a href=&quot;#UNIX发展史&quot; class=&quot;headerlink&quot; title=&quot;UNIX发展史&quot;&gt;&lt;/a&gt;UNIX发展史&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;1969年 美国贝尔实验室的肯.汤姆森(Ken Thompson)在PDP-机器上开发出了UNIX系统&lt;/li&gt;
&lt;li&gt;1971年 Dennis M.Ritchie(丹尼斯.里奇)发明了C语言 与ken Thompson一起开发UNIX系统 &lt;/li&gt;
&lt;li&gt;1973年 UNIX大部分的源码用C语言重写,因此提高了UNIX系统的可移植性&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Linux发展史&quot;&gt;&lt;a href=&quot;#Linux发展史&quot; class=&quot;headerlink&quot; title=&quot;Linux发展史&quot;&gt;&lt;/a&gt;Linux发展史&lt;/h2&gt;&lt;p&gt;   Linux系统诞生于1993年,由芬兰大学生李纳斯(Linus Torvalds)和后来陆续加入的众多的爱好者共同开发完成。&lt;br&gt;   Linux是开源软件,源代码开放的UnIX&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Java Concurrency in Practice</title>
    <link href="http://example.com/2020/03/24/Java-Concurrency-in-Practice/"/>
    <id>http://example.com/2020/03/24/Java-Concurrency-in-Practice/</id>
    <published>2020-03-24T04:21:04.000Z</published>
    <updated>2022-02-17T10:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>[TOC]</p><h2 id="1-线程安全性"><a href="#1-线程安全性" class="headerlink" title="1. 线程安全性"></a>1. 线程安全性</h2><p>对象的状态是指存储在状态变量(例如实例域或者静态域)中的数据</p><p>Java主要的同步机制是关键字synchronized,它提供了一种独占的加锁方式,但是”同步”这个术语还包括volatile类型的变量,显示锁(Explicit lock)以及原子变量</p><p>完全由线程安全的类构成的程序不一定就是线程安全的, 而在线程安全类中也可以包含非线程安全的类</p><p>正确性的含义就是:ok_hand: :某个类的行为与其规范完全一致</p><span id="more"></span><p>线程安全性的定义:taurus:: 当多个线程访问某个类时, 这个类始终都能表现出正确的行为, 那么就称这个类是线程安全的</p><p>或者这样定义:alien::一个在并发环境和单线程环境中都不会被破坏的类</p><p>类的无状态:yum::它既不包含任何域, 也不包含任何对其他类中域的引用. 计算过程中的临时状态仅存在于线程栈上的局部变量上, 并且只能由正在执行的线程访问</p><p>无状态对象一定是线程安全的</p><p>竞态条件:由于不恰当的执行时序而出现的不正确的结果</p><p>当某个计算的正确性取决于多个线程的交替执行时时序时, 就会产生竞态条件</p><p>数据竞争:rofl:: 如果在访问共享的非final类型的域时没有采取同步进行协同, 那么就会出现数据竞争</p><p>并非所有的竞态条件都是数据竞争, 同样并非所有的数据竞争都是竞态条件</p><p>复合操作: 包含一组必须以原子方式执行的操作</p><p>当在无状态的类中添加一个状态时, 如果该状态完全由线程安全的对象来管理,那么这个类仍是线程安全的</p><p>原子性: 一组语句作为一个不可分割的单元被执行</p><p>Java内置锁(synchronized) 线程在进入代码块之前会自动获得锁, 并且在退出同步代码块时自动释放锁(无论是正常退出还是异常退出)</p><p>重入:camel:: 当某个线程请求一个由其他线程持有的锁时, 发出的请求就会阻塞, 由于内置锁是可重入的, 因此如果某个线程试图获得一个已由它持有的锁时, 那么这个请求就会成功</p><p>如果在复合操作的执行过程中持有一个锁, 那么会使复合操作成为原子操作</p><p>一种常见的错误:x: 认为: 只有在写入共享变量时才需要同步 对于可能被多个线程同时访问的可变状态变量, 在访问它时都需要持有同一把锁</p><p>每个共享变量和可变的变量都应该只由一个锁来保护</p><p>串行访问:first_quarter_moon::多个线程以此以独占的方式访问对象, 而不是并发地访问</p><p>通常 在简单性和性能之间存在着相互制约因素, 当实现某个同步策略时, 一定不要盲目地为了性能而牺牲简单性(这可能会破坏安全性)</p><p>当执行时间较长的计算或者可能无法快速完成的操作时(网络I&#x2F;O或者控制台I&#x2F;O) 一定不要持有锁</p><h2 id="2-对象的共享"><a href="#2-对象的共享" class="headerlink" title="2. 对象的共享"></a>2. 对象的共享</h2><p>:one: 可见性</p><p>重排序(Reordering): 在没有同步的情况下,编译器、处理器以及运行时等都可能对操纵的执行顺序进行一些意想不到的调整</p><p>只要在某个线程中无法检测到重排序情况(即使在其他线程中可以很明显的的看到该线程中重排序),那么就无法确保线程中的操作将按照程序中指定的顺序来执行</p><p>在没有同步的情况下, 编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整</p><p>非原子的64位共享:shaved_ice::</p><p>Java内存模型要求,变量的读取操作和写入操作都必须是原子操作,但是对于非volatile类型的long和double变量,JVM允许将64位的读操作和写操作分解为两个32位的操作,当读取一个非volatile类型的long变量时,如果对该变量的读操作和写操作在不同的线程中执行,那么很可能会读取到某个值的高32位可另外一个值的低32位</p><p>在访问某个共享且可变的变量时要求所有的线程在同一个锁上同步,就是为了确保某个线程写入该变量的值对于其它线程来说都是可见的</p><p>加锁的含义不仅仅局限于互斥行为,还包括内存可见性,所有执行读操作或者写操作的线程都必须在同一个锁上同步</p><p>volatile的特性:</p><ul><li>保证了不同线程对这个变量进行操时的可见性, 即一个线程修改了某个变量的值, 这个新值对其他线程来说是立即可见的(实现可见性)</li><li>禁止进行指令重排序(实现有序性)</li></ul><p>volatile变量:telephone_receiver::当把变量声明为volatile类型后,编译器和运行时都会注意到这个变量是共享的,因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会缓存在寄存器或者对其他处理器不可见的地方,因此在读取volatile类型的变量时总会返回最新写入的值</p><p>volatile变量的内存可见性是基于内存屏障(Merry Barrier)实现的, JMM内部会有指令重排, 并且会有as-if-serial和happen-before的理念来保证指令的正确性</p><p>内存屏障就是基于4个基于汇编级别的关键字来禁止指令重排序的</p><p>volatile变量不会造成线程阻塞,因此volatile是一种比synchronized关键字更轻量级的同步机制</p><p>在当前大多数处理器架构上, 读取volatile变量的开销只比读取非volatile变量的开销略高一些</p><p>synchronized在内存可见性上的作用比volatile变量更强</p><p>加锁 （synchronized 悲观锁 互斥锁）并发执行 ——–&gt; 序列化执行</p><p>怎么理解volatile变量(volatile是怎么保证多个线程对被修饰变量的可见性): 从内存可见性的角度来看,写入volatile变量相当于退出同步代码块(即monitorexit 将本地缓存的变量值刷新到主存),而读取volatile变量就相当于进入同步代码块(即monitorenter 从主存中读取最新的值到本地缓存中)</p><p>虽然volatile变量很方便,但也存在一些局限性:santa::volatile变量通常用做某个变量完成、发生、中断或者状态的标志,但是volatile的语义不足以确保递增操作(count++)的原子性,除非你可以确保只有一个线程对变量执行写操作</p><p>:jack_o_lantern: 加锁机制既可以保证可见性又可以确保原子性, 而volatile变量只能确保可见性</p><p>:ear_of_rice: 当且仅当满足以下条件时才应该使用volatile变量:</p><ul><li>对变量的写入操作不依赖变量的当前值, 或者你能保证只有单个线程更新变量的值</li><li>该变量不会与其他变量一起纳入不变性条件中</li><li>在访问变量时不需要加锁</li></ul><p>:two: ​发布与逸出</p><p>发布: 指使一个对象能够在当前作用域范围之外的代码中使用</p><p>当某个不应该发布的对象被发布时，这种情况就被成为逸出</p><p>封装能够使得对程序的正确性进行分析变得可能，并使得无意中破坏设计约束条件变得困难</p><h2 id="6-任务的执行"><a href="#6-任务的执行" class="headerlink" title="6. 任务的执行"></a>6. 任务的执行</h2><p>在理想状态下, 各个任务之间是相互独立的:任务并不依赖于其他任务的状态、结界或者边界效应。独立性有助于实现并发</p><p>在正常的负载下,服务器应用程序应该同时表现出良好的吞吐量和快速的响应性</p><p>在单线程服务器中,阻塞不仅会推迟当前请求的完成时间:而且还会彻底阻止等待中的请求被处理,服务器的资源利用率非常低,因为当单线程在等待I&#x2F;O操作完成时,CPU将处于空闲状态</p><p>串行处理机制通常都无法提供高吞吐率或者快速响应性</p><h2 id="8-线程池的使用"><a href="#8-线程池的使用" class="headerlink" title="8. 线程池的使用"></a>8. 线程池的使用</h2><p>在线程池中:sailboat: , 如果任务依赖于其他任务,那么可能产生死锁</p><p>线程饥饿死锁(Thread Starvation Deadlock): 如果所有正在执行任务的线程都由于等待其他仍然处于工作队列中的任务而阻塞的现象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadPoolExecutor的通用构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>线程的创建和销毁:new::</p><p>线程池的基本大小(Cool Pool Size) 、最大大小(Maximum)以及存活的时间等因素共同负责线程的创建和销毁</p><p>基本大小也就是线程池的目标大小,即在没有任务执行时线程池的大小(在创建ThreadPoolExecutor初期, 线程并不会立即启动,而是等到有任务提交时才会启动(除非调用prestartAllCoreThreads),并且只有在工作队列满了的情况下才会创建超出这个数量的线程 </p><p>线程池的最大大小表示可以同时活动的线程数量的上限,如果某个线程的的空闲时间超过了等待时间, 那么将标记为可回收的,并且当线程池的当前大小超过了基本大小时,这个线程将被终止</p><p>管理队列任务:golf::</p><p>newFixedThreadPool和newSingleThreadPool在默认情况下将使用一个无界的LinkedBlockingQueue。如果所有的工作者线程都处于忙碌状态,那么任务将在队列中等候,如果任务持续快速地到达,并且超过了线程池处理它们的速度,那么队列将无限制地增加</p><p>使用有界队列(ArrayBlockingQueue、有界的LinkedBlockingQueue、PriorityBlockingQueue)有助于避免资源耗尽的情况发生</p><p>当队列已满时,新的任务该怎么办:ambulance::</p><p>:one: 在使用有界的工作队列时,队列的大小与线程池的大小必须一起调节,如果线程池较小而队列较大,那么有助于减少内存使用量,降低CPU的使用率,同时还可以减少上下文切换, 但付出的代价是可能限制吞吐量</p><p>:two:对于非常大的或者无界的线程池,可以通过使用SynchronousQueue来避免任务排队,以及直接将任务从生产者移交给工作者线程</p><p>newCachedThreadPool工厂方法中使用了SynchronousQueue</p><p>CPU工作线程数(线程池中的线程数量)设多少合适?<br>N<sub>threads</sub> &#x3D; N<sub>CPU</sub>  * U<sub>CPU</sub>  * (1 + W&#x2F;C)</p><ul><li><p>N<sub>CPU</sub> 是处理器的核数目, 可以通过Runtime.getRuntimr().availableProcessors()得到</p></li><li><p>U<sub>CPU</sub>是期望的CPU利用率(该值应该介于0-1之间)</p></li><li><p>W&#x2F;C是等待时间与计算时间的比率</p></li></ul><h2 id="13-显式锁"><a href="#13-显式锁" class="headerlink" title="13. 显式锁"></a>13. 显式锁</h2><p>在jdk5.0之前,在协调对共享对象的访问时可以使用的机制只有synchronized和volatile 在jdk5.0之后增加了一种新的机制: ReentrantLock</p><p>Reentrant并不是一种替代内置锁的办法,而是当内置加锁机制不使用时,作为一种可选择的高级功能</p><p>Lock提供了一种可轮询、无条定时的以及可中断的锁获取操作</p><h2 id="15-原子变量与非阻塞同步机制"><a href="#15-原子变量与非阻塞同步机制" class="headerlink" title="15. 原子变量与非阻塞同步机制"></a>15. 原子变量与非阻塞同步机制</h2><p>非阻塞算法用底层的原子机器指令(例如比较并交换指令)代替锁来确保数据在并发访问中的一致性</p><p>非阻塞算法可以使多个线程在竞争相同的数据时不会发生阻塞, 因此它能在粒度更细的层次上进行协调, 并且极大地减少调度开销。而且, 在非阻塞算法中不存在死锁和其他活跃性问题:smiley:</p><p>锁的劣势: 如果有多个线程同时请求锁, 那么JVM就要借助操作系统的功能。在没有竞争的情况下能够运行的很好, 但是在竞争的情况下, 其性能会由于上下文切换的开销和调度延迟而降低。如果锁持有的时间非常短, 那么当在不恰当的时间请求锁时, 使线程休眠将付出很高的代价。当一个线程等待锁时, 它不能做任何事情, 如果持有锁的线程被永久地阻塞(无限循环、死锁、活锁、其他的活跃性故障), 所有等待这个锁的线程就永远无法执行下去:sob:</p><p>:rainbow_flag:与锁相比, volatile变量是一种更轻量级的同步机制, 因为在使用这些变量时不会发生上下文切换或线程调度等操作。但是同样存在一些局限: 虽然它们提供了相似的可见性保证, 但不能用于构建原子的复合操作, 因此当一个变量依赖其他变量时或者当变量的新值依赖于旧值时, 就不能使用volatile变量</p><p>独占锁是一种悲观技术 </p><p>硬件对并发的支持:ng_man:: cas操作 cpu本身有指令支持   <code>cmpxchg </code> (汇编指令), 其不支持原子性, OS和JVM使用这些指令来实现锁和并发的数据结构, 但是在JDK5之前 Java还不能直接使用这些指令</p><p>cas: 借助冲突检查机制来判断在更新过程中是否存在来自其他线程的干扰, 如果存在, 这个操作将失败,并且可以重试(也可以不重试)</p><p>cas(Compare And Set &#x2F; Compare And Swap)是一种乐观的技术</p><p>关于cas失败重试问题: 如果cas失败时不执行任何操作, 那么是一种明智的做法,当cas失败时,意味着其他线程已经完成了你想要执行的操作</p><p>当竞争程度不高时,基于cas的计数器在性能上远远超过基于锁的计数器, 而在没有竞争时甚至更高</p><p>cas不一定就比悲观锁效率高,取决于单个线程的执行时间以及等待线程的数量</p><p>cas的主要缺点是: 它将使调用者处理竞争问题(通过重试、回退、放弃),而在锁中能自动处理竞争问题(线程在获得锁之前将一直阻塞)</p><p>cas存在的问题: ABA问题</p><ul><li>版本号(AtomticStampedReference)</li><li>使用 Boolean(AtomticMarkableReference)标记</li></ul><p>LOCK_IF_MP cmpxchg &#x3D;&#x3D;&#x3D; lock cmpxchg </p><p>单个cpu不用加lock</p><p>lock优先锁定cache line 其次锁定北桥信号</p><p>能用synchronized解决问题的 优先使用synchronized</p><p>CFS(操作系统线程调度算法)</p><p>JDK1.5之后synchronized内部有锁升级的过程 ,偏向锁 —&gt;自旋锁(轻量级cas锁)—-&gt;重量级锁（悲观排队锁）</p><p>内存屏障 (memory barrier) lfency sfency mfency</p><p>JVM对cas的支持: 在原子变量类(java.util.concurrent.atomic)中使用了这些底层的JVM支持为数字类型和引用类型提供一种高效的cas操作,而在java.util.concurrent中的大多数类在实现时则直接或者间接地使用了这些原子变量</p><p>原子变量类:atom_symbol: :原子变量比锁的粒度更细(原子变量将发生竞争的范围缩小到单个变量上),量级更轻,并且对于在多处理器系统上实现高性能的并发代码来说是非常关键的</p><p>尽管原子的变量类扩展了Number类,但是并没有扩展一些基本包装的类,例如Integer和Long 原因:基本类型的包装类是不可修改的,而原子变量类则是可修改的。在原子变量类中同样没有重新定义hashCode方法和equals方法,每个实例都是不同的,与其他可变对象相同, 也不宜用做基于散列的容器中的键值</p><p>AtomicInteger直接利用了硬件对并发的支持</p><p>在高度竞争的情况下, 锁的性能将超过原子变量的性能, 但在更真实的竞争情况下,原子变量的性能将超过锁的性能,这是因为锁在发起竞争时会挂起线程,从而降低了CPU的使用率和共享内存总线上的同步信号量</p><h2 id="16-Java内存模型"><a href="#16-Java内存模型" class="headerlink" title="16. Java内存模型"></a>16. Java内存模型</h2><p>Happens-Before :happy:</p><ul><li>程序顺序规则: 如果程序中的A操作在操作B之前,那么在线程中A操作将在B操作之前执行</li><li>监视器锁规则: 在监视器锁上的解锁操作必须在同一个监视器锁上的加锁操作之前执行</li><li>volatile变量规则: 对volatile变量的写入操作必须在对该变量的读操作之前执行</li><li>线程启动规则: 在线程上对Thread.start的调用必须在该线程中执行任何操作之前执行</li><li>线程结束规则: 线程中的任何操作都必须在其他线程检测到该线程已经结束之前执行,或者从Thread.join中成功返回,或者在调用Thread.isAlive时返回false</li><li>中断规则: 当一个线程在另一个线程上调用interrupt时,必须在被中断线程检测到interrupt调用之前执行(通过抛出InterruptedException,或者调用isInterrupted和interrupted)</li><li>终结器规则: 对象的构造函数必须在启动该对象的终结器之前执行完成</li><li>传递性: 如果操作A在操作B之前执行,并且操作B在操作C之前执行, 那么操作A必须在操作C之前执行</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-线程安全性&quot;&gt;&lt;a href=&quot;#1-线程安全性&quot; class=&quot;headerlink&quot; title=&quot;1. 线程安全性&quot;&gt;&lt;/a&gt;1. 线程安全性&lt;/h2&gt;&lt;p&gt;对象的状态是指存储在状态变量(例如实例域或者静态域)中的数据&lt;/p&gt;
&lt;p&gt;Java主要的同步机制是关键字synchronized,它提供了一种独占的加锁方式,但是”同步”这个术语还包括volatile类型的变量,显示锁(Explicit lock)以及原子变量&lt;/p&gt;
&lt;p&gt;完全由线程安全的类构成的程序不一定就是线程安全的, 而在线程安全类中也可以包含非线程安全的类&lt;/p&gt;
&lt;p&gt;正确性的含义就是:ok_hand: :某个类的行为与其规范完全一致&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="concurrency" scheme="http://example.com/tags/concurrency/"/>
    
  </entry>
  
  <entry>
    <title>oh-my-zsh安装</title>
    <link href="http://example.com/2020/03/12/oh-my-zsh%E5%AE%89%E8%A3%85/"/>
    <id>http://example.com/2020/03/12/oh-my-zsh%E5%AE%89%E8%A3%85/</id>
    <published>2020-03-12T10:46:05.000Z</published>
    <updated>2020-03-12T10:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>[TOC]</p><h2 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装zsh</span></span><br><span class="line">yum install zsh</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置默认shell为zsh</span></span><br><span class="line">chsh -s $(<span class="built_in">which</span> zsh)</span><br><span class="line"><span class="comment"># 切换为bash</span></span><br><span class="line">chsh -s /bin/bash</span><br></pre></td></tr></table></figure><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查设置是否成功</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查是否安装了zsh(安装oh-my-zsh之前必须安装zsh)</span></span><br><span class="line">zsh --version</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装oh-my-zsh(wget)</span></span><br><span class="line">sh -c <span class="string">&quot;<span class="subst">$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure><h2 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认主题</span></span><br><span class="line">ZSH_THEME=<span class="string">&quot;robbyrussel&quot;</span></span><br><span class="line"><span class="comment"># mira agnoster duellj(推荐的主题)</span></span><br><span class="line"><span class="comment"># 设置随机主题</span></span><br><span class="line">ZSH_THEME=<span class="string">&quot;random&quot;</span></span><br><span class="line"><span class="comment"># oh-my-zsh默认自带的主题放置的位置</span></span><br><span class="line">vim ~/.oh-my-zsh/themes</span><br></pre></td></tr></table></figure><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装语法高亮插件</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装自动补全插件</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在~/.zshrc中配置插件</span></span><br><span class="line">plugins=(git wd web-search <span class="built_in">history</span> history-substring-search zsh-syntax-highlighting zsh-autosuggestions)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新加载配置即可</span></span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;安装zsh&quot;&gt;&lt;a href=&quot;#安装zsh&quot; class=&quot;headerlink&quot; title=&quot;安装zsh&quot;&gt;&lt;/a&gt;安装zsh&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 安装zsh&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum install zsh&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 设置默认shell为zsh&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;chsh -s $(&lt;span class=&quot;built_in&quot;&gt;which&lt;/span&gt; zsh)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 切换为bash&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;chsh -s /bin/bash&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
</feed>
